VULKAN_CORE_H_ :: 1;
VERSION_1_0 :: 1;
API_VERSION_1_0 :: 4194304;
HEADER_VERSION :: 162;
HEADER_VERSION_COMPLETE :: 4202658;
NULL_HANDLE :: 0;
ATTACHMENT_UNUSED :: -1;
FALSE :: 0;
LOD_CLAMP_NONE :: 1000.000;
QUEUE_FAMILY_IGNORED :: -1;
REMAINING_ARRAY_LAYERS :: -1;
REMAINING_MIP_LEVELS :: -1;
SUBPASS_EXTERNAL :: -1;
TRUE :: 1;
WHOLE_SIZE :: -1;
MAX_MEMORY_TYPES :: 32;
MAX_MEMORY_HEAPS :: 16;
MAX_PHYSICAL_DEVICE_NAME_SIZE :: 256;
UUID_SIZE :: 16;
MAX_EXTENSION_NAME_SIZE :: 256;
MAX_DESCRIPTION_SIZE :: 256;
VERSION_1_1 :: 1;
API_VERSION_1_1 :: 4198400;
MAX_DEVICE_GROUP_SIZE :: 32;
LUID_SIZE :: 8;
QUEUE_FAMILY_EXTERNAL :: -2;
VERSION_1_2 :: 1;
API_VERSION_1_2 :: 4202496;
VERSION_1_3 :: 1;
API_VERSION_1_3 :: (0 << 29) | (1 << 22) | (3 << 12) | (0);
MAX_DRIVER_NAME_SIZE :: 256;
MAX_DRIVER_INFO_SIZE :: 256;
KHR_SURFACE :: 1;
KHR_SURFACE_SPEC_VERSION :: 25;
KHR_SURFACE_EXTENSION_NAME :: "VK_KHR_surface";
KHR_SWAPCHAIN :: 1;
KHR_SWAPCHAIN_SPEC_VERSION :: 70;
KHR_SWAPCHAIN_EXTENSION_NAME :: "VK_KHR_swapchain";
KHR_DISPLAY :: 1;
KHR_DISPLAY_SPEC_VERSION :: 23;
KHR_DISPLAY_EXTENSION_NAME :: "VK_KHR_display";
KHR_DISPLAY_SWAPCHAIN :: 1;
KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION :: 10;
KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME :: "VK_KHR_display_swapchain";
KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE :: 1;
KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION :: 3;
KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME :: "VK_KHR_sampler_mirror_clamp_to_edge";
KHR_MULTIVIEW :: 1;
KHR_MULTIVIEW_SPEC_VERSION :: 1;
KHR_MULTIVIEW_EXTENSION_NAME :: "VK_KHR_multiview";
KHR_GET_PHYSICAL_DEVICE_PROPERTIES2 :: 1;
KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION :: 2;
KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME :: "VK_KHR_get_physical_device_properties2";
KHR_DEVICE_GROUP :: 1;
KHR_DEVICE_GROUP_SPEC_VERSION :: 4;
KHR_DEVICE_GROUP_EXTENSION_NAME :: "VK_KHR_device_group";
KHR_SHADER_DRAW_PARAMETERS :: 1;
KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION :: 1;
KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME :: "VK_KHR_shader_draw_parameters";
KHR_MAINTENANCE1 :: 1;
KHR_MAINTENANCE1_SPEC_VERSION :: 2;
KHR_MAINTENANCE1_EXTENSION_NAME :: "VK_KHR_maintenance1";
KHR_DEVICE_GROUP_CREATION :: 1;
KHR_DEVICE_GROUP_CREATION_SPEC_VERSION :: 1;
KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME :: "VK_KHR_device_group_creation";
MAX_DEVICE_GROUP_SIZE_KHR :: 32;
KHR_EXTERNAL_MEMORY_CAPABILITIES :: 1;
KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION :: 1;
KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME :: "VK_KHR_external_memory_capabilities";
LUID_SIZE_KHR :: 8;
KHR_EXTERNAL_MEMORY :: 1;
KHR_EXTERNAL_MEMORY_SPEC_VERSION :: 1;
KHR_EXTERNAL_MEMORY_EXTENSION_NAME :: "VK_KHR_external_memory";
QUEUE_FAMILY_EXTERNAL_KHR :: -2;
KHR_EXTERNAL_MEMORY_FD :: 1;
KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION :: 1;
KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME :: "VK_KHR_external_memory_fd";
KHR_EXTERNAL_SEMAPHORE_CAPABILITIES :: 1;
KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION :: 1;
KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME :: "VK_KHR_external_semaphore_capabilities";
KHR_EXTERNAL_SEMAPHORE :: 1;
KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION :: 1;
KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME :: "VK_KHR_external_semaphore";
KHR_EXTERNAL_SEMAPHORE_FD :: 1;
KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION :: 1;
KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME :: "VK_KHR_external_semaphore_fd";
KHR_PUSH_DESCRIPTOR :: 1;
KHR_PUSH_DESCRIPTOR_SPEC_VERSION :: 2;
KHR_PUSH_DESCRIPTOR_EXTENSION_NAME :: "VK_KHR_push_descriptor";
KHR_SHADER_FLOAT16_INT8 :: 1;
KHR_SHADER_FLOAT16_INT8_SPEC_VERSION :: 1;
KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME :: "VK_KHR_shader_float16_int8";
KHR_16BIT_STORAGE :: 1;
KHR_16BIT_STORAGE_SPEC_VERSION :: 1;
KHR_16BIT_STORAGE_EXTENSION_NAME :: "VK_KHR_16bit_storage";
KHR_INCREMENTAL_PRESENT :: 1;
KHR_INCREMENTAL_PRESENT_SPEC_VERSION :: 1;
KHR_INCREMENTAL_PRESENT_EXTENSION_NAME :: "VK_KHR_incremental_present";
KHR_DESCRIPTOR_UPDATE_TEMPLATE :: 1;
KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION :: 1;
KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME :: "VK_KHR_descriptor_update_template";
KHR_IMAGELESS_FRAMEBUFFER :: 1;
KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION :: 1;
KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME :: "VK_KHR_imageless_framebuffer";
KHR_CREATE_RENDERPASS2 :: 1;
KHR_CREATE_RENDERPASS_2_SPEC_VERSION :: 1;
KHR_CREATE_RENDERPASS_2_EXTENSION_NAME :: "VK_KHR_create_renderpass2";
KHR_SHARED_PRESENTABLE_IMAGE :: 1;
KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION :: 1;
KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME :: "VK_KHR_shared_presentable_image";
KHR_EXTERNAL_FENCE_CAPABILITIES :: 1;
KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION :: 1;
KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME :: "VK_KHR_external_fence_capabilities";
KHR_EXTERNAL_FENCE :: 1;
KHR_EXTERNAL_FENCE_SPEC_VERSION :: 1;
KHR_EXTERNAL_FENCE_EXTENSION_NAME :: "VK_KHR_external_fence";
KHR_EXTERNAL_FENCE_FD :: 1;
KHR_EXTERNAL_FENCE_FD_SPEC_VERSION :: 1;
KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME :: "VK_KHR_external_fence_fd";
KHR_PERFORMANCE_QUERY :: 1;
KHR_PERFORMANCE_QUERY_SPEC_VERSION :: 1;
KHR_PERFORMANCE_QUERY_EXTENSION_NAME :: "VK_KHR_performance_query";
KHR_MAINTENANCE2 :: 1;
KHR_MAINTENANCE2_SPEC_VERSION :: 1;
KHR_MAINTENANCE2_EXTENSION_NAME :: "VK_KHR_maintenance2";
KHR_GET_SURFACE_CAPABILITIES2 :: 1;
KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION :: 1;
KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME :: "VK_KHR_get_surface_capabilities2";
KHR_VARIABLE_POINTERS :: 1;
KHR_VARIABLE_POINTERS_SPEC_VERSION :: 1;
KHR_VARIABLE_POINTERS_EXTENSION_NAME :: "VK_KHR_variable_pointers";
KHR_GET_DISPLAY_PROPERTIES2 :: 1;
KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION :: 1;
KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME :: "VK_KHR_get_display_properties2";
KHR_DEDICATED_ALLOCATION :: 1;
KHR_DEDICATED_ALLOCATION_SPEC_VERSION :: 3;
KHR_DEDICATED_ALLOCATION_EXTENSION_NAME :: "VK_KHR_dedicated_allocation";
KHR_STORAGE_BUFFER_STORAGE_CLASS :: 1;
KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION :: 1;
KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME :: "VK_KHR_storage_buffer_storage_class";
KHR_RELAXED_BLOCK_LAYOUT :: 1;
KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION :: 1;
KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME :: "VK_KHR_relaxed_block_layout";
KHR_GET_MEMORY_REQUIREMENTS2 :: 1;
KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION :: 1;
KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME :: "VK_KHR_get_memory_requirements2";
KHR_IMAGE_FORMAT_LIST :: 1;
KHR_IMAGE_FORMAT_LIST_SPEC_VERSION :: 1;
KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME :: "VK_KHR_image_format_list";
KHR_SAMPLER_YCBCR_CONVERSION :: 1;
KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION :: 14;
KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME :: "VK_KHR_sampler_ycbcr_conversion";
KHR_BIND_MEMORY2 :: 1;
KHR_BIND_MEMORY_2_SPEC_VERSION :: 1;
KHR_BIND_MEMORY_2_EXTENSION_NAME :: "VK_KHR_bind_memory2";
KHR_MAINTENANCE3 :: 1;
KHR_MAINTENANCE3_SPEC_VERSION :: 1;
KHR_MAINTENANCE3_EXTENSION_NAME :: "VK_KHR_maintenance3";
KHR_DRAW_INDIRECT_COUNT :: 1;
KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION :: 1;
KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME :: "VK_KHR_draw_indirect_count";
KHR_SHADER_SUBGROUP_EXTENDED_TYPES :: 1;
KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION :: 1;
KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME :: "VK_KHR_shader_subgroup_extended_types";
KHR_8BIT_STORAGE :: 1;
KHR_8BIT_STORAGE_SPEC_VERSION :: 1;
KHR_8BIT_STORAGE_EXTENSION_NAME :: "VK_KHR_8bit_storage";
KHR_SHADER_ATOMIC_INT64 :: 1;
KHR_SHADER_ATOMIC_INT64_SPEC_VERSION :: 1;
KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME :: "VK_KHR_shader_atomic_int64";
KHR_SHADER_CLOCK :: 1;
KHR_SHADER_CLOCK_SPEC_VERSION :: 1;
KHR_SHADER_CLOCK_EXTENSION_NAME :: "VK_KHR_shader_clock";
KHR_DRIVER_PROPERTIES :: 1;
KHR_DRIVER_PROPERTIES_SPEC_VERSION :: 1;
KHR_DRIVER_PROPERTIES_EXTENSION_NAME :: "VK_KHR_driver_properties";
MAX_DRIVER_NAME_SIZE_KHR :: 256;
MAX_DRIVER_INFO_SIZE_KHR :: 256;
KHR_SHADER_FLOAT_CONTROLS :: 1;
KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION :: 4;
KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME :: "VK_KHR_shader_float_controls";
KHR_DEPTH_STENCIL_RESOLVE :: 1;
KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION :: 1;
KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME :: "VK_KHR_depth_stencil_resolve";
KHR_SWAPCHAIN_MUTABLE_FORMAT :: 1;
KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION :: 1;
KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME :: "VK_KHR_swapchain_mutable_format";
KHR_TIMELINE_SEMAPHORE :: 1;
KHR_TIMELINE_SEMAPHORE_SPEC_VERSION :: 2;
KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME :: "VK_KHR_timeline_semaphore";
KHR_VULKAN_MEMORY_MODEL :: 1;
KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION :: 3;
KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME :: "VK_KHR_vulkan_memory_model";
KHR_SHADER_TERMINATE_INVOCATION :: 1;
KHR_SHADER_TERMINATE_INVOCATION_SPEC_VERSION :: 1;
KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME :: "VK_KHR_shader_terminate_invocation";
KHR_FRAGMENT_SHADING_RATE :: 1;
KHR_FRAGMENT_SHADING_RATE_SPEC_VERSION :: 1;
KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME :: "VK_KHR_fragment_shading_rate";
KHR_SPIRV_1_4 :: 1;
KHR_SPIRV_1_4_SPEC_VERSION :: 1;
KHR_SPIRV_1_4_EXTENSION_NAME :: "VK_KHR_spirv_1_4";
KHR_SURFACE_PROTECTED_CAPABILITIES :: 1;
KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION :: 1;
KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME :: "VK_KHR_surface_protected_capabilities";
KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS :: 1;
KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_SPEC_VERSION :: 1;
KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME :: "VK_KHR_separate_depth_stencil_layouts";
KHR_UNIFORM_BUFFER_STANDARD_LAYOUT :: 1;
KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION :: 1;
KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME :: "VK_KHR_uniform_buffer_standard_layout";
KHR_BUFFER_DEVICE_ADDRESS :: 1;
KHR_BUFFER_DEVICE_ADDRESS_SPEC_VERSION :: 1;
KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME :: "VK_KHR_buffer_device_address";
KHR_DEFERRED_HOST_OPERATIONS :: 1;
KHR_DEFERRED_HOST_OPERATIONS_SPEC_VERSION :: 4;
KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME :: "VK_KHR_deferred_host_operations";
KHR_PIPELINE_EXECUTABLE_PROPERTIES :: 1;
KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION :: 1;
KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME :: "VK_KHR_pipeline_executable_properties";
KHR_PIPELINE_LIBRARY :: 1;
KHR_PIPELINE_LIBRARY_SPEC_VERSION :: 1;
KHR_PIPELINE_LIBRARY_EXTENSION_NAME :: "VK_KHR_pipeline_library";
KHR_SHADER_NON_SEMANTIC_INFO :: 1;
KHR_SHADER_NON_SEMANTIC_INFO_SPEC_VERSION :: 1;
KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME :: "VK_KHR_shader_non_semantic_info";
KHR_COPY_COMMANDS2 :: 1;
KHR_COPY_COMMANDS_2_SPEC_VERSION :: 1;
KHR_COPY_COMMANDS_2_EXTENSION_NAME :: "VK_KHR_copy_commands2";
EXT_DEBUG_REPORT :: 1;
EXT_DEBUG_REPORT_SPEC_VERSION :: 9;
EXT_DEBUG_REPORT_EXTENSION_NAME :: "VK_EXT_debug_report";
NV_GLSL_SHADER :: 1;
NV_GLSL_SHADER_SPEC_VERSION :: 1;
NV_GLSL_SHADER_EXTENSION_NAME :: "VK_NV_glsl_shader";
EXT_DEPTH_RANGE_UNRESTRICTED :: 1;
EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION :: 1;
EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME :: "VK_EXT_depth_range_unrestricted";
IMG_FILTER_CUBIC :: 1;
IMG_FILTER_CUBIC_SPEC_VERSION :: 1;
IMG_FILTER_CUBIC_EXTENSION_NAME :: "VK_IMG_filter_cubic";
AMD_RASTERIZATION_ORDER :: 1;
AMD_RASTERIZATION_ORDER_SPEC_VERSION :: 1;
AMD_RASTERIZATION_ORDER_EXTENSION_NAME :: "VK_AMD_rasterization_order";
AMD_SHADER_TRINARY_MINMAX :: 1;
AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION :: 1;
AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME :: "VK_AMD_shader_trinary_minmax";
AMD_SHADER_EXPLICIT_VERTEX_PARAMETER :: 1;
AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION :: 1;
AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME :: "VK_AMD_shader_explicit_vertex_parameter";
EXT_DEBUG_MARKER :: 1;
EXT_DEBUG_MARKER_SPEC_VERSION :: 4;
EXT_DEBUG_MARKER_EXTENSION_NAME :: "VK_EXT_debug_marker";
AMD_GCN_SHADER :: 1;
AMD_GCN_SHADER_SPEC_VERSION :: 1;
AMD_GCN_SHADER_EXTENSION_NAME :: "VK_AMD_gcn_shader";
NV_DEDICATED_ALLOCATION :: 1;
NV_DEDICATED_ALLOCATION_SPEC_VERSION :: 1;
NV_DEDICATED_ALLOCATION_EXTENSION_NAME :: "VK_NV_dedicated_allocation";
EXT_TRANSFORM_FEEDBACK :: 1;
EXT_TRANSFORM_FEEDBACK_SPEC_VERSION :: 1;
EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME :: "VK_EXT_transform_feedback";
NVX_IMAGE_VIEW_HANDLE :: 1;
NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION :: 2;
NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME :: "VK_NVX_image_view_handle";
AMD_DRAW_INDIRECT_COUNT :: 1;
AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION :: 2;
AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME :: "VK_AMD_draw_indirect_count";
AMD_NEGATIVE_VIEWPORT_HEIGHT :: 1;
AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION :: 1;
AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME :: "VK_AMD_negative_viewport_height";
AMD_GPU_SHADER_HALF_FLOAT :: 1;
AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION :: 2;
AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME :: "VK_AMD_gpu_shader_half_float";
AMD_SHADER_BALLOT :: 1;
AMD_SHADER_BALLOT_SPEC_VERSION :: 1;
AMD_SHADER_BALLOT_EXTENSION_NAME :: "VK_AMD_shader_ballot";
AMD_TEXTURE_GATHER_BIAS_LOD :: 1;
AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION :: 1;
AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME :: "VK_AMD_texture_gather_bias_lod";
AMD_SHADER_INFO :: 1;
AMD_SHADER_INFO_SPEC_VERSION :: 1;
AMD_SHADER_INFO_EXTENSION_NAME :: "VK_AMD_shader_info";
AMD_SHADER_IMAGE_LOAD_STORE_LOD :: 1;
AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION :: 1;
AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME :: "VK_AMD_shader_image_load_store_lod";
NV_CORNER_SAMPLED_IMAGE :: 1;
NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION :: 2;
NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME :: "VK_NV_corner_sampled_image";
IMG_FORMAT_PVRTC :: 1;
IMG_FORMAT_PVRTC_SPEC_VERSION :: 1;
IMG_FORMAT_PVRTC_EXTENSION_NAME :: "VK_IMG_format_pvrtc";
NV_EXTERNAL_MEMORY_CAPABILITIES :: 1;
NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION :: 1;
NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME :: "VK_NV_external_memory_capabilities";
NV_EXTERNAL_MEMORY :: 1;
NV_EXTERNAL_MEMORY_SPEC_VERSION :: 1;
NV_EXTERNAL_MEMORY_EXTENSION_NAME :: "VK_NV_external_memory";
EXT_VALIDATION_FLAGS :: 1;
EXT_VALIDATION_FLAGS_SPEC_VERSION :: 2;
EXT_VALIDATION_FLAGS_EXTENSION_NAME :: "VK_EXT_validation_flags";
EXT_SHADER_SUBGROUP_BALLOT :: 1;
EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION :: 1;
EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME :: "VK_EXT_shader_subgroup_ballot";
EXT_SHADER_SUBGROUP_VOTE :: 1;
EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION :: 1;
EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME :: "VK_EXT_shader_subgroup_vote";
EXT_TEXTURE_COMPRESSION_ASTC_HDR :: 1;
EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION :: 1;
EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME :: "VK_EXT_texture_compression_astc_hdr";
EXT_ASTC_DECODE_MODE :: 1;
EXT_ASTC_DECODE_MODE_SPEC_VERSION :: 1;
EXT_ASTC_DECODE_MODE_EXTENSION_NAME :: "VK_EXT_astc_decode_mode";
EXT_CONDITIONAL_RENDERING :: 1;
EXT_CONDITIONAL_RENDERING_SPEC_VERSION :: 2;
EXT_CONDITIONAL_RENDERING_EXTENSION_NAME :: "VK_EXT_conditional_rendering";
NV_CLIP_SPACE_W_SCALING :: 1;
NV_CLIP_SPACE_W_SCALING_SPEC_VERSION :: 1;
NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME :: "VK_NV_clip_space_w_scaling";
EXT_DIRECT_MODE_DISPLAY :: 1;
EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION :: 1;
EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME :: "VK_EXT_direct_mode_display";
EXT_DISPLAY_SURFACE_COUNTER :: 1;
EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION :: 1;
EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME :: "VK_EXT_display_surface_counter";
EXT_DISPLAY_CONTROL :: 1;
EXT_DISPLAY_CONTROL_SPEC_VERSION :: 1;
EXT_DISPLAY_CONTROL_EXTENSION_NAME :: "VK_EXT_display_control";
GOOGLE_DISPLAY_TIMING :: 1;
GOOGLE_DISPLAY_TIMING_SPEC_VERSION :: 1;
GOOGLE_DISPLAY_TIMING_EXTENSION_NAME :: "VK_GOOGLE_display_timing";
NV_SAMPLE_MASK_OVERRIDE_COVERAGE :: 1;
NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION :: 1;
NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME :: "VK_NV_sample_mask_override_coverage";
NV_GEOMETRY_SHADER_PASSTHROUGH :: 1;
NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION :: 1;
NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME :: "VK_NV_geometry_shader_passthrough";
NV_VIEWPORT_ARRAY2 :: 1;
NV_VIEWPORT_ARRAY2_SPEC_VERSION :: 1;
NV_VIEWPORT_ARRAY2_EXTENSION_NAME :: "VK_NV_viewport_array2";
NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES :: 1;
NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION :: 1;
NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME :: "VK_NVX_multiview_per_view_attributes";
NV_VIEWPORT_SWIZZLE :: 1;
NV_VIEWPORT_SWIZZLE_SPEC_VERSION :: 1;
NV_VIEWPORT_SWIZZLE_EXTENSION_NAME :: "VK_NV_viewport_swizzle";
EXT_DISCARD_RECTANGLES :: 1;
EXT_DISCARD_RECTANGLES_SPEC_VERSION :: 1;
EXT_DISCARD_RECTANGLES_EXTENSION_NAME :: "VK_EXT_discard_rectangles";
EXT_CONSERVATIVE_RASTERIZATION :: 1;
EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION :: 1;
EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME :: "VK_EXT_conservative_rasterization";
EXT_DEPTH_CLIP_ENABLE :: 1;
EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION :: 1;
EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME :: "VK_EXT_depth_clip_enable";
EXT_SWAPCHAIN_COLORSPACE :: 1;
EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION :: 4;
EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME :: "VK_EXT_swapchain_colorspace";
EXT_HDR_METADATA :: 1;
EXT_HDR_METADATA_SPEC_VERSION :: 2;
EXT_HDR_METADATA_EXTENSION_NAME :: "VK_EXT_hdr_metadata";
EXT_EXTERNAL_MEMORY_DMA_BUF :: 1;
EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION :: 1;
EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME :: "VK_EXT_external_memory_dma_buf";
EXT_QUEUE_FAMILY_FOREIGN :: 1;
EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION :: 1;
EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME :: "VK_EXT_queue_family_foreign";
QUEUE_FAMILY_FOREIGN_EXT :: -3;
EXT_DEBUG_UTILS :: 1;
EXT_DEBUG_UTILS_SPEC_VERSION :: 2;
EXT_DEBUG_UTILS_EXTENSION_NAME :: "VK_EXT_debug_utils";
EXT_SAMPLER_FILTER_MINMAX :: 1;
EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION :: 2;
EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME :: "VK_EXT_sampler_filter_minmax";
AMD_GPU_SHADER_INT16 :: 1;
AMD_GPU_SHADER_INT16_SPEC_VERSION :: 2;
AMD_GPU_SHADER_INT16_EXTENSION_NAME :: "VK_AMD_gpu_shader_int16";
AMD_MIXED_ATTACHMENT_SAMPLES :: 1;
AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION :: 1;
AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME :: "VK_AMD_mixed_attachment_samples";
AMD_SHADER_FRAGMENT_MASK :: 1;
AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION :: 1;
AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME :: "VK_AMD_shader_fragment_mask";
EXT_INLINE_UNIFORM_BLOCK :: 1;
EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION :: 1;
EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME :: "VK_EXT_inline_uniform_block";
EXT_SHADER_STENCIL_EXPORT :: 1;
EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION :: 1;
EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME :: "VK_EXT_shader_stencil_export";
EXT_SAMPLE_LOCATIONS :: 1;
EXT_SAMPLE_LOCATIONS_SPEC_VERSION :: 1;
EXT_SAMPLE_LOCATIONS_EXTENSION_NAME :: "VK_EXT_sample_locations";
EXT_BLEND_OPERATION_ADVANCED :: 1;
EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION :: 2;
EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME :: "VK_EXT_blend_operation_advanced";
NV_FRAGMENT_COVERAGE_TO_COLOR :: 1;
NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION :: 1;
NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME :: "VK_NV_fragment_coverage_to_color";
NV_FRAMEBUFFER_MIXED_SAMPLES :: 1;
NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION :: 1;
NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME :: "VK_NV_framebuffer_mixed_samples";
NV_FILL_RECTANGLE :: 1;
NV_FILL_RECTANGLE_SPEC_VERSION :: 1;
NV_FILL_RECTANGLE_EXTENSION_NAME :: "VK_NV_fill_rectangle";
NV_SHADER_SM_BUILTINS :: 1;
NV_SHADER_SM_BUILTINS_SPEC_VERSION :: 1;
NV_SHADER_SM_BUILTINS_EXTENSION_NAME :: "VK_NV_shader_sm_builtins";
EXT_POST_DEPTH_COVERAGE :: 1;
EXT_POST_DEPTH_COVERAGE_SPEC_VERSION :: 1;
EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME :: "VK_EXT_post_depth_coverage";
EXT_IMAGE_DRM_FORMAT_MODIFIER :: 1;
EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION :: 1;
EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME :: "VK_EXT_image_drm_format_modifier";
EXT_VALIDATION_CACHE :: 1;
EXT_VALIDATION_CACHE_SPEC_VERSION :: 1;
EXT_VALIDATION_CACHE_EXTENSION_NAME :: "VK_EXT_validation_cache";
EXT_DESCRIPTOR_INDEXING :: 1;
EXT_DESCRIPTOR_INDEXING_SPEC_VERSION :: 2;
EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME :: "VK_EXT_descriptor_indexing";
EXT_SHADER_VIEWPORT_INDEX_LAYER :: 1;
EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION :: 1;
EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME :: "VK_EXT_shader_viewport_index_layer";
NV_SHADING_RATE_IMAGE :: 1;
NV_SHADING_RATE_IMAGE_SPEC_VERSION :: 3;
NV_SHADING_RATE_IMAGE_EXTENSION_NAME :: "VK_NV_shading_rate_image";
NV_RAY_TRACING :: 1;
NV_RAY_TRACING_SPEC_VERSION :: 3;
NV_RAY_TRACING_EXTENSION_NAME :: "VK_NV_ray_tracing";
SHADER_UNUSED_KHR :: -1;
SHADER_UNUSED_NV :: -1;
NV_REPRESENTATIVE_FRAGMENT_TEST :: 1;
NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION :: 2;
NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME :: "VK_NV_representative_fragment_test";
EXT_FILTER_CUBIC :: 1;
EXT_FILTER_CUBIC_SPEC_VERSION :: 3;
EXT_FILTER_CUBIC_EXTENSION_NAME :: "VK_EXT_filter_cubic";
QCOM_RENDER_PASS_SHADER_RESOLVE :: 1;
QCOM_RENDER_PASS_SHADER_RESOLVE_SPEC_VERSION :: 4;
QCOM_RENDER_PASS_SHADER_RESOLVE_EXTENSION_NAME :: "VK_QCOM_render_pass_shader_resolve";
EXT_GLOBAL_PRIORITY :: 1;
EXT_GLOBAL_PRIORITY_SPEC_VERSION :: 2;
EXT_GLOBAL_PRIORITY_EXTENSION_NAME :: "VK_EXT_global_priority";
EXT_EXTERNAL_MEMORY_HOST :: 1;
EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION :: 1;
EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME :: "VK_EXT_external_memory_host";
AMD_BUFFER_MARKER :: 1;
AMD_BUFFER_MARKER_SPEC_VERSION :: 1;
AMD_BUFFER_MARKER_EXTENSION_NAME :: "VK_AMD_buffer_marker";
AMD_PIPELINE_COMPILER_CONTROL :: 1;
AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION :: 1;
AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME :: "VK_AMD_pipeline_compiler_control";
EXT_CALIBRATED_TIMESTAMPS :: 1;
EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION :: 1;
EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME :: "VK_EXT_calibrated_timestamps";
AMD_SHADER_CORE_PROPERTIES :: 1;
AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION :: 2;
AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME :: "VK_AMD_shader_core_properties";
AMD_MEMORY_OVERALLOCATION_BEHAVIOR :: 1;
AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION :: 1;
AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME :: "VK_AMD_memory_overallocation_behavior";
EXT_VERTEX_ATTRIBUTE_DIVISOR :: 1;
EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION :: 3;
EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME :: "VK_EXT_vertex_attribute_divisor";
EXT_PIPELINE_CREATION_FEEDBACK :: 1;
EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION :: 1;
EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME :: "VK_EXT_pipeline_creation_feedback";
NV_SHADER_SUBGROUP_PARTITIONED :: 1;
NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION :: 1;
NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME :: "VK_NV_shader_subgroup_partitioned";
NV_COMPUTE_SHADER_DERIVATIVES :: 1;
NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION :: 1;
NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME :: "VK_NV_compute_shader_derivatives";
NV_MESH_SHADER :: 1;
NV_MESH_SHADER_SPEC_VERSION :: 1;
NV_MESH_SHADER_EXTENSION_NAME :: "VK_NV_mesh_shader";
NV_FRAGMENT_SHADER_BARYCENTRIC :: 1;
NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION :: 1;
NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME :: "VK_NV_fragment_shader_barycentric";
NV_SHADER_IMAGE_FOOTPRINT :: 1;
NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION :: 2;
NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME :: "VK_NV_shader_image_footprint";
NV_SCISSOR_EXCLUSIVE :: 1;
NV_SCISSOR_EXCLUSIVE_SPEC_VERSION :: 1;
NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME :: "VK_NV_scissor_exclusive";
NV_DEVICE_DIAGNOSTIC_CHECKPOINTS :: 1;
NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION :: 2;
NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME :: "VK_NV_device_diagnostic_checkpoints";
INTEL_SHADER_INTEGER_FUNCTIONS2 :: 1;
INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION :: 1;
INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME :: "VK_INTEL_shader_integer_functions2";
INTEL_PERFORMANCE_QUERY :: 1;
INTEL_PERFORMANCE_QUERY_SPEC_VERSION :: 2;
INTEL_PERFORMANCE_QUERY_EXTENSION_NAME :: "VK_INTEL_performance_query";
EXT_PCI_BUS_INFO :: 1;
EXT_PCI_BUS_INFO_SPEC_VERSION :: 2;
EXT_PCI_BUS_INFO_EXTENSION_NAME :: "VK_EXT_pci_bus_info";
AMD_DISPLAY_NATIVE_HDR :: 1;
AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION :: 1;
AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME :: "VK_AMD_display_native_hdr";
EXT_FRAGMENT_DENSITY_MAP :: 1;
EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION :: 1;
EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME :: "VK_EXT_fragment_density_map";
EXT_SCALAR_BLOCK_LAYOUT :: 1;
EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION :: 1;
EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME :: "VK_EXT_scalar_block_layout";
GOOGLE_HLSL_FUNCTIONALITY1 :: 1;
GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION :: 1;
GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME :: "VK_GOOGLE_hlsl_functionality1";
GOOGLE_DECORATE_STRING :: 1;
GOOGLE_DECORATE_STRING_SPEC_VERSION :: 1;
GOOGLE_DECORATE_STRING_EXTENSION_NAME :: "VK_GOOGLE_decorate_string";
EXT_SUBGROUP_SIZE_CONTROL :: 1;
EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION :: 2;
EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME :: "VK_EXT_subgroup_size_control";
AMD_SHADER_CORE_PROPERTIES2 :: 1;
AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION :: 1;
AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME :: "VK_AMD_shader_core_properties2";
AMD_DEVICE_COHERENT_MEMORY :: 1;
AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION :: 1;
AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME :: "VK_AMD_device_coherent_memory";
EXT_SHADER_IMAGE_ATOMIC_INT64 :: 1;
EXT_SHADER_IMAGE_ATOMIC_INT64_SPEC_VERSION :: 1;
EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME :: "VK_EXT_shader_image_atomic_int64";
EXT_MEMORY_BUDGET :: 1;
EXT_MEMORY_BUDGET_SPEC_VERSION :: 1;
EXT_MEMORY_BUDGET_EXTENSION_NAME :: "VK_EXT_memory_budget";
EXT_MEMORY_PRIORITY :: 1;
EXT_MEMORY_PRIORITY_SPEC_VERSION :: 1;
EXT_MEMORY_PRIORITY_EXTENSION_NAME :: "VK_EXT_memory_priority";
NV_DEDICATED_ALLOCATION_IMAGE_ALIASING :: 1;
NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION :: 1;
NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME :: "VK_NV_dedicated_allocation_image_aliasing";
EXT_BUFFER_DEVICE_ADDRESS :: 1;
EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION :: 2;
EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME :: "VK_EXT_buffer_device_address";
EXT_TOOLING_INFO :: 1;
EXT_TOOLING_INFO_SPEC_VERSION :: 1;
EXT_TOOLING_INFO_EXTENSION_NAME :: "VK_EXT_tooling_info";
EXT_SEPARATE_STENCIL_USAGE :: 1;
EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION :: 1;
EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME :: "VK_EXT_separate_stencil_usage";
EXT_VALIDATION_FEATURES :: 1;
EXT_VALIDATION_FEATURES_SPEC_VERSION :: 4;
EXT_VALIDATION_FEATURES_EXTENSION_NAME :: "VK_EXT_validation_features";
NV_COOPERATIVE_MATRIX :: 1;
NV_COOPERATIVE_MATRIX_SPEC_VERSION :: 1;
NV_COOPERATIVE_MATRIX_EXTENSION_NAME :: "VK_NV_cooperative_matrix";
NV_COVERAGE_REDUCTION_MODE :: 1;
NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION :: 1;
NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME :: "VK_NV_coverage_reduction_mode";
EXT_FRAGMENT_SHADER_INTERLOCK :: 1;
EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION :: 1;
EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME :: "VK_EXT_fragment_shader_interlock";
EXT_YCBCR_IMAGE_ARRAYS :: 1;
EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION :: 1;
EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME :: "VK_EXT_ycbcr_image_arrays";
EXT_HEADLESS_SURFACE :: 1;
EXT_HEADLESS_SURFACE_SPEC_VERSION :: 1;
EXT_HEADLESS_SURFACE_EXTENSION_NAME :: "VK_EXT_headless_surface";
EXT_LINE_RASTERIZATION :: 1;
EXT_LINE_RASTERIZATION_SPEC_VERSION :: 1;
EXT_LINE_RASTERIZATION_EXTENSION_NAME :: "VK_EXT_line_rasterization";
EXT_SHADER_ATOMIC_FLOAT :: 1;
EXT_SHADER_ATOMIC_FLOAT_SPEC_VERSION :: 1;
EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME :: "VK_EXT_shader_atomic_float";
EXT_HOST_QUERY_RESET :: 1;
EXT_HOST_QUERY_RESET_SPEC_VERSION :: 1;
EXT_HOST_QUERY_RESET_EXTENSION_NAME :: "VK_EXT_host_query_reset";
EXT_INDEX_TYPE_UINT8 :: 1;
EXT_INDEX_TYPE_UINT8_SPEC_VERSION :: 1;
EXT_INDEX_TYPE_UINT8_EXTENSION_NAME :: "VK_EXT_index_type_uint8";
EXT_EXTENDED_DYNAMIC_STATE :: 1;
EXT_EXTENDED_DYNAMIC_STATE_SPEC_VERSION :: 1;
EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME :: "VK_EXT_extended_dynamic_state";
EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION :: 1;
EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION :: 1;
EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME :: "VK_EXT_shader_demote_to_helper_invocation";
NV_DEVICE_GENERATED_COMMANDS :: 1;
NV_DEVICE_GENERATED_COMMANDS_SPEC_VERSION :: 3;
NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME :: "VK_NV_device_generated_commands";
EXT_TEXEL_BUFFER_ALIGNMENT :: 1;
EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION :: 1;
EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME :: "VK_EXT_texel_buffer_alignment";
QCOM_RENDER_PASS_TRANSFORM :: 1;
QCOM_RENDER_PASS_TRANSFORM_SPEC_VERSION :: 1;
QCOM_RENDER_PASS_TRANSFORM_EXTENSION_NAME :: "VK_QCOM_render_pass_transform";
EXT_DEVICE_MEMORY_REPORT :: 1;
EXT_DEVICE_MEMORY_REPORT_SPEC_VERSION :: 1;
EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME :: "VK_EXT_device_memory_report";
EXT_ROBUSTNESS2 :: 1;
EXT_ROBUSTNESS_2_SPEC_VERSION :: 1;
EXT_ROBUSTNESS_2_EXTENSION_NAME :: "VK_EXT_robustness2";
EXT_CUSTOM_BORDER_COLOR :: 1;
EXT_CUSTOM_BORDER_COLOR_SPEC_VERSION :: 12;
EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME :: "VK_EXT_custom_border_color";
GOOGLE_USER_TYPE :: 1;
GOOGLE_USER_TYPE_SPEC_VERSION :: 1;
GOOGLE_USER_TYPE_EXTENSION_NAME :: "VK_GOOGLE_user_type";
EXT_PRIVATE_DATA :: 1;
EXT_PRIVATE_DATA_SPEC_VERSION :: 1;
EXT_PRIVATE_DATA_EXTENSION_NAME :: "VK_EXT_private_data";
EXT_PIPELINE_CREATION_CACHE_CONTROL :: 1;
EXT_PIPELINE_CREATION_CACHE_CONTROL_SPEC_VERSION :: 3;
EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME :: "VK_EXT_pipeline_creation_cache_control";
NV_DEVICE_DIAGNOSTICS_CONFIG :: 1;
NV_DEVICE_DIAGNOSTICS_CONFIG_SPEC_VERSION :: 1;
NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME :: "VK_NV_device_diagnostics_config";
EXT_DESCRIPTOR_BUFFER :: 1;
EXT_DESCRIPTOR_BUFFER_SPEC_VERSION :: 1;
EXT_DESCRIPTOR_BUFFER_EXTENSION_NAME :: "VK_EXT_descriptor_buffer";
QCOM_RENDER_PASS_STORE_OPS :: 1;
QCOM_RENDER_PASS_STORE_OPS_SPEC_VERSION :: 2;
QCOM_RENDER_PASS_STORE_OPS_EXTENSION_NAME :: "VK_QCOM_render_pass_store_ops";
NV_FRAGMENT_SHADING_RATE_ENUMS :: 1;
NV_FRAGMENT_SHADING_RATE_ENUMS_SPEC_VERSION :: 1;
NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME :: "VK_NV_fragment_shading_rate_enums";
EXT_FRAGMENT_DENSITY_MAP2 :: 1;
EXT_FRAGMENT_DENSITY_MAP_2_SPEC_VERSION :: 1;
EXT_FRAGMENT_DENSITY_MAP_2_EXTENSION_NAME :: "VK_EXT_fragment_density_map2";
QCOM_ROTATED_COPY_COMMANDS :: 1;
QCOM_ROTATED_COPY_COMMANDS_SPEC_VERSION :: 0;
QCOM_ROTATED_COPY_COMMANDS_EXTENSION_NAME :: "VK_QCOM_rotated_copy_commands";
EXT_IMAGE_ROBUSTNESS :: 1;
EXT_IMAGE_ROBUSTNESS_SPEC_VERSION :: 1;
EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME :: "VK_EXT_image_robustness";
EXT_4444_FORMATS :: 1;
EXT_4444_FORMATS_SPEC_VERSION :: 1;
EXT_4444_FORMATS_EXTENSION_NAME :: "VK_EXT_4444_formats";
KHR_ACCELERATION_STRUCTURE :: 1;
KHR_ACCELERATION_STRUCTURE_SPEC_VERSION :: 11;
KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME :: "VK_KHR_acceleration_structure";
KHR_RAY_TRACING_PIPELINE :: 1;
KHR_RAY_TRACING_PIPELINE_SPEC_VERSION :: 1;
KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME :: "VK_KHR_ray_tracing_pipeline";
KHR_RAY_QUERY :: 1;
KHR_RAY_QUERY_SPEC_VERSION :: 1;
KHR_RAY_QUERY_EXTENSION_NAME :: "VK_KHR_ray_query";

Bool32 :: u32;
DeviceAddress :: u64;
DeviceSize :: u64;
Flags :: u32;
SampleMask :: u32;
Buffer :: *BufferT;
Image :: *ImageT;
Instance :: *InstanceT;
PhysicalDevice :: *PhysicalDeviceT;
Device :: *DeviceT;
Queue :: *QueueT;
Semaphore :: *SemaphoreT;
CommandBuffer :: *CommandBufferT;
Fence :: *FenceT;
DeviceMemory :: *DeviceMemoryT;
Event :: *EventT;
QueryPool :: *QueryPoolT;
BufferView :: *BufferViewT;
ImageView :: *ImageViewT;
ShaderModule :: *ShaderModuleT;
PipelineCache :: *PipelineCacheT;
PipelineLayout :: *PipelineLayoutT;
Pipeline :: *PipelineT;
RenderPass :: *RenderPassT;
DescriptorSetLayout :: *DescriptorSetLayoutT;
Sampler :: *SamplerT;
DescriptorSet :: *DescriptorSetT;
DescriptorPool :: *DescriptorPoolT;
Framebuffer :: *FramebufferT;
CommandPool :: *CommandPoolT;
AccessFlags :: Flags;
ImageAspectFlags :: Flags;
FormatFeatureFlags :: Flags;
ImageCreateFlags :: Flags;
SampleCountFlags :: Flags;
ImageUsageFlags :: Flags;
InstanceCreateFlags :: Flags;
MemoryHeapFlags :: Flags;
MemoryPropertyFlags :: Flags;
QueueFlags :: Flags;
DeviceCreateFlags :: Flags;
DeviceQueueCreateFlags :: Flags;
PipelineStageFlags :: Flags;
MemoryMapFlags :: Flags;
SparseMemoryBindFlags :: Flags;
SparseImageFormatFlags :: Flags;
FenceCreateFlags :: Flags;
SemaphoreCreateFlags :: Flags;
EventCreateFlags :: Flags;
QueryPipelineStatisticFlags :: Flags;
QueryPoolCreateFlags :: Flags;
QueryResultFlags :: Flags;
BufferCreateFlags :: Flags;
BufferUsageFlags :: Flags;
BufferViewCreateFlags :: Flags;
ImageViewCreateFlags :: Flags;
ShaderModuleCreateFlags :: Flags;
PipelineCacheCreateFlags :: Flags;
ColorComponentFlags :: Flags;
PipelineCreateFlags :: Flags;
PipelineShaderStageCreateFlags :: Flags;
CullModeFlags :: Flags;
PipelineVertexInputStateCreateFlags :: Flags;
PipelineInputAssemblyStateCreateFlags :: Flags;
PipelineTessellationStateCreateFlags :: Flags;
PipelineViewportStateCreateFlags :: Flags;
PipelineRasterizationStateCreateFlags :: Flags;
PipelineMultisampleStateCreateFlags :: Flags;
PipelineDepthStencilStateCreateFlags :: Flags;
PipelineColorBlendStateCreateFlags :: Flags;
PipelineDynamicStateCreateFlags :: Flags;
PipelineLayoutCreateFlags :: Flags;
ShaderStageFlags :: Flags;
SamplerCreateFlags :: Flags;
DescriptorPoolCreateFlags :: Flags;
DescriptorPoolResetFlags :: Flags;
DescriptorSetLayoutCreateFlags :: Flags;
AttachmentDescriptionFlags :: Flags;
DependencyFlags :: Flags;
FramebufferCreateFlags :: Flags;
RenderPassCreateFlags :: Flags;
SubpassDescriptionFlags :: Flags;
CommandPoolCreateFlags :: Flags;
CommandPoolResetFlags :: Flags;
CommandBufferUsageFlags :: Flags;
QueryControlFlags :: Flags;
CommandBufferResetFlags :: Flags;
StencilFaceFlags :: Flags;
PFN_AllocationFunction :: #type (
    pUserData : *void,
    size : u64,
    alignment : u64,
    allocationScope : SystemAllocationScope
) -> *void #c_call;
PFN_FreeFunction :: #type (
    pUserData : *void,
    pMemory : *void
) #c_call;
PFN_InternalAllocationNotification :: #type (
    pUserData : *void,
    size : u64,
    allocationType : InternalAllocationType,
    allocationScope : SystemAllocationScope
) #c_call;
PFN_InternalFreeNotification :: #type (
    pUserData : *void,
    size : u64,
    allocationType : InternalAllocationType,
    allocationScope : SystemAllocationScope
) #c_call;
PFN_ReallocationFunction :: #type (
    pUserData : *void,
    pOriginal : *void,
    size : u64,
    alignment : u64,
    allocationScope : SystemAllocationScope
) -> *void #c_call;
PFN_VoidFunction :: #type () #c_call;
PFN_CreateInstance :: #type (
    pCreateInfo : *InstanceCreateInfo,
    pAllocator : *AllocationCallbacks,
    pInstance : *Instance
) -> Result #c_call;
PFN_DestroyInstance :: #type (
    instance : Instance,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_EnumeratePhysicalDevices :: #type (
    instance : Instance,
    pPhysicalDeviceCount : *u32,
    pPhysicalDevices : *PhysicalDevice
) -> Result #c_call;
PFN_GetPhysicalDeviceFeatures :: #type (
    physicalDevice : PhysicalDevice,
    pFeatures : *PhysicalDeviceFeatures
) #c_call;
PFN_GetPhysicalDeviceFormatProperties :: #type (
    physicalDevice : PhysicalDevice,
    format : Format,
    pFormatProperties : *FormatProperties
) #c_call;
PFN_GetPhysicalDeviceImageFormatProperties :: #type (
    physicalDevice : PhysicalDevice,
    format : Format,
    type : ImageType,
    tiling : ImageTiling,
    usage : ImageUsageFlags,
    flags : ImageCreateFlags,
    pImageFormatProperties : *ImageFormatProperties
) -> Result #c_call;
PFN_GetPhysicalDeviceProperties :: #type (
    physicalDevice : PhysicalDevice,
    pProperties : *PhysicalDeviceProperties
) #c_call;
PFN_GetPhysicalDeviceQueueFamilyProperties :: #type (
    physicalDevice : PhysicalDevice,
    pQueueFamilyPropertyCount : *u32,
    pQueueFamilyProperties : *QueueFamilyProperties
) #c_call;
PFN_GetPhysicalDeviceMemoryProperties :: #type (
    physicalDevice : PhysicalDevice,
    pMemoryProperties : *PhysicalDeviceMemoryProperties
) #c_call;
PFN_GetInstanceProcAddr :: #type (
    instance : Instance,
    pName : *u8
) -> PFN_VoidFunction #c_call;
PFN_GetDeviceProcAddr :: #type (
    device : Device,
    pName : *u8
) -> PFN_VoidFunction #c_call;
PFN_CreateDevice :: #type (
    physicalDevice : PhysicalDevice,
    pCreateInfo : *DeviceCreateInfo,
    pAllocator : *AllocationCallbacks,
    pDevice : *Device
) -> Result #c_call;
PFN_DestroyDevice :: #type (
    device : Device,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_EnumerateInstanceExtensionProperties :: #type (
    pLayerName : *u8,
    pPropertyCount : *u32,
    pProperties : *ExtensionProperties
) -> Result #c_call;
PFN_EnumerateDeviceExtensionProperties :: #type (
    physicalDevice : PhysicalDevice,
    pLayerName : *u8,
    pPropertyCount : *u32,
    pProperties : *ExtensionProperties
) -> Result #c_call;
PFN_EnumerateInstanceLayerProperties :: #type (
    pPropertyCount : *u32,
    pProperties : *LayerProperties
) -> Result #c_call;
PFN_EnumerateDeviceLayerProperties :: #type (
    physicalDevice : PhysicalDevice,
    pPropertyCount : *u32,
    pProperties : *LayerProperties
) -> Result #c_call;
PFN_GetDeviceQueue :: #type (
    device : Device,
    queueFamilyIndex : u32,
    queueIndex : u32,
    pQueue : *Queue
) #c_call;
PFN_QueueSubmit :: #type (
    queue : Queue,
    submitCount : u32,
    pSubmits : *SubmitInfo,
    fence : Fence
) -> Result #c_call;
PFN_QueueWaitIdle :: #type (queue : Queue) -> Result #c_call;
PFN_DeviceWaitIdle :: #type (device : Device) -> Result #c_call;
PFN_AllocateMemory :: #type (
    device : Device,
    pAllocateInfo : *MemoryAllocateInfo,
    pAllocator : *AllocationCallbacks,
    pMemory : *DeviceMemory
) -> Result #c_call;
PFN_FreeMemory :: #type (
    device : Device,
    memory : DeviceMemory,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_MapMemory :: #type (
    device : Device,
    memory : DeviceMemory,
    offset : DeviceSize,
    size : DeviceSize,
    flags : MemoryMapFlags,
    ppData : **void
) -> Result #c_call;
PFN_UnmapMemory :: #type (
    device : Device,
    memory : DeviceMemory
) #c_call;
PFN_FlushMappedMemoryRanges :: #type (
    device : Device,
    memoryRangeCount : u32,
    pMemoryRanges : *MappedMemoryRange
) -> Result #c_call;
PFN_InvalidateMappedMemoryRanges :: #type (
    device : Device,
    memoryRangeCount : u32,
    pMemoryRanges : *MappedMemoryRange
) -> Result #c_call;
PFN_GetDeviceMemoryCommitment :: #type (
    device : Device,
    memory : DeviceMemory,
    pCommittedMemoryInBytes : *DeviceSize
) #c_call;
PFN_BindBufferMemory :: #type (
    device : Device,
    buffer : Buffer,
    memory : DeviceMemory,
    memoryOffset : DeviceSize
) -> Result #c_call;
PFN_BindImageMemory :: #type (
    device : Device,
    image : Image,
    memory : DeviceMemory,
    memoryOffset : DeviceSize
) -> Result #c_call;
PFN_GetBufferMemoryRequirements :: #type (
    device : Device,
    buffer : Buffer,
    pMemoryRequirements : *MemoryRequirements
) #c_call;
PFN_GetImageMemoryRequirements :: #type (
    device : Device,
    image : Image,
    pMemoryRequirements : *MemoryRequirements
) #c_call;
PFN_GetImageSparseMemoryRequirements :: #type (
    device : Device,
    image : Image,
    pSparseMemoryRequirementCount : *u32,
    pSparseMemoryRequirements : *SparseImageMemoryRequirements
) #c_call;
PFN_GetPhysicalDeviceSparseImageFormatProperties :: #type (
    physicalDevice : PhysicalDevice,
    format : Format,
    type : ImageType,
    samples : SampleCountFlagBits,
    usage : ImageUsageFlags,
    tiling : ImageTiling,
    pPropertyCount : *u32,
    pProperties : *SparseImageFormatProperties
) #c_call;
PFN_QueueBindSparse :: #type (
    queue : Queue,
    bindInfoCount : u32,
    pBindInfo : *BindSparseInfo,
    fence : Fence
) -> Result #c_call;
PFN_CreateFence :: #type (
    device : Device,
    pCreateInfo : *FenceCreateInfo,
    pAllocator : *AllocationCallbacks,
    pFence : *Fence
) -> Result #c_call;
PFN_DestroyFence :: #type (
    device : Device,
    fence : Fence,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_ResetFences :: #type (
    device : Device,
    fenceCount : u32,
    pFences : *Fence
) -> Result #c_call;
PFN_GetFenceStatus :: #type (
    device : Device,
    fence : Fence
) -> Result #c_call;
PFN_WaitForFences :: #type (
    device : Device,
    fenceCount : u32,
    pFences : *Fence,
    waitAll : Bool32,
    timeout : u64
) -> Result #c_call;
PFN_CreateSemaphore :: #type (
    device : Device,
    pCreateInfo : *SemaphoreCreateInfo,
    pAllocator : *AllocationCallbacks,
    pSemaphore : *Semaphore
) -> Result #c_call;
PFN_DestroySemaphore :: #type (
    device : Device,
    semaphore : Semaphore,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_CreateEvent :: #type (
    device : Device,
    pCreateInfo : *EventCreateInfo,
    pAllocator : *AllocationCallbacks,
    pEvent : *Event
) -> Result #c_call;
PFN_DestroyEvent :: #type (
    device : Device,
    event : Event,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_GetEventStatus :: #type (
    device : Device,
    event : Event
) -> Result #c_call;
PFN_SetEvent :: #type (
    device : Device,
    event : Event
) -> Result #c_call;
PFN_ResetEvent :: #type (
    device : Device,
    event : Event
) -> Result #c_call;
PFN_CreateQueryPool :: #type (
    device : Device,
    pCreateInfo : *QueryPoolCreateInfo,
    pAllocator : *AllocationCallbacks,
    pQueryPool : *QueryPool
) -> Result #c_call;
PFN_DestroyQueryPool :: #type (
    device : Device,
    queryPool : QueryPool,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_GetQueryPoolResults :: #type (
    device : Device,
    queryPool : QueryPool,
    firstQuery : u32,
    queryCount : u32,
    dataSize : u64,
    pData : *void,
    stride : DeviceSize,
    flags : QueryResultFlags
) -> Result #c_call;
PFN_CreateBuffer :: #type (
    device : Device,
    pCreateInfo : *BufferCreateInfo,
    pAllocator : *AllocationCallbacks,
    pBuffer : *Buffer
) -> Result #c_call;
PFN_DestroyBuffer :: #type (
    device : Device,
    buffer : Buffer,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_CreateBufferView :: #type (
    device : Device,
    pCreateInfo : *BufferViewCreateInfo,
    pAllocator : *AllocationCallbacks,
    pView : *BufferView
) -> Result #c_call;
PFN_DestroyBufferView :: #type (
    device : Device,
    bufferView : BufferView,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_CreateImage :: #type (
    device : Device,
    pCreateInfo : *ImageCreateInfo,
    pAllocator : *AllocationCallbacks,
    pImage : *Image
) -> Result #c_call;
PFN_DestroyImage :: #type (
    device : Device,
    image : Image,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_GetImageSubresourceLayout :: #type (
    device : Device,
    image : Image,
    pSubresource : *ImageSubresource,
    pLayout : *SubresourceLayout
) #c_call;
PFN_CreateImageView :: #type (
    device : Device,
    pCreateInfo : *ImageViewCreateInfo,
    pAllocator : *AllocationCallbacks,
    pView : *ImageView
) -> Result #c_call;
PFN_DestroyImageView :: #type (
    device : Device,
    imageView : ImageView,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_CreateShaderModule :: #type (
    device : Device,
    pCreateInfo : *ShaderModuleCreateInfo,
    pAllocator : *AllocationCallbacks,
    pShaderModule : *ShaderModule
) -> Result #c_call;
PFN_DestroyShaderModule :: #type (
    device : Device,
    shaderModule : ShaderModule,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_CreatePipelineCache :: #type (
    device : Device,
    pCreateInfo : *PipelineCacheCreateInfo,
    pAllocator : *AllocationCallbacks,
    pPipelineCache : *PipelineCache
) -> Result #c_call;
PFN_DestroyPipelineCache :: #type (
    device : Device,
    pipelineCache : PipelineCache,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_GetPipelineCacheData :: #type (
    device : Device,
    pipelineCache : PipelineCache,
    pDataSize : *u64,
    pData : *void
) -> Result #c_call;
PFN_MergePipelineCaches :: #type (
    device : Device,
    dstCache : PipelineCache,
    srcCacheCount : u32,
    pSrcCaches : *PipelineCache
) -> Result #c_call;
PFN_CreateGraphicsPipelines :: #type (
    device : Device,
    pipelineCache : PipelineCache,
    createInfoCount : u32,
    pCreateInfos : *GraphicsPipelineCreateInfo,
    pAllocator : *AllocationCallbacks,
    pPipelines : *Pipeline
) -> Result #c_call;
PFN_CreateComputePipelines :: #type (
    device : Device,
    pipelineCache : PipelineCache,
    createInfoCount : u32,
    pCreateInfos : *ComputePipelineCreateInfo,
    pAllocator : *AllocationCallbacks,
    pPipelines : *Pipeline
) -> Result #c_call;
PFN_DestroyPipeline :: #type (
    device : Device,
    pipeline : Pipeline,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_CreatePipelineLayout :: #type (
    device : Device,
    pCreateInfo : *PipelineLayoutCreateInfo,
    pAllocator : *AllocationCallbacks,
    pPipelineLayout : *PipelineLayout
) -> Result #c_call;
PFN_DestroyPipelineLayout :: #type (
    device : Device,
    pipelineLayout : PipelineLayout,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_CreateSampler :: #type (
    device : Device,
    pCreateInfo : *SamplerCreateInfo,
    pAllocator : *AllocationCallbacks,
    pSampler : *Sampler
) -> Result #c_call;
PFN_DestroySampler :: #type (
    device : Device,
    sampler : Sampler,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_CreateDescriptorSetLayout :: #type (
    device : Device,
    pCreateInfo : *DescriptorSetLayoutCreateInfo,
    pAllocator : *AllocationCallbacks,
    pSetLayout : *DescriptorSetLayout
) -> Result #c_call;
PFN_DestroyDescriptorSetLayout :: #type (
    device : Device,
    descriptorSetLayout : DescriptorSetLayout,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_CreateDescriptorPool :: #type (
    device : Device,
    pCreateInfo : *DescriptorPoolCreateInfo,
    pAllocator : *AllocationCallbacks,
    pDescriptorPool : *DescriptorPool
) -> Result #c_call;
PFN_DestroyDescriptorPool :: #type (
    device : Device,
    descriptorPool : DescriptorPool,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_ResetDescriptorPool :: #type (
    device : Device,
    descriptorPool : DescriptorPool,
    flags : DescriptorPoolResetFlags
) -> Result #c_call;
PFN_AllocateDescriptorSets :: #type (
    device : Device,
    pAllocateInfo : *DescriptorSetAllocateInfo,
    pDescriptorSets : *DescriptorSet
) -> Result #c_call;
PFN_FreeDescriptorSets :: #type (
    device : Device,
    descriptorPool : DescriptorPool,
    descriptorSetCount : u32,
    pDescriptorSets : *DescriptorSet
) -> Result #c_call;
PFN_UpdateDescriptorSets :: #type (
    device : Device,
    descriptorWriteCount : u32,
    pDescriptorWrites : *WriteDescriptorSet,
    descriptorCopyCount : u32,
    pDescriptorCopies : *CopyDescriptorSet
) #c_call;
PFN_CreateFramebuffer :: #type (
    device : Device,
    pCreateInfo : *FramebufferCreateInfo,
    pAllocator : *AllocationCallbacks,
    pFramebuffer : *Framebuffer
) -> Result #c_call;
PFN_DestroyFramebuffer :: #type (
    device : Device,
    framebuffer : Framebuffer,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_CreateRenderPass :: #type (
    device : Device,
    pCreateInfo : *RenderPassCreateInfo,
    pAllocator : *AllocationCallbacks,
    pRenderPass : *RenderPass
) -> Result #c_call;
PFN_DestroyRenderPass :: #type (
    device : Device,
    renderPass : RenderPass,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_GetRenderAreaGranularity :: #type (
    device : Device,
    renderPass : RenderPass,
    pGranularity : *Extent2D
) #c_call;
PFN_CreateCommandPool :: #type (
    device : Device,
    pCreateInfo : *CommandPoolCreateInfo,
    pAllocator : *AllocationCallbacks,
    pCommandPool : *CommandPool
) -> Result #c_call;
PFN_DestroyCommandPool :: #type (
    device : Device,
    commandPool : CommandPool,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_ResetCommandPool :: #type (
    device : Device,
    commandPool : CommandPool,
    flags : CommandPoolResetFlags
) -> Result #c_call;
PFN_AllocateCommandBuffers :: #type (
    device : Device,
    pAllocateInfo : *CommandBufferAllocateInfo,
    pCommandBuffers : *CommandBuffer
) -> Result #c_call;
PFN_FreeCommandBuffers :: #type (
    device : Device,
    commandPool : CommandPool,
    commandBufferCount : u32,
    pCommandBuffers : *CommandBuffer
) #c_call;
PFN_BeginCommandBuffer :: #type (
    commandBuffer : CommandBuffer,
    pBeginInfo : *CommandBufferBeginInfo
) -> Result #c_call;
PFN_EndCommandBuffer :: #type (commandBuffer : CommandBuffer) -> Result #c_call;
PFN_ResetCommandBuffer :: #type (
    commandBuffer : CommandBuffer,
    flags : CommandBufferResetFlags
) -> Result #c_call;
PFN_CmdBindPipeline :: #type (
    commandBuffer : CommandBuffer,
    pipelineBindPoint : PipelineBindPoint,
    pipeline : Pipeline
) #c_call;
PFN_CmdSetViewport :: #type (
    commandBuffer : CommandBuffer,
    firstViewport : u32,
    viewportCount : u32,
    pViewports : *Viewport
) #c_call;
PFN_CmdSetScissor :: #type (
    commandBuffer : CommandBuffer,
    firstScissor : u32,
    scissorCount : u32,
    pScissors : *Rect2D
) #c_call;
PFN_CmdSetLineWidth :: #type (
    commandBuffer : CommandBuffer,
    lineWidth : float32
) #c_call;
PFN_CmdSetDepthBias :: #type (
    commandBuffer : CommandBuffer,
    depthBiasConstantFactor : float32,
    depthBiasClamp : float32,
    depthBiasSlopeFactor : float32
) #c_call;
PFN_CmdSetBlendConstants :: #type (
    commandBuffer : CommandBuffer,
    blendConstants : *float32
) #c_call;
PFN_CmdSetDepthBounds :: #type (
    commandBuffer : CommandBuffer,
    minDepthBounds : float32,
    maxDepthBounds : float32
) #c_call;
PFN_CmdSetStencilCompareMask :: #type (
    commandBuffer : CommandBuffer,
    faceMask : StencilFaceFlags,
    compareMask : u32
) #c_call;
PFN_CmdSetStencilWriteMask :: #type (
    commandBuffer : CommandBuffer,
    faceMask : StencilFaceFlags,
    writeMask : u32
) #c_call;
PFN_CmdSetStencilReference :: #type (
    commandBuffer : CommandBuffer,
    faceMask : StencilFaceFlags,
    reference : u32
) #c_call;
PFN_CmdBindDescriptorSets :: #type (
    commandBuffer : CommandBuffer,
    pipelineBindPoint : PipelineBindPoint,
    layout : PipelineLayout,
    firstSet : u32,
    descriptorSetCount : u32,
    pDescriptorSets : *DescriptorSet,
    dynamicOffsetCount : u32,
    pDynamicOffsets : *u32
) #c_call;
PFN_CmdBindIndexBuffer :: #type (
    commandBuffer : CommandBuffer,
    buffer : Buffer,
    offset : DeviceSize,
    indexType : IndexType
) #c_call;
PFN_CmdBindVertexBuffers :: #type (
    commandBuffer : CommandBuffer,
    firstBinding : u32,
    bindingCount : u32,
    pBuffers : *Buffer,
    pOffsets : *DeviceSize
) #c_call;
PFN_CmdDraw :: #type (
    commandBuffer : CommandBuffer,
    vertexCount : u32,
    instanceCount : u32,
    firstVertex : u32,
    firstInstance : u32
) #c_call;
PFN_CmdDrawIndexed :: #type (
    commandBuffer : CommandBuffer,
    indexCount : u32,
    instanceCount : u32,
    firstIndex : u32,
    vertexOffset : s32,
    firstInstance : u32
) #c_call;
PFN_CmdDrawIndirect :: #type (
    commandBuffer : CommandBuffer,
    buffer : Buffer,
    offset : DeviceSize,
    drawCount : u32,
    stride : u32
) #c_call;
PFN_CmdDrawIndexedIndirect :: #type (
    commandBuffer : CommandBuffer,
    buffer : Buffer,
    offset : DeviceSize,
    drawCount : u32,
    stride : u32
) #c_call;
PFN_CmdDispatch :: #type (
    commandBuffer : CommandBuffer,
    groupCountX : u32,
    groupCountY : u32,
    groupCountZ : u32
) #c_call;
PFN_CmdDispatchIndirect :: #type (
    commandBuffer : CommandBuffer,
    buffer : Buffer,
    offset : DeviceSize
) #c_call;
PFN_CmdCopyBuffer :: #type (
    commandBuffer : CommandBuffer,
    srcBuffer : Buffer,
    dstBuffer : Buffer,
    regionCount : u32,
    pRegions : *BufferCopy
) #c_call;
PFN_CmdCopyImage :: #type (
    commandBuffer : CommandBuffer,
    srcImage : Image,
    srcImageLayout : ImageLayout,
    dstImage : Image,
    dstImageLayout : ImageLayout,
    regionCount : u32,
    pRegions : *ImageCopy
) #c_call;
PFN_CmdBlitImage :: #type (
    commandBuffer : CommandBuffer,
    srcImage : Image,
    srcImageLayout : ImageLayout,
    dstImage : Image,
    dstImageLayout : ImageLayout,
    regionCount : u32,
    pRegions : *ImageBlit,
    filter : Filter
) #c_call;
PFN_CmdCopyBufferToImage :: #type (
    commandBuffer : CommandBuffer,
    srcBuffer : Buffer,
    dstImage : Image,
    dstImageLayout : ImageLayout,
    regionCount : u32,
    pRegions : *BufferImageCopy
) #c_call;
PFN_CmdCopyImageToBuffer :: #type (
    commandBuffer : CommandBuffer,
    srcImage : Image,
    srcImageLayout : ImageLayout,
    dstBuffer : Buffer,
    regionCount : u32,
    pRegions : *BufferImageCopy
) #c_call;
PFN_CmdUpdateBuffer :: #type (
    commandBuffer : CommandBuffer,
    dstBuffer : Buffer,
    dstOffset : DeviceSize,
    dataSize : DeviceSize,
    pData : *void
) #c_call;
PFN_CmdFillBuffer :: #type (
    commandBuffer : CommandBuffer,
    dstBuffer : Buffer,
    dstOffset : DeviceSize,
    size : DeviceSize,
    data : u32
) #c_call;
PFN_CmdClearColorImage :: #type (
    commandBuffer : CommandBuffer,
    image : Image,
    imageLayout : ImageLayout,
    pColor : *ClearColorValue,
    rangeCount : u32,
    pRanges : *ImageSubresourceRange
) #c_call;
PFN_CmdClearDepthStencilImage :: #type (
    commandBuffer : CommandBuffer,
    image : Image,
    imageLayout : ImageLayout,
    pDepthStencil : *ClearDepthStencilValue,
    rangeCount : u32,
    pRanges : *ImageSubresourceRange
) #c_call;
PFN_CmdClearAttachments :: #type (
    commandBuffer : CommandBuffer,
    attachmentCount : u32,
    pAttachments : *ClearAttachment,
    rectCount : u32,
    pRects : *ClearRect
) #c_call;
PFN_CmdResolveImage :: #type (
    commandBuffer : CommandBuffer,
    srcImage : Image,
    srcImageLayout : ImageLayout,
    dstImage : Image,
    dstImageLayout : ImageLayout,
    regionCount : u32,
    pRegions : *ImageResolve
) #c_call;
PFN_CmdSetEvent :: #type (
    commandBuffer : CommandBuffer,
    event : Event,
    stageMask : PipelineStageFlags
) #c_call;
PFN_CmdResetEvent :: #type (
    commandBuffer : CommandBuffer,
    event : Event,
    stageMask : PipelineStageFlags
) #c_call;
PFN_CmdWaitEvents :: #type (
    commandBuffer : CommandBuffer,
    eventCount : u32,
    pEvents : *Event,
    srcStageMask : PipelineStageFlags,
    dstStageMask : PipelineStageFlags,
    memoryBarrierCount : u32,
    pMemoryBarriers : *MemoryBarrier,
    bufferMemoryBarrierCount : u32,
    pBufferMemoryBarriers : *BufferMemoryBarrier,
    imageMemoryBarrierCount : u32,
    pImageMemoryBarriers : *ImageMemoryBarrier
) #c_call;
PFN_CmdPipelineBarrier :: #type (
    commandBuffer : CommandBuffer,
    srcStageMask : PipelineStageFlags,
    dstStageMask : PipelineStageFlags,
    dependencyFlags : DependencyFlags,
    memoryBarrierCount : u32,
    pMemoryBarriers : *MemoryBarrier,
    bufferMemoryBarrierCount : u32,
    pBufferMemoryBarriers : *BufferMemoryBarrier,
    imageMemoryBarrierCount : u32,
    pImageMemoryBarriers : *ImageMemoryBarrier
) #c_call;
PFN_CmdBeginQuery :: #type (
    commandBuffer : CommandBuffer,
    queryPool : QueryPool,
    query : u32,
    flags : QueryControlFlags
) #c_call;
PFN_CmdEndQuery :: #type (
    commandBuffer : CommandBuffer,
    queryPool : QueryPool,
    query : u32
) #c_call;
PFN_CmdResetQueryPool :: #type (
    commandBuffer : CommandBuffer,
    queryPool : QueryPool,
    firstQuery : u32,
    queryCount : u32
) #c_call;
PFN_CmdWriteTimestamp :: #type (
    commandBuffer : CommandBuffer,
    pipelineStage : PipelineStageFlagBits,
    queryPool : QueryPool,
    query : u32
) #c_call;
PFN_CmdCopyQueryPoolResults :: #type (
    commandBuffer : CommandBuffer,
    queryPool : QueryPool,
    firstQuery : u32,
    queryCount : u32,
    dstBuffer : Buffer,
    dstOffset : DeviceSize,
    stride : DeviceSize,
    flags : QueryResultFlags
) #c_call;
PFN_CmdPushConstants :: #type (
    commandBuffer : CommandBuffer,
    layout : PipelineLayout,
    stageFlags : ShaderStageFlags,
    offset : u32,
    size : u32,
    pValues : *void
) #c_call;
PFN_CmdBeginRenderPass :: #type (
    commandBuffer : CommandBuffer,
    pRenderPassBegin : *RenderPassBeginInfo,
    contents : SubpassContents
) #c_call;
PFN_CmdNextSubpass :: #type (
    commandBuffer : CommandBuffer,
    contents : SubpassContents
) #c_call;
PFN_CmdEndRenderPass :: #type (commandBuffer : CommandBuffer) #c_call;
PFN_CmdExecuteCommands :: #type (
    commandBuffer : CommandBuffer,
    commandBufferCount : u32,
    pCommandBuffers : *CommandBuffer
) #c_call;
SamplerYcbcrConversion :: *SamplerYcbcrConversionT;
DescriptorUpdateTemplate :: *DescriptorUpdateTemplateT;
SubgroupFeatureFlags :: Flags;
PeerMemoryFeatureFlags :: Flags;
MemoryAllocateFlags :: Flags;
CommandPoolTrimFlags :: Flags;
DescriptorUpdateTemplateCreateFlags :: Flags;
ExternalMemoryHandleTypeFlags :: Flags;
ExternalMemoryFeatureFlags :: Flags;
ExternalFenceHandleTypeFlags :: Flags;
ExternalFenceFeatureFlags :: Flags;
FenceImportFlags :: Flags;
SemaphoreImportFlags :: Flags;
ExternalSemaphoreHandleTypeFlags :: Flags;
ExternalSemaphoreFeatureFlags :: Flags;
PhysicalDeviceVariablePointerFeatures :: PhysicalDeviceVariablePointersFeatures;
PhysicalDeviceShaderDrawParameterFeatures :: PhysicalDeviceShaderDrawParametersFeatures;
PFN_EnumerateInstanceVersion :: #type (pApiVersion : *u32) -> Result #c_call;
PFN_BindBufferMemory2 :: #type (
    device : Device,
    bindInfoCount : u32,
    pBindInfos : *BindBufferMemoryInfo
) -> Result #c_call;
PFN_BindImageMemory2 :: #type (
    device : Device,
    bindInfoCount : u32,
    pBindInfos : *BindImageMemoryInfo
) -> Result #c_call;
PFN_GetDeviceGroupPeerMemoryFeatures :: #type (
    device : Device,
    heapIndex : u32,
    localDeviceIndex : u32,
    remoteDeviceIndex : u32,
    pPeerMemoryFeatures : *PeerMemoryFeatureFlags
) #c_call;
PFN_CmdSetDeviceMask :: #type (
    commandBuffer : CommandBuffer,
    deviceMask : u32
) #c_call;
PFN_CmdDispatchBase :: #type (
    commandBuffer : CommandBuffer,
    baseGroupX : u32,
    baseGroupY : u32,
    baseGroupZ : u32,
    groupCountX : u32,
    groupCountY : u32,
    groupCountZ : u32
) #c_call;
PFN_EnumeratePhysicalDeviceGroups :: #type (
    instance : Instance,
    pPhysicalDeviceGroupCount : *u32,
    pPhysicalDeviceGroupProperties : *PhysicalDeviceGroupProperties
) -> Result #c_call;
PFN_GetImageMemoryRequirements2 :: #type (
    device : Device,
    pInfo : *ImageMemoryRequirementsInfo2,
    pMemoryRequirements : *MemoryRequirements2
) #c_call;
PFN_GetBufferMemoryRequirements2 :: #type (
    device : Device,
    pInfo : *BufferMemoryRequirementsInfo2,
    pMemoryRequirements : *MemoryRequirements2
) #c_call;
PFN_GetImageSparseMemoryRequirements2 :: #type (
    device : Device,
    pInfo : *ImageSparseMemoryRequirementsInfo2,
    pSparseMemoryRequirementCount : *u32,
    pSparseMemoryRequirements : *SparseImageMemoryRequirements2
) #c_call;
PFN_GetPhysicalDeviceFeatures2 :: #type (
    physicalDevice : PhysicalDevice,
    pFeatures : *PhysicalDeviceFeatures2
) #c_call;
PFN_GetPhysicalDeviceProperties2 :: #type (
    physicalDevice : PhysicalDevice,
    pProperties : *PhysicalDeviceProperties2
) #c_call;
PFN_GetPhysicalDeviceFormatProperties2 :: #type (
    physicalDevice : PhysicalDevice,
    format : Format,
    pFormatProperties : *FormatProperties2
) #c_call;
PFN_GetPhysicalDeviceImageFormatProperties2 :: #type (
    physicalDevice : PhysicalDevice,
    pImageFormatInfo : *PhysicalDeviceImageFormatInfo2,
    pImageFormatProperties : *ImageFormatProperties2
) -> Result #c_call;
PFN_GetPhysicalDeviceQueueFamilyProperties2 :: #type (
    physicalDevice : PhysicalDevice,
    pQueueFamilyPropertyCount : *u32,
    pQueueFamilyProperties : *QueueFamilyProperties2
) #c_call;
PFN_GetPhysicalDeviceMemoryProperties2 :: #type (
    physicalDevice : PhysicalDevice,
    pMemoryProperties : *PhysicalDeviceMemoryProperties2
) #c_call;
PFN_GetPhysicalDeviceSparseImageFormatProperties2 :: #type (
    physicalDevice : PhysicalDevice,
    pFormatInfo : *PhysicalDeviceSparseImageFormatInfo2,
    pPropertyCount : *u32,
    pProperties : *SparseImageFormatProperties2
) #c_call;
PFN_TrimCommandPool :: #type (
    device : Device,
    commandPool : CommandPool,
    flags : CommandPoolTrimFlags
) #c_call;
PFN_GetDeviceQueue2 :: #type (
    device : Device,
    pQueueInfo : *DeviceQueueInfo2,
    pQueue : *Queue
) #c_call;
PFN_CreateSamplerYcbcrConversion :: #type (
    device : Device,
    pCreateInfo : *SamplerYcbcrConversionCreateInfo,
    pAllocator : *AllocationCallbacks,
    pYcbcrConversion : *SamplerYcbcrConversion
) -> Result #c_call;
PFN_DestroySamplerYcbcrConversion :: #type (
    device : Device,
    ycbcrConversion : SamplerYcbcrConversion,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_CreateDescriptorUpdateTemplate :: #type (
    device : Device,
    pCreateInfo : *DescriptorUpdateTemplateCreateInfo,
    pAllocator : *AllocationCallbacks,
    pDescriptorUpdateTemplate : *DescriptorUpdateTemplate
) -> Result #c_call;
PFN_DestroyDescriptorUpdateTemplate :: #type (
    device : Device,
    descriptorUpdateTemplate : DescriptorUpdateTemplate,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_UpdateDescriptorSetWithTemplate :: #type (
    device : Device,
    descriptorSet : DescriptorSet,
    descriptorUpdateTemplate : DescriptorUpdateTemplate,
    pData : *void
) #c_call;
PFN_GetPhysicalDeviceExternalBufferProperties :: #type (
    physicalDevice : PhysicalDevice,
    pExternalBufferInfo : *PhysicalDeviceExternalBufferInfo,
    pExternalBufferProperties : *ExternalBufferProperties
) #c_call;
PFN_GetPhysicalDeviceExternalFenceProperties :: #type (
    physicalDevice : PhysicalDevice,
    pExternalFenceInfo : *PhysicalDeviceExternalFenceInfo,
    pExternalFenceProperties : *ExternalFenceProperties
) #c_call;
PFN_GetPhysicalDeviceExternalSemaphoreProperties :: #type (
    physicalDevice : PhysicalDevice,
    pExternalSemaphoreInfo : *PhysicalDeviceExternalSemaphoreInfo,
    pExternalSemaphoreProperties : *ExternalSemaphoreProperties
) #c_call;
PFN_GetDescriptorSetLayoutSupport :: #type (
    device : Device,
    pCreateInfo : *DescriptorSetLayoutCreateInfo,
    pSupport : *DescriptorSetLayoutSupport
) #c_call;
ResolveModeFlags :: Flags;
DescriptorBindingFlags :: Flags;
SemaphoreWaitFlags :: Flags;
PFN_CmdDrawIndirectCount :: #type (
    commandBuffer : CommandBuffer,
    buffer : Buffer,
    offset : DeviceSize,
    countBuffer : Buffer,
    countBufferOffset : DeviceSize,
    maxDrawCount : u32,
    stride : u32
) #c_call;
PFN_CmdDrawIndexedIndirectCount :: #type (
    commandBuffer : CommandBuffer,
    buffer : Buffer,
    offset : DeviceSize,
    countBuffer : Buffer,
    countBufferOffset : DeviceSize,
    maxDrawCount : u32,
    stride : u32
) #c_call;
PFN_CreateRenderPass2 :: #type (
    device : Device,
    pCreateInfo : *RenderPassCreateInfo2,
    pAllocator : *AllocationCallbacks,
    pRenderPass : *RenderPass
) -> Result #c_call;
PFN_CmdBeginRenderPass2 :: #type (
    commandBuffer : CommandBuffer,
    pRenderPassBegin : *RenderPassBeginInfo,
    pSubpassBeginInfo : *SubpassBeginInfo
) #c_call;
PFN_CmdNextSubpass2 :: #type (
    commandBuffer : CommandBuffer,
    pSubpassBeginInfo : *SubpassBeginInfo,
    pSubpassEndInfo : *SubpassEndInfo
) #c_call;
PFN_CmdEndRenderPass2 :: #type (
    commandBuffer : CommandBuffer,
    pSubpassEndInfo : *SubpassEndInfo
) #c_call;
PFN_ResetQueryPool :: #type (
    device : Device,
    queryPool : QueryPool,
    firstQuery : u32,
    queryCount : u32
) #c_call;
PFN_GetSemaphoreCounterValue :: #type (
    device : Device,
    semaphore : Semaphore,
    pValue : *u64
) -> Result #c_call;
PFN_WaitSemaphores :: #type (
    device : Device,
    pWaitInfo : *SemaphoreWaitInfo,
    timeout : u64
) -> Result #c_call;
PFN_SignalSemaphore :: #type (
    device : Device,
    pSignalInfo : *SemaphoreSignalInfo
) -> Result #c_call;
PFN_GetBufferDeviceAddress :: #type (
    device : Device,
    pInfo : *BufferDeviceAddressInfo
) -> DeviceAddress #c_call;
PFN_GetBufferOpaqueCaptureAddress :: #type (
    device : Device,
    pInfo : *BufferDeviceAddressInfo
) -> u64 #c_call;
PFN_GetDeviceMemoryOpaqueCaptureAddress :: #type (
    device : Device,
    pInfo : *DeviceMemoryOpaqueCaptureAddressInfo
) -> u64 #c_call;
SurfaceKHR :: *SurfaceKHRT;
CompositeAlphaFlagsKHR :: Flags;
SurfaceTransformFlagsKHR :: Flags;
PFN_DestroySurfaceKHR :: #type (
    instance : Instance,
    surface : SurfaceKHR,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_GetPhysicalDeviceSurfaceSupportKHR :: #type (
    physicalDevice : PhysicalDevice,
    queueFamilyIndex : u32,
    surface : SurfaceKHR,
    pSupported : *Bool32
) -> Result #c_call;
PFN_GetPhysicalDeviceSurfaceCapabilitiesKHR :: #type (
    physicalDevice : PhysicalDevice,
    surface : SurfaceKHR,
    pSurfaceCapabilities : *SurfaceCapabilitiesKHR
) -> Result #c_call;
PFN_GetPhysicalDeviceSurfaceFormatsKHR :: #type (
    physicalDevice : PhysicalDevice,
    surface : SurfaceKHR,
    pSurfaceFormatCount : *u32,
    pSurfaceFormats : *SurfaceFormatKHR
) -> Result #c_call;
PFN_GetPhysicalDeviceSurfacePresentModesKHR :: #type (
    physicalDevice : PhysicalDevice,
    surface : SurfaceKHR,
    pPresentModeCount : *u32,
    pPresentModes : *PresentModeKHR
) -> Result #c_call;
SwapchainKHR :: *SwapchainKHRT;
SwapchainCreateFlagsKHR :: Flags;
DeviceGroupPresentModeFlagsKHR :: Flags;
PFN_CreateSwapchainKHR :: #type (
    device : Device,
    pCreateInfo : *SwapchainCreateInfoKHR,
    pAllocator : *AllocationCallbacks,
    pSwapchain : *SwapchainKHR
) -> Result #c_call;
PFN_DestroySwapchainKHR :: #type (
    device : Device,
    swapchain : SwapchainKHR,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_GetSwapchainImagesKHR :: #type (
    device : Device,
    swapchain : SwapchainKHR,
    pSwapchainImageCount : *u32,
    pSwapchainImages : *Image
) -> Result #c_call;
PFN_AcquireNextImageKHR :: #type (
    device : Device,
    swapchain : SwapchainKHR,
    timeout : u64,
    semaphore : Semaphore,
    fence : Fence,
    pImageIndex : *u32
) -> Result #c_call;
PFN_QueuePresentKHR :: #type (
    queue : Queue,
    pPresentInfo : *PresentInfoKHR
) -> Result #c_call;
PFN_GetDeviceGroupPresentCapabilitiesKHR :: #type (
    device : Device,
    pDeviceGroupPresentCapabilities : *DeviceGroupPresentCapabilitiesKHR
) -> Result #c_call;
PFN_GetDeviceGroupSurfacePresentModesKHR :: #type (
    device : Device,
    surface : SurfaceKHR,
    pModes : *DeviceGroupPresentModeFlagsKHR
) -> Result #c_call;
PFN_GetPhysicalDevicePresentRectanglesKHR :: #type (
    physicalDevice : PhysicalDevice,
    surface : SurfaceKHR,
    pRectCount : *u32,
    pRects : *Rect2D
) -> Result #c_call;
PFN_AcquireNextImage2KHR :: #type (
    device : Device,
    pAcquireInfo : *AcquireNextImageInfoKHR,
    pImageIndex : *u32
) -> Result #c_call;
DisplayKHR :: *DisplayKHRT;
DisplayModeKHR :: *DisplayModeKHRT;
DisplayModeCreateFlagsKHR :: Flags;
DisplayPlaneAlphaFlagsKHR :: Flags;
DisplaySurfaceCreateFlagsKHR :: Flags;
PFN_GetPhysicalDeviceDisplayPropertiesKHR :: #type (
    physicalDevice : PhysicalDevice,
    pPropertyCount : *u32,
    pProperties : *DisplayPropertiesKHR
) -> Result #c_call;
PFN_GetPhysicalDeviceDisplayPlanePropertiesKHR :: #type (
    physicalDevice : PhysicalDevice,
    pPropertyCount : *u32,
    pProperties : *DisplayPlanePropertiesKHR
) -> Result #c_call;
PFN_GetDisplayPlaneSupportedDisplaysKHR :: #type (
    physicalDevice : PhysicalDevice,
    planeIndex : u32,
    pDisplayCount : *u32,
    pDisplays : *DisplayKHR
) -> Result #c_call;
PFN_GetDisplayModePropertiesKHR :: #type (
    physicalDevice : PhysicalDevice,
    display : DisplayKHR,
    pPropertyCount : *u32,
    pProperties : *DisplayModePropertiesKHR
) -> Result #c_call;
PFN_CreateDisplayModeKHR :: #type (
    physicalDevice : PhysicalDevice,
    display : DisplayKHR,
    pCreateInfo : *DisplayModeCreateInfoKHR,
    pAllocator : *AllocationCallbacks,
    pMode : *DisplayModeKHR
) -> Result #c_call;
PFN_GetDisplayPlaneCapabilitiesKHR :: #type (
    physicalDevice : PhysicalDevice,
    mode : DisplayModeKHR,
    planeIndex : u32,
    pCapabilities : *DisplayPlaneCapabilitiesKHR
) -> Result #c_call;
PFN_CreateDisplayPlaneSurfaceKHR :: #type (
    instance : Instance,
    pCreateInfo : *DisplaySurfaceCreateInfoKHR,
    pAllocator : *AllocationCallbacks,
    pSurface : *SurfaceKHR
) -> Result #c_call;
PFN_CreateSharedSwapchainsKHR :: #type (
    device : Device,
    swapchainCount : u32,
    pCreateInfos : *SwapchainCreateInfoKHR,
    pAllocator : *AllocationCallbacks,
    pSwapchains : *SwapchainKHR
) -> Result #c_call;
RenderPassMultiviewCreateInfoKHR :: RenderPassMultiviewCreateInfo;
PhysicalDeviceMultiviewFeaturesKHR :: PhysicalDeviceMultiviewFeatures;
PhysicalDeviceMultiviewPropertiesKHR :: PhysicalDeviceMultiviewProperties;
PhysicalDeviceFeatures2KHR :: PhysicalDeviceFeatures2;
PhysicalDeviceProperties2KHR :: PhysicalDeviceProperties2;
FormatProperties2KHR :: FormatProperties2;
ImageFormatProperties2KHR :: ImageFormatProperties2;
PhysicalDeviceImageFormatInfo2KHR :: PhysicalDeviceImageFormatInfo2;
QueueFamilyProperties2KHR :: QueueFamilyProperties2;
PhysicalDeviceMemoryProperties2KHR :: PhysicalDeviceMemoryProperties2;
SparseImageFormatProperties2KHR :: SparseImageFormatProperties2;
PhysicalDeviceSparseImageFormatInfo2KHR :: PhysicalDeviceSparseImageFormatInfo2;
PFN_GetPhysicalDeviceFeatures2KHR :: #type (
    physicalDevice : PhysicalDevice,
    pFeatures : *PhysicalDeviceFeatures2
) #c_call;
PFN_GetPhysicalDeviceProperties2KHR :: #type (
    physicalDevice : PhysicalDevice,
    pProperties : *PhysicalDeviceProperties2
) #c_call;
PFN_GetPhysicalDeviceFormatProperties2KHR :: #type (
    physicalDevice : PhysicalDevice,
    format : Format,
    pFormatProperties : *FormatProperties2
) #c_call;
PFN_GetPhysicalDeviceImageFormatProperties2KHR :: #type (
    physicalDevice : PhysicalDevice,
    pImageFormatInfo : *PhysicalDeviceImageFormatInfo2,
    pImageFormatProperties : *ImageFormatProperties2
) -> Result #c_call;
PFN_GetPhysicalDeviceQueueFamilyProperties2KHR :: #type (
    physicalDevice : PhysicalDevice,
    pQueueFamilyPropertyCount : *u32,
    pQueueFamilyProperties : *QueueFamilyProperties2
) #c_call;
PFN_GetPhysicalDeviceMemoryProperties2KHR :: #type (
    physicalDevice : PhysicalDevice,
    pMemoryProperties : *PhysicalDeviceMemoryProperties2
) #c_call;
PFN_GetPhysicalDeviceSparseImageFormatProperties2KHR :: #type (
    physicalDevice : PhysicalDevice,
    pFormatInfo : *PhysicalDeviceSparseImageFormatInfo2,
    pPropertyCount : *u32,
    pProperties : *SparseImageFormatProperties2
) #c_call;
PeerMemoryFeatureFlagsKHR :: PeerMemoryFeatureFlags;
PeerMemoryFeatureFlagBitsKHR :: PeerMemoryFeatureFlagBits;
MemoryAllocateFlagsKHR :: MemoryAllocateFlags;
MemoryAllocateFlagBitsKHR :: MemoryAllocateFlagBits;
MemoryAllocateFlagsInfoKHR :: MemoryAllocateFlagsInfo;
DeviceGroupRenderPassBeginInfoKHR :: DeviceGroupRenderPassBeginInfo;
DeviceGroupCommandBufferBeginInfoKHR :: DeviceGroupCommandBufferBeginInfo;
DeviceGroupSubmitInfoKHR :: DeviceGroupSubmitInfo;
DeviceGroupBindSparseInfoKHR :: DeviceGroupBindSparseInfo;
BindBufferMemoryDeviceGroupInfoKHR :: BindBufferMemoryDeviceGroupInfo;
BindImageMemoryDeviceGroupInfoKHR :: BindImageMemoryDeviceGroupInfo;
PFN_GetDeviceGroupPeerMemoryFeaturesKHR :: #type (
    device : Device,
    heapIndex : u32,
    localDeviceIndex : u32,
    remoteDeviceIndex : u32,
    pPeerMemoryFeatures : *PeerMemoryFeatureFlags
) #c_call;
PFN_CmdSetDeviceMaskKHR :: #type (
    commandBuffer : CommandBuffer,
    deviceMask : u32
) #c_call;
PFN_CmdDispatchBaseKHR :: #type (
    commandBuffer : CommandBuffer,
    baseGroupX : u32,
    baseGroupY : u32,
    baseGroupZ : u32,
    groupCountX : u32,
    groupCountY : u32,
    groupCountZ : u32
) #c_call;
CommandPoolTrimFlagsKHR :: CommandPoolTrimFlags;
PFN_TrimCommandPoolKHR :: #type (
    device : Device,
    commandPool : CommandPool,
    flags : CommandPoolTrimFlags
) #c_call;
PhysicalDeviceGroupPropertiesKHR :: PhysicalDeviceGroupProperties;
DeviceGroupDeviceCreateInfoKHR :: DeviceGroupDeviceCreateInfo;
PFN_EnumeratePhysicalDeviceGroupsKHR :: #type (
    instance : Instance,
    pPhysicalDeviceGroupCount : *u32,
    pPhysicalDeviceGroupProperties : *PhysicalDeviceGroupProperties
) -> Result #c_call;
ExternalMemoryHandleTypeFlagsKHR :: ExternalMemoryHandleTypeFlags;
ExternalMemoryHandleTypeFlagBitsKHR :: ExternalMemoryHandleTypeFlagBits;
ExternalMemoryFeatureFlagsKHR :: ExternalMemoryFeatureFlags;
ExternalMemoryFeatureFlagBitsKHR :: ExternalMemoryFeatureFlagBits;
ExternalMemoryPropertiesKHR :: ExternalMemoryProperties;
PhysicalDeviceExternalImageFormatInfoKHR :: PhysicalDeviceExternalImageFormatInfo;
ExternalImageFormatPropertiesKHR :: ExternalImageFormatProperties;
PhysicalDeviceExternalBufferInfoKHR :: PhysicalDeviceExternalBufferInfo;
ExternalBufferPropertiesKHR :: ExternalBufferProperties;
PhysicalDeviceIDPropertiesKHR :: PhysicalDeviceIDProperties;
PFN_GetPhysicalDeviceExternalBufferPropertiesKHR :: #type (
    physicalDevice : PhysicalDevice,
    pExternalBufferInfo : *PhysicalDeviceExternalBufferInfo,
    pExternalBufferProperties : *ExternalBufferProperties
) #c_call;
ExternalMemoryImageCreateInfoKHR :: ExternalMemoryImageCreateInfo;
ExternalMemoryBufferCreateInfoKHR :: ExternalMemoryBufferCreateInfo;
ExportMemoryAllocateInfoKHR :: ExportMemoryAllocateInfo;
PFN_GetMemoryFdKHR :: #type (
    device : Device,
    pGetFdInfo : *MemoryGetFdInfoKHR,
    pFd : *s32
) -> Result #c_call;
PFN_GetMemoryFdPropertiesKHR :: #type (
    device : Device,
    handleType : ExternalMemoryHandleTypeFlagBits,
    fd : s32,
    pMemoryFdProperties : *MemoryFdPropertiesKHR
) -> Result #c_call;
ExternalSemaphoreHandleTypeFlagsKHR :: ExternalSemaphoreHandleTypeFlags;
ExternalSemaphoreHandleTypeFlagBitsKHR :: ExternalSemaphoreHandleTypeFlagBits;
ExternalSemaphoreFeatureFlagsKHR :: ExternalSemaphoreFeatureFlags;
ExternalSemaphoreFeatureFlagBitsKHR :: ExternalSemaphoreFeatureFlagBits;
PhysicalDeviceExternalSemaphoreInfoKHR :: PhysicalDeviceExternalSemaphoreInfo;
ExternalSemaphorePropertiesKHR :: ExternalSemaphoreProperties;
PFN_GetPhysicalDeviceExternalSemaphorePropertiesKHR :: #type (
    physicalDevice : PhysicalDevice,
    pExternalSemaphoreInfo : *PhysicalDeviceExternalSemaphoreInfo,
    pExternalSemaphoreProperties : *ExternalSemaphoreProperties
) #c_call;
SemaphoreImportFlagsKHR :: SemaphoreImportFlags;
SemaphoreImportFlagBitsKHR :: SemaphoreImportFlagBits;
ExportSemaphoreCreateInfoKHR :: ExportSemaphoreCreateInfo;
PFN_ImportSemaphoreFdKHR :: #type (
    device : Device,
    pImportSemaphoreFdInfo : *ImportSemaphoreFdInfoKHR
) -> Result #c_call;
PFN_GetSemaphoreFdKHR :: #type (
    device : Device,
    pGetFdInfo : *SemaphoreGetFdInfoKHR,
    pFd : *s32
) -> Result #c_call;
PFN_CmdPushDescriptorSetKHR :: #type (
    commandBuffer : CommandBuffer,
    pipelineBindPoint : PipelineBindPoint,
    layout : PipelineLayout,
    set : u32,
    descriptorWriteCount : u32,
    pDescriptorWrites : *WriteDescriptorSet
) #c_call;
PFN_CmdPushDescriptorSetWithTemplateKHR :: #type (
    commandBuffer : CommandBuffer,
    descriptorUpdateTemplate : DescriptorUpdateTemplate,
    layout : PipelineLayout,
    set : u32,
    pData : *void
) #c_call;
PhysicalDeviceShaderFloat16Int8FeaturesKHR :: PhysicalDeviceShaderFloat16Int8Features;
PhysicalDeviceFloat16Int8FeaturesKHR :: PhysicalDeviceShaderFloat16Int8Features;
PhysicalDevice16BitStorageFeaturesKHR :: PhysicalDevice16BitStorageFeatures;
DescriptorUpdateTemplateKHR :: DescriptorUpdateTemplate;
DescriptorUpdateTemplateTypeKHR :: DescriptorUpdateTemplateType;
DescriptorUpdateTemplateCreateFlagsKHR :: DescriptorUpdateTemplateCreateFlags;
DescriptorUpdateTemplateEntryKHR :: DescriptorUpdateTemplateEntry;
DescriptorUpdateTemplateCreateInfoKHR :: DescriptorUpdateTemplateCreateInfo;
PFN_CreateDescriptorUpdateTemplateKHR :: #type (
    device : Device,
    pCreateInfo : *DescriptorUpdateTemplateCreateInfo,
    pAllocator : *AllocationCallbacks,
    pDescriptorUpdateTemplate : *DescriptorUpdateTemplate
) -> Result #c_call;
PFN_DestroyDescriptorUpdateTemplateKHR :: #type (
    device : Device,
    descriptorUpdateTemplate : DescriptorUpdateTemplate,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_UpdateDescriptorSetWithTemplateKHR :: #type (
    device : Device,
    descriptorSet : DescriptorSet,
    descriptorUpdateTemplate : DescriptorUpdateTemplate,
    pData : *void
) #c_call;
PhysicalDeviceImagelessFramebufferFeaturesKHR :: PhysicalDeviceImagelessFramebufferFeatures;
FramebufferAttachmentsCreateInfoKHR :: FramebufferAttachmentsCreateInfo;
FramebufferAttachmentImageInfoKHR :: FramebufferAttachmentImageInfo;
RenderPassAttachmentBeginInfoKHR :: RenderPassAttachmentBeginInfo;
RenderPassCreateInfo2KHR :: RenderPassCreateInfo2;
AttachmentDescription2KHR :: AttachmentDescription2;
AttachmentReference2KHR :: AttachmentReference2;
SubpassDescription2KHR :: SubpassDescription2;
SubpassDependency2KHR :: SubpassDependency2;
SubpassBeginInfoKHR :: SubpassBeginInfo;
SubpassEndInfoKHR :: SubpassEndInfo;
PFN_CreateRenderPass2KHR :: #type (
    device : Device,
    pCreateInfo : *RenderPassCreateInfo2,
    pAllocator : *AllocationCallbacks,
    pRenderPass : *RenderPass
) -> Result #c_call;
PFN_CmdBeginRenderPass2KHR :: #type (
    commandBuffer : CommandBuffer,
    pRenderPassBegin : *RenderPassBeginInfo,
    pSubpassBeginInfo : *SubpassBeginInfo
) #c_call;
PFN_CmdNextSubpass2KHR :: #type (
    commandBuffer : CommandBuffer,
    pSubpassBeginInfo : *SubpassBeginInfo,
    pSubpassEndInfo : *SubpassEndInfo
) #c_call;
PFN_CmdEndRenderPass2KHR :: #type (
    commandBuffer : CommandBuffer,
    pSubpassEndInfo : *SubpassEndInfo
) #c_call;
PFN_GetSwapchainStatusKHR :: #type (
    device : Device,
    swapchain : SwapchainKHR
) -> Result #c_call;
ExternalFenceHandleTypeFlagsKHR :: ExternalFenceHandleTypeFlags;
ExternalFenceHandleTypeFlagBitsKHR :: ExternalFenceHandleTypeFlagBits;
ExternalFenceFeatureFlagsKHR :: ExternalFenceFeatureFlags;
ExternalFenceFeatureFlagBitsKHR :: ExternalFenceFeatureFlagBits;
PhysicalDeviceExternalFenceInfoKHR :: PhysicalDeviceExternalFenceInfo;
ExternalFencePropertiesKHR :: ExternalFenceProperties;
PFN_GetPhysicalDeviceExternalFencePropertiesKHR :: #type (
    physicalDevice : PhysicalDevice,
    pExternalFenceInfo : *PhysicalDeviceExternalFenceInfo,
    pExternalFenceProperties : *ExternalFenceProperties
) #c_call;
FenceImportFlagsKHR :: FenceImportFlags;
FenceImportFlagBitsKHR :: FenceImportFlagBits;
ExportFenceCreateInfoKHR :: ExportFenceCreateInfo;
PFN_ImportFenceFdKHR :: #type (
    device : Device,
    pImportFenceFdInfo : *ImportFenceFdInfoKHR
) -> Result #c_call;
PFN_GetFenceFdKHR :: #type (
    device : Device,
    pGetFdInfo : *FenceGetFdInfoKHR,
    pFd : *s32
) -> Result #c_call;
PerformanceCounterDescriptionFlagsKHR :: Flags;
AcquireProfilingLockFlagsKHR :: Flags;
PFN_EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR :: #type (
    physicalDevice : PhysicalDevice,
    queueFamilyIndex : u32,
    pCounterCount : *u32,
    pCounters : *PerformanceCounterKHR,
    pCounterDescriptions : *PerformanceCounterDescriptionKHR
) -> Result #c_call;
PFN_GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR :: #type (
    physicalDevice : PhysicalDevice,
    pPerformanceQueryCreateInfo : *QueryPoolPerformanceCreateInfoKHR,
    pNumPasses : *u32
) #c_call;
PFN_AcquireProfilingLockKHR :: #type (
    device : Device,
    pInfo : *AcquireProfilingLockInfoKHR
) -> Result #c_call;
PFN_ReleaseProfilingLockKHR :: #type (device : Device) #c_call;
PointClippingBehaviorKHR :: PointClippingBehavior;
TessellationDomainOriginKHR :: TessellationDomainOrigin;
PhysicalDevicePointClippingPropertiesKHR :: PhysicalDevicePointClippingProperties;
RenderPassInputAttachmentAspectCreateInfoKHR :: RenderPassInputAttachmentAspectCreateInfo;
InputAttachmentAspectReferenceKHR :: InputAttachmentAspectReference;
ImageViewUsageCreateInfoKHR :: ImageViewUsageCreateInfo;
PipelineTessellationDomainOriginStateCreateInfoKHR :: PipelineTessellationDomainOriginStateCreateInfo;
PFN_GetPhysicalDeviceSurfaceCapabilities2KHR :: #type (
    physicalDevice : PhysicalDevice,
    pSurfaceInfo : *PhysicalDeviceSurfaceInfo2KHR,
    pSurfaceCapabilities : *SurfaceCapabilities2KHR
) -> Result #c_call;
PFN_GetPhysicalDeviceSurfaceFormats2KHR :: #type (
    physicalDevice : PhysicalDevice,
    pSurfaceInfo : *PhysicalDeviceSurfaceInfo2KHR,
    pSurfaceFormatCount : *u32,
    pSurfaceFormats : *SurfaceFormat2KHR
) -> Result #c_call;
PhysicalDeviceVariablePointerFeaturesKHR :: PhysicalDeviceVariablePointersFeatures;
PhysicalDeviceVariablePointersFeaturesKHR :: PhysicalDeviceVariablePointersFeatures;
PFN_GetPhysicalDeviceDisplayProperties2KHR :: #type (
    physicalDevice : PhysicalDevice,
    pPropertyCount : *u32,
    pProperties : *DisplayProperties2KHR
) -> Result #c_call;
PFN_GetPhysicalDeviceDisplayPlaneProperties2KHR :: #type (
    physicalDevice : PhysicalDevice,
    pPropertyCount : *u32,
    pProperties : *DisplayPlaneProperties2KHR
) -> Result #c_call;
PFN_GetDisplayModeProperties2KHR :: #type (
    physicalDevice : PhysicalDevice,
    display : DisplayKHR,
    pPropertyCount : *u32,
    pProperties : *DisplayModeProperties2KHR
) -> Result #c_call;
PFN_GetDisplayPlaneCapabilities2KHR :: #type (
    physicalDevice : PhysicalDevice,
    pDisplayPlaneInfo : *DisplayPlaneInfo2KHR,
    pCapabilities : *DisplayPlaneCapabilities2KHR
) -> Result #c_call;
MemoryDedicatedRequirementsKHR :: MemoryDedicatedRequirements;
MemoryDedicatedAllocateInfoKHR :: MemoryDedicatedAllocateInfo;
BufferMemoryRequirementsInfo2KHR :: BufferMemoryRequirementsInfo2;
ImageMemoryRequirementsInfo2KHR :: ImageMemoryRequirementsInfo2;
ImageSparseMemoryRequirementsInfo2KHR :: ImageSparseMemoryRequirementsInfo2;
MemoryRequirements2KHR :: MemoryRequirements2;
SparseImageMemoryRequirements2KHR :: SparseImageMemoryRequirements2;
PFN_GetImageMemoryRequirements2KHR :: #type (
    device : Device,
    pInfo : *ImageMemoryRequirementsInfo2,
    pMemoryRequirements : *MemoryRequirements2
) #c_call;
PFN_GetBufferMemoryRequirements2KHR :: #type (
    device : Device,
    pInfo : *BufferMemoryRequirementsInfo2,
    pMemoryRequirements : *MemoryRequirements2
) #c_call;
PFN_GetImageSparseMemoryRequirements2KHR :: #type (
    device : Device,
    pInfo : *ImageSparseMemoryRequirementsInfo2,
    pSparseMemoryRequirementCount : *u32,
    pSparseMemoryRequirements : *SparseImageMemoryRequirements2
) #c_call;
ImageFormatListCreateInfoKHR :: ImageFormatListCreateInfo;
SamplerYcbcrConversionKHR :: SamplerYcbcrConversion;
SamplerYcbcrModelConversionKHR :: SamplerYcbcrModelConversion;
SamplerYcbcrRangeKHR :: SamplerYcbcrRange;
ChromaLocationKHR :: ChromaLocation;
SamplerYcbcrConversionCreateInfoKHR :: SamplerYcbcrConversionCreateInfo;
SamplerYcbcrConversionInfoKHR :: SamplerYcbcrConversionInfo;
BindImagePlaneMemoryInfoKHR :: BindImagePlaneMemoryInfo;
ImagePlaneMemoryRequirementsInfoKHR :: ImagePlaneMemoryRequirementsInfo;
PhysicalDeviceSamplerYcbcrConversionFeaturesKHR :: PhysicalDeviceSamplerYcbcrConversionFeatures;
SamplerYcbcrConversionImageFormatPropertiesKHR :: SamplerYcbcrConversionImageFormatProperties;
PFN_CreateSamplerYcbcrConversionKHR :: #type (
    device : Device,
    pCreateInfo : *SamplerYcbcrConversionCreateInfo,
    pAllocator : *AllocationCallbacks,
    pYcbcrConversion : *SamplerYcbcrConversion
) -> Result #c_call;
PFN_DestroySamplerYcbcrConversionKHR :: #type (
    device : Device,
    ycbcrConversion : SamplerYcbcrConversion,
    pAllocator : *AllocationCallbacks
) #c_call;
BindBufferMemoryInfoKHR :: BindBufferMemoryInfo;
BindImageMemoryInfoKHR :: BindImageMemoryInfo;
PFN_BindBufferMemory2KHR :: #type (
    device : Device,
    bindInfoCount : u32,
    pBindInfos : *BindBufferMemoryInfo
) -> Result #c_call;
PFN_BindImageMemory2KHR :: #type (
    device : Device,
    bindInfoCount : u32,
    pBindInfos : *BindImageMemoryInfo
) -> Result #c_call;
PhysicalDeviceMaintenance3PropertiesKHR :: PhysicalDeviceMaintenance3Properties;
DescriptorSetLayoutSupportKHR :: DescriptorSetLayoutSupport;
PFN_GetDescriptorSetLayoutSupportKHR :: #type (
    device : Device,
    pCreateInfo : *DescriptorSetLayoutCreateInfo,
    pSupport : *DescriptorSetLayoutSupport
) #c_call;
PFN_CmdDrawIndirectCountKHR :: #type (
    commandBuffer : CommandBuffer,
    buffer : Buffer,
    offset : DeviceSize,
    countBuffer : Buffer,
    countBufferOffset : DeviceSize,
    maxDrawCount : u32,
    stride : u32
) #c_call;
PFN_CmdDrawIndexedIndirectCountKHR :: #type (
    commandBuffer : CommandBuffer,
    buffer : Buffer,
    offset : DeviceSize,
    countBuffer : Buffer,
    countBufferOffset : DeviceSize,
    maxDrawCount : u32,
    stride : u32
) #c_call;
PhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR :: PhysicalDeviceShaderSubgroupExtendedTypesFeatures;
PhysicalDevice8BitStorageFeaturesKHR :: PhysicalDevice8BitStorageFeatures;
PhysicalDeviceShaderAtomicInt64FeaturesKHR :: PhysicalDeviceShaderAtomicInt64Features;
DriverIdKHR :: DriverId;
ConformanceVersionKHR :: ConformanceVersion;
PhysicalDeviceDriverPropertiesKHR :: PhysicalDeviceDriverProperties;
ShaderFloatControlsIndependenceKHR :: ShaderFloatControlsIndependence;
PhysicalDeviceFloatControlsPropertiesKHR :: PhysicalDeviceFloatControlsProperties;
ResolveModeFlagBitsKHR :: ResolveModeFlagBits;
ResolveModeFlagsKHR :: ResolveModeFlags;
SubpassDescriptionDepthStencilResolveKHR :: SubpassDescriptionDepthStencilResolve;
PhysicalDeviceDepthStencilResolvePropertiesKHR :: PhysicalDeviceDepthStencilResolveProperties;
SemaphoreTypeKHR :: SemaphoreType;
SemaphoreWaitFlagBitsKHR :: SemaphoreWaitFlagBits;
SemaphoreWaitFlagsKHR :: SemaphoreWaitFlags;
PhysicalDeviceTimelineSemaphoreFeaturesKHR :: PhysicalDeviceTimelineSemaphoreFeatures;
PhysicalDeviceTimelineSemaphorePropertiesKHR :: PhysicalDeviceTimelineSemaphoreProperties;
SemaphoreTypeCreateInfoKHR :: SemaphoreTypeCreateInfo;
TimelineSemaphoreSubmitInfoKHR :: TimelineSemaphoreSubmitInfo;
SemaphoreWaitInfoKHR :: SemaphoreWaitInfo;
SemaphoreSignalInfoKHR :: SemaphoreSignalInfo;
PFN_GetSemaphoreCounterValueKHR :: #type (
    device : Device,
    semaphore : Semaphore,
    pValue : *u64
) -> Result #c_call;
PFN_WaitSemaphoresKHR :: #type (
    device : Device,
    pWaitInfo : *SemaphoreWaitInfo,
    timeout : u64
) -> Result #c_call;
PFN_SignalSemaphoreKHR :: #type (
    device : Device,
    pSignalInfo : *SemaphoreSignalInfo
) -> Result #c_call;
PhysicalDeviceVulkanMemoryModelFeaturesKHR :: PhysicalDeviceVulkanMemoryModelFeatures;
PFN_GetPhysicalDeviceFragmentShadingRatesKHR :: #type (
    physicalDevice : PhysicalDevice,
    pFragmentShadingRateCount : *u32,
    pFragmentShadingRates : *PhysicalDeviceFragmentShadingRateKHR
) -> Result #c_call;
PFN_CmdSetFragmentShadingRateKHR :: #type (
    commandBuffer : CommandBuffer,
    pFragmentSize : *Extent2D,
    combinerOps : *FragmentShadingRateCombinerOpKHR
) #c_call;
PhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR :: PhysicalDeviceSeparateDepthStencilLayoutsFeatures;
AttachmentReferenceStencilLayoutKHR :: AttachmentReferenceStencilLayout;
AttachmentDescriptionStencilLayoutKHR :: AttachmentDescriptionStencilLayout;
PhysicalDeviceUniformBufferStandardLayoutFeaturesKHR :: PhysicalDeviceUniformBufferStandardLayoutFeatures;
PhysicalDeviceBufferDeviceAddressFeaturesKHR :: PhysicalDeviceBufferDeviceAddressFeatures;
BufferDeviceAddressInfoKHR :: BufferDeviceAddressInfo;
BufferOpaqueCaptureAddressCreateInfoKHR :: BufferOpaqueCaptureAddressCreateInfo;
MemoryOpaqueCaptureAddressAllocateInfoKHR :: MemoryOpaqueCaptureAddressAllocateInfo;
DeviceMemoryOpaqueCaptureAddressInfoKHR :: DeviceMemoryOpaqueCaptureAddressInfo;
PFN_GetBufferDeviceAddressKHR :: #type (
    device : Device,
    pInfo : *BufferDeviceAddressInfo
) -> DeviceAddress #c_call;
PFN_GetBufferOpaqueCaptureAddressKHR :: #type (
    device : Device,
    pInfo : *BufferDeviceAddressInfo
) -> u64 #c_call;
PFN_GetDeviceMemoryOpaqueCaptureAddressKHR :: #type (
    device : Device,
    pInfo : *DeviceMemoryOpaqueCaptureAddressInfo
) -> u64 #c_call;
DeferredOperationKHR :: *DeferredOperationKHRT;
PFN_CreateDeferredOperationKHR :: #type (
    device : Device,
    pAllocator : *AllocationCallbacks,
    pDeferredOperation : *DeferredOperationKHR
) -> Result #c_call;
PFN_DestroyDeferredOperationKHR :: #type (
    device : Device,
    operation : DeferredOperationKHR,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_GetDeferredOperationMaxConcurrencyKHR :: #type (
    device : Device,
    operation : DeferredOperationKHR
) -> u32 #c_call;
PFN_GetDeferredOperationResultKHR :: #type (
    device : Device,
    operation : DeferredOperationKHR
) -> Result #c_call;
PFN_DeferredOperationJoinKHR :: #type (
    device : Device,
    operation : DeferredOperationKHR
) -> Result #c_call;
PFN_GetPipelineExecutablePropertiesKHR :: #type (
    device : Device,
    pPipelineInfo : *PipelineInfoKHR,
    pExecutableCount : *u32,
    pProperties : *PipelineExecutablePropertiesKHR
) -> Result #c_call;
PFN_GetPipelineExecutableStatisticsKHR :: #type (
    device : Device,
    pExecutableInfo : *PipelineExecutableInfoKHR,
    pStatisticCount : *u32,
    pStatistics : *PipelineExecutableStatisticKHR
) -> Result #c_call;
PFN_GetPipelineExecutableInternalRepresentationsKHR :: #type (
    device : Device,
    pExecutableInfo : *PipelineExecutableInfoKHR,
    pInternalRepresentationCount : *u32,
    pInternalRepresentations : *PipelineExecutableInternalRepresentationKHR
) -> Result #c_call;
PFN_CmdCopyBuffer2KHR :: #type (
    commandBuffer : CommandBuffer,
    pCopyBufferInfo : *CopyBufferInfo2KHR
) #c_call;
PFN_CmdCopyImage2KHR :: #type (
    commandBuffer : CommandBuffer,
    pCopyImageInfo : *CopyImageInfo2KHR
) #c_call;
PFN_CmdCopyBufferToImage2KHR :: #type (
    commandBuffer : CommandBuffer,
    pCopyBufferToImageInfo : *CopyBufferToImageInfo2KHR
) #c_call;
PFN_CmdCopyImageToBuffer2KHR :: #type (
    commandBuffer : CommandBuffer,
    pCopyImageToBufferInfo : *CopyImageToBufferInfo2KHR
) #c_call;
PFN_CmdBlitImage2KHR :: #type (
    commandBuffer : CommandBuffer,
    pBlitImageInfo : *BlitImageInfo2KHR
) #c_call;
PFN_CmdResolveImage2KHR :: #type (
    commandBuffer : CommandBuffer,
    pResolveImageInfo : *ResolveImageInfo2KHR
) #c_call;
DebugReportCallbackEXT :: *DebugReportCallbackEXTT;
DebugReportFlagsEXT :: Flags;
PFN_DebugReportCallbackEXT :: #type (
    flags : DebugReportFlagsEXT,
    objectType : DebugReportObjectTypeEXT,
    object : u64,
    location : u64,
    messageCode : s32,
    pLayerPrefix : *u8,
    pMessage : *u8,
    pUserData : *void
) -> Bool32 #c_call;
PFN_CreateDebugReportCallbackEXT :: #type (
    instance : Instance,
    pCreateInfo : *DebugReportCallbackCreateInfoEXT,
    pAllocator : *AllocationCallbacks,
    pCallback : *DebugReportCallbackEXT
) -> Result #c_call;
PFN_DestroyDebugReportCallbackEXT :: #type (
    instance : Instance,
    callback : DebugReportCallbackEXT,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_DebugReportMessageEXT :: #type (
    instance : Instance,
    flags : DebugReportFlagsEXT,
    objectType : DebugReportObjectTypeEXT,
    object : u64,
    location : u64,
    messageCode : s32,
    pLayerPrefix : *u8,
    pMessage : *u8
) #c_call;
PFN_DebugMarkerSetObjectTagEXT :: #type (
    device : Device,
    pTagInfo : *DebugMarkerObjectTagInfoEXT
) -> Result #c_call;
PFN_DebugMarkerSetObjectNameEXT :: #type (
    device : Device,
    pNameInfo : *DebugMarkerObjectNameInfoEXT
) -> Result #c_call;
PFN_CmdDebugMarkerBeginEXT :: #type (
    commandBuffer : CommandBuffer,
    pMarkerInfo : *DebugMarkerMarkerInfoEXT
) #c_call;
PFN_CmdDebugMarkerEndEXT :: #type (commandBuffer : CommandBuffer) #c_call;
PFN_CmdDebugMarkerInsertEXT :: #type (
    commandBuffer : CommandBuffer,
    pMarkerInfo : *DebugMarkerMarkerInfoEXT
) #c_call;
PipelineRasterizationStateStreamCreateFlagsEXT :: Flags;
PFN_CmdBindTransformFeedbackBuffersEXT :: #type (
    commandBuffer : CommandBuffer,
    firstBinding : u32,
    bindingCount : u32,
    pBuffers : *Buffer,
    pOffsets : *DeviceSize,
    pSizes : *DeviceSize
) #c_call;
PFN_CmdBeginTransformFeedbackEXT :: #type (
    commandBuffer : CommandBuffer,
    firstCounterBuffer : u32,
    counterBufferCount : u32,
    pCounterBuffers : *Buffer,
    pCounterBufferOffsets : *DeviceSize
) #c_call;
PFN_CmdEndTransformFeedbackEXT :: #type (
    commandBuffer : CommandBuffer,
    firstCounterBuffer : u32,
    counterBufferCount : u32,
    pCounterBuffers : *Buffer,
    pCounterBufferOffsets : *DeviceSize
) #c_call;
PFN_CmdBeginQueryIndexedEXT :: #type (
    commandBuffer : CommandBuffer,
    queryPool : QueryPool,
    query : u32,
    flags : QueryControlFlags,
    index : u32
) #c_call;
PFN_CmdEndQueryIndexedEXT :: #type (
    commandBuffer : CommandBuffer,
    queryPool : QueryPool,
    query : u32,
    index : u32
) #c_call;
PFN_CmdDrawIndirectByteCountEXT :: #type (
    commandBuffer : CommandBuffer,
    instanceCount : u32,
    firstInstance : u32,
    counterBuffer : Buffer,
    counterBufferOffset : DeviceSize,
    counterOffset : u32,
    vertexStride : u32
) #c_call;
PFN_GetImageViewHandleNVX :: #type (
    device : Device,
    pInfo : *ImageViewHandleInfoNVX
) -> u32 #c_call;
PFN_GetImageViewAddressNVX :: #type (
    device : Device,
    imageView : ImageView,
    pProperties : *ImageViewAddressPropertiesNVX
) -> Result #c_call;
PFN_CmdDrawIndirectCountAMD :: #type (
    commandBuffer : CommandBuffer,
    buffer : Buffer,
    offset : DeviceSize,
    countBuffer : Buffer,
    countBufferOffset : DeviceSize,
    maxDrawCount : u32,
    stride : u32
) #c_call;
PFN_CmdDrawIndexedIndirectCountAMD :: #type (
    commandBuffer : CommandBuffer,
    buffer : Buffer,
    offset : DeviceSize,
    countBuffer : Buffer,
    countBufferOffset : DeviceSize,
    maxDrawCount : u32,
    stride : u32
) #c_call;
PFN_GetShaderInfoAMD :: #type (
    device : Device,
    pipeline : Pipeline,
    shaderStage : ShaderStageFlagBits,
    infoType : ShaderInfoTypeAMD,
    pInfoSize : *u64,
    pInfo : *void
) -> Result #c_call;
ExternalMemoryHandleTypeFlagsNV :: Flags;
ExternalMemoryFeatureFlagsNV :: Flags;
PFN_GetPhysicalDeviceExternalImageFormatPropertiesNV :: #type (
    physicalDevice : PhysicalDevice,
    format : Format,
    type : ImageType,
    tiling : ImageTiling,
    usage : ImageUsageFlags,
    flags : ImageCreateFlags,
    externalHandleType : ExternalMemoryHandleTypeFlagsNV,
    pExternalImageFormatProperties : *ExternalImageFormatPropertiesNV
) -> Result #c_call;
ConditionalRenderingFlagsEXT :: Flags;
PFN_CmdBeginConditionalRenderingEXT :: #type (
    commandBuffer : CommandBuffer,
    pConditionalRenderingBegin : *ConditionalRenderingBeginInfoEXT
) #c_call;
PFN_CmdEndConditionalRenderingEXT :: #type (commandBuffer : CommandBuffer) #c_call;
PFN_CmdSetViewportWScalingNV :: #type (
    commandBuffer : CommandBuffer,
    firstViewport : u32,
    viewportCount : u32,
    pViewportWScalings : *ViewportWScalingNV
) #c_call;
PFN_ReleaseDisplayEXT :: #type (
    physicalDevice : PhysicalDevice,
    display : DisplayKHR
) -> Result #c_call;
SurfaceCounterFlagsEXT :: Flags;
PFN_GetPhysicalDeviceSurfaceCapabilities2EXT :: #type (
    physicalDevice : PhysicalDevice,
    surface : SurfaceKHR,
    pSurfaceCapabilities : *SurfaceCapabilities2EXT
) -> Result #c_call;
PFN_DisplayPowerControlEXT :: #type (
    device : Device,
    display : DisplayKHR,
    pDisplayPowerInfo : *DisplayPowerInfoEXT
) -> Result #c_call;
PFN_RegisterDeviceEventEXT :: #type (
    device : Device,
    pDeviceEventInfo : *DeviceEventInfoEXT,
    pAllocator : *AllocationCallbacks,
    pFence : *Fence
) -> Result #c_call;
PFN_RegisterDisplayEventEXT :: #type (
    device : Device,
    display : DisplayKHR,
    pDisplayEventInfo : *DisplayEventInfoEXT,
    pAllocator : *AllocationCallbacks,
    pFence : *Fence
) -> Result #c_call;
PFN_GetSwapchainCounterEXT :: #type (
    device : Device,
    swapchain : SwapchainKHR,
    counter : SurfaceCounterFlagBitsEXT,
    pCounterValue : *u64
) -> Result #c_call;
PFN_GetRefreshCycleDurationGOOGLE :: #type (
    device : Device,
    swapchain : SwapchainKHR,
    pDisplayTimingProperties : *RefreshCycleDurationGOOGLE
) -> Result #c_call;
PFN_GetPastPresentationTimingGOOGLE :: #type (
    device : Device,
    swapchain : SwapchainKHR,
    pPresentationTimingCount : *u32,
    pPresentationTimings : *PastPresentationTimingGOOGLE
) -> Result #c_call;
PipelineViewportSwizzleStateCreateFlagsNV :: Flags;
PipelineDiscardRectangleStateCreateFlagsEXT :: Flags;
PFN_CmdSetDiscardRectangleEXT :: #type (
    commandBuffer : CommandBuffer,
    firstDiscardRectangle : u32,
    discardRectangleCount : u32,
    pDiscardRectangles : *Rect2D
) #c_call;
PipelineRasterizationConservativeStateCreateFlagsEXT :: Flags;
PipelineRasterizationDepthClipStateCreateFlagsEXT :: Flags;
PFN_SetHdrMetadataEXT :: #type (
    device : Device,
    swapchainCount : u32,
    pSwapchains : *SwapchainKHR,
    pMetadata : *HdrMetadataEXT
) #c_call;
DebugUtilsMessengerEXT :: *DebugUtilsMessengerEXTT;
DebugUtilsMessengerCallbackDataFlagsEXT :: Flags;
DebugUtilsMessageTypeFlagsEXT :: Flags;
DebugUtilsMessageSeverityFlagsEXT :: Flags;
DebugUtilsMessengerCreateFlagsEXT :: Flags;
PFN_DebugUtilsMessengerCallbackEXT :: #type (
    messageSeverity : DebugUtilsMessageSeverityFlagBitsEXT,
    messageTypes : DebugUtilsMessageTypeFlagsEXT,
    pCallbackData : *DebugUtilsMessengerCallbackDataEXT,
    pUserData : *void
) -> Bool32 #c_call;
PFN_SetDebugUtilsObjectNameEXT :: #type (
    device : Device,
    pNameInfo : *DebugUtilsObjectNameInfoEXT
) -> Result #c_call;
PFN_SetDebugUtilsObjectTagEXT :: #type (
    device : Device,
    pTagInfo : *DebugUtilsObjectTagInfoEXT
) -> Result #c_call;
PFN_QueueBeginDebugUtilsLabelEXT :: #type (
    queue : Queue,
    pLabelInfo : *DebugUtilsLabelEXT
) #c_call;
PFN_QueueEndDebugUtilsLabelEXT :: #type (queue : Queue) #c_call;
PFN_QueueInsertDebugUtilsLabelEXT :: #type (
    queue : Queue,
    pLabelInfo : *DebugUtilsLabelEXT
) #c_call;
PFN_CmdBeginDebugUtilsLabelEXT :: #type (
    commandBuffer : CommandBuffer,
    pLabelInfo : *DebugUtilsLabelEXT
) #c_call;
PFN_CmdEndDebugUtilsLabelEXT :: #type (commandBuffer : CommandBuffer) #c_call;
PFN_CmdInsertDebugUtilsLabelEXT :: #type (
    commandBuffer : CommandBuffer,
    pLabelInfo : *DebugUtilsLabelEXT
) #c_call;
PFN_CreateDebugUtilsMessengerEXT :: #type (
    instance : Instance,
    pCreateInfo : *DebugUtilsMessengerCreateInfoEXT,
    pAllocator : *AllocationCallbacks,
    pMessenger : *DebugUtilsMessengerEXT
) -> Result #c_call;
PFN_DestroyDebugUtilsMessengerEXT :: #type (
    instance : Instance,
    messenger : DebugUtilsMessengerEXT,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_SubmitDebugUtilsMessageEXT :: #type (
    instance : Instance,
    messageSeverity : DebugUtilsMessageSeverityFlagBitsEXT,
    messageTypes : DebugUtilsMessageTypeFlagsEXT,
    pCallbackData : *DebugUtilsMessengerCallbackDataEXT
) #c_call;
SamplerReductionModeEXT :: SamplerReductionMode;
SamplerReductionModeCreateInfoEXT :: SamplerReductionModeCreateInfo;
PhysicalDeviceSamplerFilterMinmaxPropertiesEXT :: PhysicalDeviceSamplerFilterMinmaxProperties;
PFN_CmdSetSampleLocationsEXT :: #type (
    commandBuffer : CommandBuffer,
    pSampleLocationsInfo : *SampleLocationsInfoEXT
) #c_call;
PFN_GetPhysicalDeviceMultisamplePropertiesEXT :: #type (
    physicalDevice : PhysicalDevice,
    samples : SampleCountFlagBits,
    pMultisampleProperties : *MultisamplePropertiesEXT
) #c_call;
PipelineCoverageToColorStateCreateFlagsNV :: Flags;
PipelineCoverageModulationStateCreateFlagsNV :: Flags;
PFN_GetImageDrmFormatModifierPropertiesEXT :: #type (
    device : Device,
    image : Image,
    pProperties : *ImageDrmFormatModifierPropertiesEXT
) -> Result #c_call;
ValidationCacheEXT :: *ValidationCacheEXTT;
ValidationCacheCreateFlagsEXT :: Flags;
PFN_CreateValidationCacheEXT :: #type (
    device : Device,
    pCreateInfo : *ValidationCacheCreateInfoEXT,
    pAllocator : *AllocationCallbacks,
    pValidationCache : *ValidationCacheEXT
) -> Result #c_call;
PFN_DestroyValidationCacheEXT :: #type (
    device : Device,
    validationCache : ValidationCacheEXT,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_MergeValidationCachesEXT :: #type (
    device : Device,
    dstCache : ValidationCacheEXT,
    srcCacheCount : u32,
    pSrcCaches : *ValidationCacheEXT
) -> Result #c_call;
PFN_GetValidationCacheDataEXT :: #type (
    device : Device,
    validationCache : ValidationCacheEXT,
    pDataSize : *u64,
    pData : *void
) -> Result #c_call;
DescriptorBindingFlagBitsEXT :: DescriptorBindingFlagBits;
DescriptorBindingFlagsEXT :: DescriptorBindingFlags;
DescriptorSetLayoutBindingFlagsCreateInfoEXT :: DescriptorSetLayoutBindingFlagsCreateInfo;
PhysicalDeviceDescriptorIndexingFeaturesEXT :: PhysicalDeviceDescriptorIndexingFeatures;
PhysicalDeviceDescriptorIndexingPropertiesEXT :: PhysicalDeviceDescriptorIndexingProperties;
DescriptorSetVariableDescriptorCountAllocateInfoEXT :: DescriptorSetVariableDescriptorCountAllocateInfo;
DescriptorSetVariableDescriptorCountLayoutSupportEXT :: DescriptorSetVariableDescriptorCountLayoutSupport;
PFN_CmdBindShadingRateImageNV :: #type (
    commandBuffer : CommandBuffer,
    imageView : ImageView,
    imageLayout : ImageLayout
) #c_call;
PFN_CmdSetViewportShadingRatePaletteNV :: #type (
    commandBuffer : CommandBuffer,
    firstViewport : u32,
    viewportCount : u32,
    pShadingRatePalettes : *ShadingRatePaletteNV
) #c_call;
PFN_CmdSetCoarseSampleOrderNV :: #type (
    commandBuffer : CommandBuffer,
    sampleOrderType : CoarseSampleOrderTypeNV,
    customSampleOrderCount : u32,
    pCustomSampleOrders : *CoarseSampleOrderCustomNV
) #c_call;
AccelerationStructureNV :: *AccelerationStructureNVT;
RayTracingShaderGroupTypeNV :: RayTracingShaderGroupTypeKHR;
GeometryTypeNV :: GeometryTypeKHR;
AccelerationStructureTypeNV :: AccelerationStructureTypeKHR;
CopyAccelerationStructureModeNV :: CopyAccelerationStructureModeKHR;
GeometryFlagsKHR :: Flags;
GeometryFlagsNV :: GeometryFlagsKHR;
GeometryFlagBitsNV :: GeometryFlagBitsKHR;
GeometryInstanceFlagsKHR :: Flags;
GeometryInstanceFlagsNV :: GeometryInstanceFlagsKHR;
GeometryInstanceFlagBitsNV :: GeometryInstanceFlagBitsKHR;
BuildAccelerationStructureFlagsKHR :: Flags;
BuildAccelerationStructureFlagsNV :: BuildAccelerationStructureFlagsKHR;
BuildAccelerationStructureFlagBitsNV :: BuildAccelerationStructureFlagBitsKHR;
TransformMatrixNV :: TransformMatrixKHR;
AabbPositionsNV :: AabbPositionsKHR;
AccelerationStructureInstanceNV :: AccelerationStructureInstanceKHR;
PFN_CreateAccelerationStructureNV :: #type (
    device : Device,
    pCreateInfo : *AccelerationStructureCreateInfoNV,
    pAllocator : *AllocationCallbacks,
    pAccelerationStructure : *AccelerationStructureNV
) -> Result #c_call;
PFN_DestroyAccelerationStructureNV :: #type (
    device : Device,
    accelerationStructure : AccelerationStructureNV,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_GetAccelerationStructureMemoryRequirementsNV :: #type (
    device : Device,
    pInfo : *AccelerationStructureMemoryRequirementsInfoNV,
    pMemoryRequirements : *MemoryRequirements2KHR
) #c_call;
PFN_BindAccelerationStructureMemoryNV :: #type (
    device : Device,
    bindInfoCount : u32,
    pBindInfos : *BindAccelerationStructureMemoryInfoNV
) -> Result #c_call;
PFN_CmdBuildAccelerationStructureNV :: #type (
    commandBuffer : CommandBuffer,
    pInfo : *AccelerationStructureInfoNV,
    instanceData : Buffer,
    instanceOffset : DeviceSize,
    update : Bool32,
    dst : AccelerationStructureNV,
    src : AccelerationStructureNV,
    scratch : Buffer,
    scratchOffset : DeviceSize
) #c_call;
PFN_CmdCopyAccelerationStructureNV :: #type (
    commandBuffer : CommandBuffer,
    dst : AccelerationStructureNV,
    src : AccelerationStructureNV,
    mode : CopyAccelerationStructureModeKHR
) #c_call;
PFN_CmdTraceRaysNV :: #type (
    commandBuffer : CommandBuffer,
    raygenShaderBindingTableBuffer : Buffer,
    raygenShaderBindingOffset : DeviceSize,
    missShaderBindingTableBuffer : Buffer,
    missShaderBindingOffset : DeviceSize,
    missShaderBindingStride : DeviceSize,
    hitShaderBindingTableBuffer : Buffer,
    hitShaderBindingOffset : DeviceSize,
    hitShaderBindingStride : DeviceSize,
    callableShaderBindingTableBuffer : Buffer,
    callableShaderBindingOffset : DeviceSize,
    callableShaderBindingStride : DeviceSize,
    width : u32,
    height : u32,
    depth : u32
) #c_call;
PFN_CreateRayTracingPipelinesNV :: #type (
    device : Device,
    pipelineCache : PipelineCache,
    createInfoCount : u32,
    pCreateInfos : *RayTracingPipelineCreateInfoNV,
    pAllocator : *AllocationCallbacks,
    pPipelines : *Pipeline
) -> Result #c_call;
PFN_GetRayTracingShaderGroupHandlesKHR :: #type (
    device : Device,
    pipeline : Pipeline,
    firstGroup : u32,
    groupCount : u32,
    dataSize : u64,
    pData : *void
) -> Result #c_call;
PFN_GetRayTracingShaderGroupHandlesNV :: #type (
    device : Device,
    pipeline : Pipeline,
    firstGroup : u32,
    groupCount : u32,
    dataSize : u64,
    pData : *void
) -> Result #c_call;
PFN_GetAccelerationStructureHandleNV :: #type (
    device : Device,
    accelerationStructure : AccelerationStructureNV,
    dataSize : u64,
    pData : *void
) -> Result #c_call;
PFN_CmdWriteAccelerationStructuresPropertiesNV :: #type (
    commandBuffer : CommandBuffer,
    accelerationStructureCount : u32,
    pAccelerationStructures : *AccelerationStructureNV,
    queryType : QueryType,
    queryPool : QueryPool,
    firstQuery : u32
) #c_call;
PFN_CompileDeferredNV :: #type (
    device : Device,
    pipeline : Pipeline,
    shader : u32
) -> Result #c_call;
PFN_GetMemoryHostPointerPropertiesEXT :: #type (
    device : Device,
    handleType : ExternalMemoryHandleTypeFlagBits,
    pHostPointer : *void,
    pMemoryHostPointerProperties : *MemoryHostPointerPropertiesEXT
) -> Result #c_call;
PFN_CmdWriteBufferMarkerAMD :: #type (
    commandBuffer : CommandBuffer,
    pipelineStage : PipelineStageFlagBits,
    dstBuffer : Buffer,
    dstOffset : DeviceSize,
    marker : u32
) #c_call;
PipelineCompilerControlFlagsAMD :: Flags;
PFN_GetPhysicalDeviceCalibrateableTimeDomainsEXT :: #type (
    physicalDevice : PhysicalDevice,
    pTimeDomainCount : *u32,
    pTimeDomains : *TimeDomainEXT
) -> Result #c_call;
PFN_GetCalibratedTimestampsEXT :: #type (
    device : Device,
    timestampCount : u32,
    pTimestampInfos : *CalibratedTimestampInfoEXT,
    pTimestamps : *u64,
    pMaxDeviation : *u64
) -> Result #c_call;
PipelineCreationFeedbackFlagsEXT :: Flags;
PFN_CmdDrawMeshTasksNV :: #type (
    commandBuffer : CommandBuffer,
    taskCount : u32,
    firstTask : u32
) #c_call;
PFN_CmdDrawMeshTasksIndirectNV :: #type (
    commandBuffer : CommandBuffer,
    buffer : Buffer,
    offset : DeviceSize,
    drawCount : u32,
    stride : u32
) #c_call;
PFN_CmdDrawMeshTasksIndirectCountNV :: #type (
    commandBuffer : CommandBuffer,
    buffer : Buffer,
    offset : DeviceSize,
    countBuffer : Buffer,
    countBufferOffset : DeviceSize,
    maxDrawCount : u32,
    stride : u32
) #c_call;
PFN_CmdSetExclusiveScissorNV :: #type (
    commandBuffer : CommandBuffer,
    firstExclusiveScissor : u32,
    exclusiveScissorCount : u32,
    pExclusiveScissors : *Rect2D
) #c_call;
PFN_CmdSetCheckpointNV :: #type (
    commandBuffer : CommandBuffer,
    pCheckpointMarker : *void
) #c_call;
PFN_GetQueueCheckpointDataNV :: #type (
    queue : Queue,
    pCheckpointDataCount : *u32,
    pCheckpointData : *CheckpointDataNV
) #c_call;
PerformanceConfigurationINTEL :: *PerformanceConfigurationINTELT;
QueryPoolCreateInfoINTEL :: QueryPoolPerformanceQueryCreateInfoINTEL;
PFN_InitializePerformanceApiINTEL :: #type (
    device : Device,
    pInitializeInfo : *InitializePerformanceApiInfoINTEL
) -> Result #c_call;
PFN_UninitializePerformanceApiINTEL :: #type (device : Device) #c_call;
PFN_CmdSetPerformanceMarkerINTEL :: #type (
    commandBuffer : CommandBuffer,
    pMarkerInfo : *PerformanceMarkerInfoINTEL
) -> Result #c_call;
PFN_CmdSetPerformanceStreamMarkerINTEL :: #type (
    commandBuffer : CommandBuffer,
    pMarkerInfo : *PerformanceStreamMarkerInfoINTEL
) -> Result #c_call;
PFN_CmdSetPerformanceOverrideINTEL :: #type (
    commandBuffer : CommandBuffer,
    pOverrideInfo : *PerformanceOverrideInfoINTEL
) -> Result #c_call;
PFN_AcquirePerformanceConfigurationINTEL :: #type (
    device : Device,
    pAcquireInfo : *PerformanceConfigurationAcquireInfoINTEL,
    pConfiguration : *PerformanceConfigurationINTEL
) -> Result #c_call;
PFN_ReleasePerformanceConfigurationINTEL :: #type (
    device : Device,
    configuration : PerformanceConfigurationINTEL
) -> Result #c_call;
PFN_QueueSetPerformanceConfigurationINTEL :: #type (
    queue : Queue,
    configuration : PerformanceConfigurationINTEL
) -> Result #c_call;
PFN_GetPerformanceParameterINTEL :: #type (
    device : Device,
    parameter : PerformanceParameterTypeINTEL,
    pValue : *PerformanceValueINTEL
) -> Result #c_call;
PFN_SetLocalDimmingAMD :: #type (
    device : Device,
    swapChain : SwapchainKHR,
    localDimmingEnable : Bool32
) #c_call;
PhysicalDeviceScalarBlockLayoutFeaturesEXT :: PhysicalDeviceScalarBlockLayoutFeatures;
ShaderCorePropertiesFlagsAMD :: Flags;
PhysicalDeviceBufferAddressFeaturesEXT :: PhysicalDeviceBufferDeviceAddressFeaturesEXT;
BufferDeviceAddressInfoEXT :: BufferDeviceAddressInfo;
PFN_GetBufferDeviceAddressEXT :: #type (
    device : Device,
    pInfo : *BufferDeviceAddressInfo
) -> DeviceAddress #c_call;
ToolPurposeFlagsEXT :: Flags;
PFN_GetPhysicalDeviceToolPropertiesEXT :: #type (
    physicalDevice : PhysicalDevice,
    pToolCount : *u32,
    pToolProperties : *PhysicalDeviceToolPropertiesEXT
) -> Result #c_call;
ImageStencilUsageCreateInfoEXT :: ImageStencilUsageCreateInfo;
PFN_GetPhysicalDeviceCooperativeMatrixPropertiesNV :: #type (
    physicalDevice : PhysicalDevice,
    pPropertyCount : *u32,
    pProperties : *CooperativeMatrixPropertiesNV
) -> Result #c_call;
PipelineCoverageReductionStateCreateFlagsNV :: Flags;
PFN_GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV :: #type (
    physicalDevice : PhysicalDevice,
    pCombinationCount : *u32,
    pCombinations : *FramebufferMixedSamplesCombinationNV
) -> Result #c_call;
HeadlessSurfaceCreateFlagsEXT :: Flags;
PFN_CreateHeadlessSurfaceEXT :: #type (
    instance : Instance,
    pCreateInfo : *HeadlessSurfaceCreateInfoEXT,
    pAllocator : *AllocationCallbacks,
    pSurface : *SurfaceKHR
) -> Result #c_call;
PFN_CmdSetLineStippleEXT :: #type (
    commandBuffer : CommandBuffer,
    lineStippleFactor : u32,
    lineStipplePattern : u16
) #c_call;
PhysicalDeviceHostQueryResetFeaturesEXT :: PhysicalDeviceHostQueryResetFeatures;
PFN_ResetQueryPoolEXT :: #type (
    device : Device,
    queryPool : QueryPool,
    firstQuery : u32,
    queryCount : u32
) #c_call;
PFN_CmdSetCullModeEXT :: #type (
    commandBuffer : CommandBuffer,
    cullMode : CullModeFlags
) #c_call;
PFN_CmdSetFrontFaceEXT :: #type (
    commandBuffer : CommandBuffer,
    frontFace : FrontFace
) #c_call;
PFN_CmdSetPrimitiveTopologyEXT :: #type (
    commandBuffer : CommandBuffer,
    primitiveTopology : PrimitiveTopology
) #c_call;
PFN_CmdSetViewportWithCountEXT :: #type (
    commandBuffer : CommandBuffer,
    viewportCount : u32,
    pViewports : *Viewport
) #c_call;
PFN_CmdSetScissorWithCountEXT :: #type (
    commandBuffer : CommandBuffer,
    scissorCount : u32,
    pScissors : *Rect2D
) #c_call;
PFN_CmdBindVertexBuffers2EXT :: #type (
    commandBuffer : CommandBuffer,
    firstBinding : u32,
    bindingCount : u32,
    pBuffers : *Buffer,
    pOffsets : *DeviceSize,
    pSizes : *DeviceSize,
    pStrides : *DeviceSize
) #c_call;
PFN_CmdSetDepthTestEnableEXT :: #type (
    commandBuffer : CommandBuffer,
    depthTestEnable : Bool32
) #c_call;
PFN_CmdSetDepthWriteEnableEXT :: #type (
    commandBuffer : CommandBuffer,
    depthWriteEnable : Bool32
) #c_call;
PFN_CmdSetDepthCompareOpEXT :: #type (
    commandBuffer : CommandBuffer,
    depthCompareOp : CompareOp
) #c_call;
PFN_CmdSetDepthBoundsTestEnableEXT :: #type (
    commandBuffer : CommandBuffer,
    depthBoundsTestEnable : Bool32
) #c_call;
PFN_CmdSetStencilTestEnableEXT :: #type (
    commandBuffer : CommandBuffer,
    stencilTestEnable : Bool32
) #c_call;
PFN_CmdSetStencilOpEXT :: #type (
    commandBuffer : CommandBuffer,
    faceMask : StencilFaceFlags,
    failOp : StencilOp,
    passOp : StencilOp,
    depthFailOp : StencilOp,
    compareOp : CompareOp
) #c_call;
IndirectCommandsLayoutNV :: *IndirectCommandsLayoutNVT;
IndirectStateFlagsNV :: Flags;
IndirectCommandsLayoutUsageFlagsNV :: Flags;
PFN_GetGeneratedCommandsMemoryRequirementsNV :: #type (
    device : Device,
    pInfo : *GeneratedCommandsMemoryRequirementsInfoNV,
    pMemoryRequirements : *MemoryRequirements2
) #c_call;
PFN_CmdPreprocessGeneratedCommandsNV :: #type (
    commandBuffer : CommandBuffer,
    pGeneratedCommandsInfo : *GeneratedCommandsInfoNV
) #c_call;
PFN_CmdExecuteGeneratedCommandsNV :: #type (
    commandBuffer : CommandBuffer,
    isPreprocessed : Bool32,
    pGeneratedCommandsInfo : *GeneratedCommandsInfoNV
) #c_call;
PFN_CmdBindPipelineShaderGroupNV :: #type (
    commandBuffer : CommandBuffer,
    pipelineBindPoint : PipelineBindPoint,
    pipeline : Pipeline,
    groupIndex : u32
) #c_call;
PFN_CreateIndirectCommandsLayoutNV :: #type (
    device : Device,
    pCreateInfo : *IndirectCommandsLayoutCreateInfoNV,
    pAllocator : *AllocationCallbacks,
    pIndirectCommandsLayout : *IndirectCommandsLayoutNV
) -> Result #c_call;
PFN_DestroyIndirectCommandsLayoutNV :: #type (
    device : Device,
    indirectCommandsLayout : IndirectCommandsLayoutNV,
    pAllocator : *AllocationCallbacks
) #c_call;
DeviceMemoryReportFlagsEXT :: Flags;
PFN_DeviceMemoryReportCallbackEXT :: #type (
    pCallbackData : *DeviceMemoryReportCallbackDataEXT,
    pUserData : *void
) #c_call;
PrivateDataSlotEXT :: *PrivateDataSlotEXTT;
PrivateDataSlotCreateFlagsEXT :: Flags;
PFN_CreatePrivateDataSlotEXT :: #type (
    device : Device,
    pCreateInfo : *PrivateDataSlotCreateInfoEXT,
    pAllocator : *AllocationCallbacks,
    pPrivateDataSlot : *PrivateDataSlotEXT
) -> Result #c_call;
PFN_DestroyPrivateDataSlotEXT :: #type (
    device : Device,
    privateDataSlot : PrivateDataSlotEXT,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_SetPrivateDataEXT :: #type (
    device : Device,
    objectType : ObjectType,
    objectHandle : u64,
    privateDataSlot : PrivateDataSlotEXT,
    data : u64
) -> Result #c_call;
PFN_GetPrivateDataEXT :: #type (
    device : Device,
    objectType : ObjectType,
    objectHandle : u64,
    privateDataSlot : PrivateDataSlotEXT,
    pData : *u64
) #c_call;
DeviceDiagnosticsConfigFlagsNV :: Flags;
PFN_CmdSetFragmentShadingRateEnumNV :: #type (
    commandBuffer : CommandBuffer,
    shadingRate : FragmentShadingRateNV,
    combinerOps : *FragmentShadingRateCombinerOpKHR
) #c_call;
AccelerationStructureKHR :: *AccelerationStructureKHRT;
AccelerationStructureCreateFlagsKHR :: Flags;
PFN_CreateAccelerationStructureKHR :: #type (
    device : Device,
    pCreateInfo : *AccelerationStructureCreateInfoKHR,
    pAllocator : *AllocationCallbacks,
    pAccelerationStructure : *AccelerationStructureKHR
) -> Result #c_call;
PFN_DestroyAccelerationStructureKHR :: #type (
    device : Device,
    accelerationStructure : AccelerationStructureKHR,
    pAllocator : *AllocationCallbacks
) #c_call;
PFN_CmdBuildAccelerationStructuresKHR :: #type (
    commandBuffer : CommandBuffer,
    infoCount : u32,
    pInfos : *AccelerationStructureBuildGeometryInfoKHR,
    ppBuildRangeInfos : **AccelerationStructureBuildRangeInfoKHR
) #c_call;
PFN_CmdBuildAccelerationStructuresIndirectKHR :: #type (
    commandBuffer : CommandBuffer,
    infoCount : u32,
    pInfos : *AccelerationStructureBuildGeometryInfoKHR,
    pIndirectDeviceAddresses : *DeviceAddress,
    pIndirectStrides : *u32,
    ppMaxPrimitiveCounts : **u32
) #c_call;
PFN_BuildAccelerationStructuresKHR :: #type (
    device : Device,
    deferredOperation : DeferredOperationKHR,
    infoCount : u32,
    pInfos : *AccelerationStructureBuildGeometryInfoKHR,
    ppBuildRangeInfos : **AccelerationStructureBuildRangeInfoKHR
) -> Result #c_call;
PFN_CopyAccelerationStructureKHR :: #type (
    device : Device,
    deferredOperation : DeferredOperationKHR,
    pInfo : *CopyAccelerationStructureInfoKHR
) -> Result #c_call;
PFN_CopyAccelerationStructureToMemoryKHR :: #type (
    device : Device,
    deferredOperation : DeferredOperationKHR,
    pInfo : *CopyAccelerationStructureToMemoryInfoKHR
) -> Result #c_call;
PFN_CopyMemoryToAccelerationStructureKHR :: #type (
    device : Device,
    deferredOperation : DeferredOperationKHR,
    pInfo : *CopyMemoryToAccelerationStructureInfoKHR
) -> Result #c_call;
PFN_WriteAccelerationStructuresPropertiesKHR :: #type (
    device : Device,
    accelerationStructureCount : u32,
    pAccelerationStructures : *AccelerationStructureKHR,
    queryType : QueryType,
    dataSize : u64,
    pData : *void,
    stride : u64
) -> Result #c_call;
PFN_CmdCopyAccelerationStructureKHR :: #type (
    commandBuffer : CommandBuffer,
    pInfo : *CopyAccelerationStructureInfoKHR
) #c_call;
PFN_CmdCopyAccelerationStructureToMemoryKHR :: #type (
    commandBuffer : CommandBuffer,
    pInfo : *CopyAccelerationStructureToMemoryInfoKHR
) #c_call;
PFN_CmdCopyMemoryToAccelerationStructureKHR :: #type (
    commandBuffer : CommandBuffer,
    pInfo : *CopyMemoryToAccelerationStructureInfoKHR
) #c_call;
PFN_GetAccelerationStructureDeviceAddressKHR :: #type (
    device : Device,
    pInfo : *AccelerationStructureDeviceAddressInfoKHR
) -> DeviceAddress #c_call;
PFN_CmdWriteAccelerationStructuresPropertiesKHR :: #type (
    commandBuffer : CommandBuffer,
    accelerationStructureCount : u32,
    pAccelerationStructures : *AccelerationStructureKHR,
    queryType : QueryType,
    queryPool : QueryPool,
    firstQuery : u32
) #c_call;
PFN_GetDeviceAccelerationStructureCompatibilityKHR :: #type (
    device : Device,
    pVersionInfo : *AccelerationStructureVersionInfoKHR,
    pCompatibility : *AccelerationStructureCompatibilityKHR
) #c_call;
PFN_GetAccelerationStructureBuildSizesKHR :: #type (
    device : Device,
    buildType : AccelerationStructureBuildTypeKHR,
    pBuildInfo : *AccelerationStructureBuildGeometryInfoKHR,
    pMaxPrimitiveCounts : *u32,
    pSizeInfo : *AccelerationStructureBuildSizesInfoKHR
) #c_call;
PFN_CmdTraceRaysKHR :: #type (
    commandBuffer : CommandBuffer,
    pRaygenShaderBindingTable : *StridedDeviceAddressRegionKHR,
    pMissShaderBindingTable : *StridedDeviceAddressRegionKHR,
    pHitShaderBindingTable : *StridedDeviceAddressRegionKHR,
    pCallableShaderBindingTable : *StridedDeviceAddressRegionKHR,
    width : u32,
    height : u32,
    depth : u32
) #c_call;
PFN_CreateRayTracingPipelinesKHR :: #type (
    device : Device,
    deferredOperation : DeferredOperationKHR,
    pipelineCache : PipelineCache,
    createInfoCount : u32,
    pCreateInfos : *RayTracingPipelineCreateInfoKHR,
    pAllocator : *AllocationCallbacks,
    pPipelines : *Pipeline
) -> Result #c_call;
PFN_GetRayTracingCaptureReplayShaderGroupHandlesKHR :: #type (
    device : Device,
    pipeline : Pipeline,
    firstGroup : u32,
    groupCount : u32,
    dataSize : u64,
    pData : *void
) -> Result #c_call;
PFN_CmdTraceRaysIndirectKHR :: #type (
    commandBuffer : CommandBuffer,
    pRaygenShaderBindingTable : *StridedDeviceAddressRegionKHR,
    pMissShaderBindingTable : *StridedDeviceAddressRegionKHR,
    pHitShaderBindingTable : *StridedDeviceAddressRegionKHR,
    pCallableShaderBindingTable : *StridedDeviceAddressRegionKHR,
    indirectDeviceAddress : DeviceAddress
) #c_call;
PFN_GetRayTracingShaderGroupStackSizeKHR :: #type (
    device : Device,
    pipeline : Pipeline,
    group : u32,
    groupShader : ShaderGroupShaderKHR
) -> DeviceSize #c_call;
PFN_CmdSetRayTracingPipelineStackSizeKHR :: #type (
    commandBuffer : CommandBuffer,
    pipelineStackSize : u32
) #c_call;

Result :: enum s32 {
    Success :: 0;
    NotReady :: 1;
    Timeout :: 2;
    EventSet :: 3;
    EventReset :: 4;
    Incomplete :: 5;
    ErrorOutOfHostMemory :: -1;
    ErrorOutOfDeviceMemory :: -2;
    ErrorInitializationFailed :: -3;
    ErrorDeviceLost :: -4;
    ErrorMemoryMapFailed :: -5;
    ErrorLayerNotPresent :: -6;
    ErrorExtensionNotPresent :: -7;
    ErrorFeatureNotPresent :: -8;
    ErrorIncompatibleDriver :: -9;
    ErrorTooManyObjects :: -10;
    ErrorFormatNotSupported :: -11;
    ErrorFragmentedPool :: -12;
    ErrorUnknown :: -13;
    ErrorOutOfPoolMemory :: -1000069000;
    ErrorInvalidExternalHandle :: -1000072003;
    ErrorFragmentation :: -1000161000;
    ErrorInvalidOpaqueCaptureAddress :: -1000257000;
    ErrorSurfaceLostKhr :: -1000000000;
    ErrorNativeWindowInUseKhr :: -1000000001;
    SuboptimalKhr :: 1000001003;
    ErrorOutOfDateKhr :: -1000001004;
    ErrorIncompatibleDisplayKhr :: -1000003001;
    ErrorValidationFailedExt :: -1000011001;
    ErrorInvalidShaderNv :: -1000012000;
    ErrorInvalidDrmFormatModifierPlaneLayoutExt :: -1000158000;
    ErrorNotPermittedExt :: -1000174001;
    ErrorFullScreenExclusiveModeLostExt :: -1000255000;
    ThreadIdleKhr :: 1000268000;
    ThreadDoneKhr :: 1000268001;
    OperationDeferredKhr :: 1000268002;
    OperationNotDeferredKhr :: 1000268003;
    PipelineCompileRequiredExt :: 1000297000;
    ErrorOutOfPoolMemoryKhr :: -1000069000;
    ErrorInvalidExternalHandleKhr :: -1000072003;
    ErrorFragmentationExt :: -1000161000;
    ErrorInvalidDeviceAddressExt :: -1000257000;
    ErrorInvalidOpaqueCaptureAddressKhr :: -1000257000;
    ErrorPipelineCompileRequiredExt :: 1000297000;
}

StructureType :: enum s32 {
    ApplicationInfo :: 0;
    InstanceCreateInfo :: 1;
    DeviceQueueCreateInfo :: 2;
    DeviceCreateInfo :: 3;
    SubmitInfo :: 4;
    MemoryAllocateInfo :: 5;
    MappedMemoryRange :: 6;
    BindSparseInfo :: 7;
    FenceCreateInfo :: 8;
    SemaphoreCreateInfo :: 9;
    EventCreateInfo :: 10;
    QueryPoolCreateInfo :: 11;
    BufferCreateInfo :: 12;
    BufferViewCreateInfo :: 13;
    ImageCreateInfo :: 14;
    ImageViewCreateInfo :: 15;
    ShaderModuleCreateInfo :: 16;
    PipelineCacheCreateInfo :: 17;
    PipelineShaderStageCreateInfo :: 18;
    PipelineVertexInputStateCreateInfo :: 19;
    PipelineInputAssemblyStateCreateInfo :: 20;
    PipelineTessellationStateCreateInfo :: 21;
    PipelineViewportStateCreateInfo :: 22;
    PipelineRasterizationStateCreateInfo :: 23;
    PipelineMultisampleStateCreateInfo :: 24;
    PipelineDepthStencilStateCreateInfo :: 25;
    PipelineColorBlendStateCreateInfo :: 26;
    PipelineDynamicStateCreateInfo :: 27;
    GraphicsPipelineCreateInfo :: 28;
    ComputePipelineCreateInfo :: 29;
    PipelineLayoutCreateInfo :: 30;
    SamplerCreateInfo :: 31;
    DescriptorSetLayoutCreateInfo :: 32;
    DescriptorPoolCreateInfo :: 33;
    DescriptorSetAllocateInfo :: 34;
    WriteDescriptorSet :: 35;
    CopyDescriptorSet :: 36;
    FramebufferCreateInfo :: 37;
    RenderPassCreateInfo :: 38;
    CommandPoolCreateInfo :: 39;
    CommandBufferAllocateInfo :: 40;
    CommandBufferInheritanceInfo :: 41;
    CommandBufferBeginInfo :: 42;
    RenderPassBeginInfo :: 43;
    BufferMemoryBarrier :: 44;
    ImageMemoryBarrier :: 45;
    MemoryBarrier :: 46;
    LoaderInstanceCreateInfo :: 47;
    LoaderDeviceCreateInfo :: 48;
    PhysicalDeviceSubgroupProperties :: 1000094000;
    BindBufferMemoryInfo :: 1000157000;
    BindImageMemoryInfo :: 1000157001;
    PhysicalDevice16BitStorageFeatures :: 1000083000;
    MemoryDedicatedRequirements :: 1000127000;
    MemoryDedicatedAllocateInfo :: 1000127001;
    MemoryAllocateFlagsInfo :: 1000060000;
    DeviceGroupRenderPassBeginInfo :: 1000060003;
    DeviceGroupCommandBufferBeginInfo :: 1000060004;
    DeviceGroupSubmitInfo :: 1000060005;
    DeviceGroupBindSparseInfo :: 1000060006;
    BindBufferMemoryDeviceGroupInfo :: 1000060013;
    BindImageMemoryDeviceGroupInfo :: 1000060014;
    PhysicalDeviceGroupProperties :: 1000070000;
    DeviceGroupDeviceCreateInfo :: 1000070001;
    BufferMemoryRequirementsInfo2 :: 1000146000;
    ImageMemoryRequirementsInfo2 :: 1000146001;
    ImageSparseMemoryRequirementsInfo2 :: 1000146002;
    MemoryRequirements2 :: 1000146003;
    SparseImageMemoryRequirements2 :: 1000146004;
    PhysicalDeviceFeatures2 :: 1000059000;
    PhysicalDeviceProperties2 :: 1000059001;
    FormatProperties2 :: 1000059002;
    ImageFormatProperties2 :: 1000059003;
    PhysicalDeviceImageFormatInfo2 :: 1000059004;
    QueueFamilyProperties2 :: 1000059005;
    PhysicalDeviceMemoryProperties2 :: 1000059006;
    SparseImageFormatProperties2 :: 1000059007;
    PhysicalDeviceSparseImageFormatInfo2 :: 1000059008;
    PhysicalDevicePointClippingProperties :: 1000117000;
    RenderPassInputAttachmentAspectCreateInfo :: 1000117001;
    ImageViewUsageCreateInfo :: 1000117002;
    PipelineTessellationDomainOriginStateCreateInfo :: 1000117003;
    RenderPassMultiviewCreateInfo :: 1000053000;
    PhysicalDeviceMultiviewFeatures :: 1000053001;
    PhysicalDeviceMultiviewProperties :: 1000053002;
    PhysicalDeviceVariablePointersFeatures :: 1000120000;
    ProtectedSubmitInfo :: 1000145000;
    PhysicalDeviceProtectedMemoryFeatures :: 1000145001;
    PhysicalDeviceProtectedMemoryProperties :: 1000145002;
    DeviceQueueInfo2 :: 1000145003;
    SamplerYcbcrConversionCreateInfo :: 1000156000;
    SamplerYcbcrConversionInfo :: 1000156001;
    BindImagePlaneMemoryInfo :: 1000156002;
    ImagePlaneMemoryRequirementsInfo :: 1000156003;
    PhysicalDeviceSamplerYcbcrConversionFeatures :: 1000156004;
    SamplerYcbcrConversionImageFormatProperties :: 1000156005;
    DescriptorUpdateTemplateCreateInfo :: 1000085000;
    PhysicalDeviceExternalImageFormatInfo :: 1000071000;
    ExternalImageFormatProperties :: 1000071001;
    PhysicalDeviceExternalBufferInfo :: 1000071002;
    ExternalBufferProperties :: 1000071003;
    PhysicalDeviceIdProperties :: 1000071004;
    ExternalMemoryBufferCreateInfo :: 1000072000;
    ExternalMemoryImageCreateInfo :: 1000072001;
    ExportMemoryAllocateInfo :: 1000072002;
    PhysicalDeviceExternalFenceInfo :: 1000112000;
    ExternalFenceProperties :: 1000112001;
    ExportFenceCreateInfo :: 1000113000;
    ExportSemaphoreCreateInfo :: 1000077000;
    PhysicalDeviceExternalSemaphoreInfo :: 1000076000;
    ExternalSemaphoreProperties :: 1000076001;
    PhysicalDeviceMaintenance3_properties :: 1000168000;
    DescriptorSetLayoutSupport :: 1000168001;
    PhysicalDeviceShaderDrawParametersFeatures :: 1000063000;
    PhysicalDeviceVulkan1_1Features :: 49;
    PhysicalDeviceVulkan1_1Properties :: 50;
    PhysicalDeviceVulkan1_2Features :: 51;
    PhysicalDeviceVulkan1_2Properties :: 52;
    ImageFormatListCreateInfo :: 1000147000;
    AttachmentDescription2 :: 1000109000;
    AttachmentReference2 :: 1000109001;
    SubpassDescription2 :: 1000109002;
    SubpassDependency2 :: 1000109003;
    RenderPassCreateInfo2 :: 1000109004;
    SubpassBeginInfo :: 1000109005;
    SubpassEndInfo :: 1000109006;
    PhysicalDevice8BitStorageFeatures :: 1000177000;
    PhysicalDeviceDriverProperties :: 1000196000;
    PhysicalDeviceShaderAtomicInt64Features :: 1000180000;
    PhysicalDeviceShaderFloat16Int8Features :: 1000082000;
    PhysicalDeviceFloatControlsProperties :: 1000197000;
    DescriptorSetLayoutBindingFlagsCreateInfo :: 1000161000;
    PhysicalDeviceDescriptorIndexingFeatures :: 1000161001;
    PhysicalDeviceDescriptorIndexingProperties :: 1000161002;
    DescriptorSetVariableDescriptorCountAllocateInfo :: 1000161003;
    DescriptorSetVariableDescriptorCountLayoutSupport :: 1000161004;
    PhysicalDeviceDepthStencilResolveProperties :: 1000199000;
    SubpassDescriptionDepthStencilResolve :: 1000199001;
    PhysicalDeviceScalarBlockLayoutFeatures :: 1000221000;
    ImageStencilUsageCreateInfo :: 1000246000;
    PhysicalDeviceSamplerFilterMinmaxProperties :: 1000130000;
    SamplerReductionModeCreateInfo :: 1000130001;
    PhysicalDeviceVulkanMemoryModelFeatures :: 1000211000;
    PhysicalDeviceImagelessFramebufferFeatures :: 1000108000;
    FramebufferAttachmentsCreateInfo :: 1000108001;
    FramebufferAttachmentImageInfo :: 1000108002;
    RenderPassAttachmentBeginInfo :: 1000108003;
    PhysicalDeviceUniformBufferStandardLayoutFeatures :: 1000253000;
    PhysicalDeviceShaderSubgroupExtendedTypesFeatures :: 1000175000;
    PhysicalDeviceSeparateDepthStencilLayoutsFeatures :: 1000241000;
    AttachmentReferenceStencilLayout :: 1000241001;
    AttachmentDescriptionStencilLayout :: 1000241002;
    PhysicalDeviceHostQueryResetFeatures :: 1000261000;
    PhysicalDeviceTimelineSemaphoreFeatures :: 1000207000;
    PhysicalDeviceTimelineSemaphoreProperties :: 1000207001;
    SemaphoreTypeCreateInfo :: 1000207002;
    TimelineSemaphoreSubmitInfo :: 1000207003;
    SemaphoreWaitInfo :: 1000207004;
    SemaphoreSignalInfo :: 1000207005;
    PhysicalDeviceBufferDeviceAddressFeatures :: 1000257000;
    BufferDeviceAddressInfo :: 1000244001;
    BufferOpaqueCaptureAddressCreateInfo :: 1000257002;
    MemoryOpaqueCaptureAddressAllocateInfo :: 1000257003;
    DeviceMemoryOpaqueCaptureAddressInfo :: 1000257004;
    SwapchainCreateInfoKhr :: 1000001000;
    PresentInfoKhr :: 1000001001;
    DeviceGroupPresentCapabilitiesKhr :: 1000060007;
    ImageSwapchainCreateInfoKhr :: 1000060008;
    BindImageMemorySwapchainInfoKhr :: 1000060009;
    AcquireNextImageInfoKhr :: 1000060010;
    DeviceGroupPresentInfoKhr :: 1000060011;
    DeviceGroupSwapchainCreateInfoKhr :: 1000060012;
    DisplayModeCreateInfoKhr :: 1000002000;
    DisplaySurfaceCreateInfoKhr :: 1000002001;
    DisplayPresentInfoKhr :: 1000003000;
    XlibSurfaceCreateInfoKhr :: 1000004000;
    XcbSurfaceCreateInfoKhr :: 1000005000;
    WaylandSurfaceCreateInfoKhr :: 1000006000;
    AndroidSurfaceCreateInfoKhr :: 1000008000;
    Win32SurfaceCreateInfoKhr :: 1000009000;
    DebugReportCallbackCreateInfoExt :: 1000011000;
    PipelineRasterizationStateRasterizationOrderAmd :: 1000018000;
    DebugMarkerObjectNameInfoExt :: 1000022000;
    DebugMarkerObjectTagInfoExt :: 1000022001;
    DebugMarkerMarkerInfoExt :: 1000022002;
    DedicatedAllocationImageCreateInfoNv :: 1000026000;
    DedicatedAllocationBufferCreateInfoNv :: 1000026001;
    DedicatedAllocationMemoryAllocateInfoNv :: 1000026002;
    PhysicalDeviceTransformFeedbackFeaturesExt :: 1000028000;
    PhysicalDeviceTransformFeedbackPropertiesExt :: 1000028001;
    PipelineRasterizationStateStreamCreateInfoExt :: 1000028002;
    ImageViewHandleInfoNvx :: 1000030000;
    ImageViewAddressPropertiesNvx :: 1000030001;
    TextureLodGatherFormatPropertiesAmd :: 1000041000;
    StreamDescriptorSurfaceCreateInfoGgp :: 1000049000;
    PhysicalDeviceCornerSampledImageFeaturesNv :: 1000050000;
    ExternalMemoryImageCreateInfoNv :: 1000056000;
    ExportMemoryAllocateInfoNv :: 1000056001;
    ImportMemoryWin32HandleInfoNv :: 1000057000;
    ExportMemoryWin32HandleInfoNv :: 1000057001;
    Win32KeyedMutexAcquireReleaseInfoNv :: 1000058000;
    ValidationFlagsExt :: 1000061000;
    ViSurfaceCreateInfoNn :: 1000062000;
    PhysicalDeviceTextureCompressionAstcHdrFeaturesExt :: 1000066000;
    ImageViewAstcDecodeModeExt :: 1000067000;
    PhysicalDeviceAstcDecodeFeaturesExt :: 1000067001;
    ImportMemoryWin32HandleInfoKhr :: 1000073000;
    ExportMemoryWin32HandleInfoKhr :: 1000073001;
    MemoryWin32HandlePropertiesKhr :: 1000073002;
    MemoryGetWin32HandleInfoKhr :: 1000073003;
    ImportMemoryFdInfoKhr :: 1000074000;
    MemoryFdPropertiesKhr :: 1000074001;
    MemoryGetFdInfoKhr :: 1000074002;
    Win32KeyedMutexAcquireReleaseInfoKhr :: 1000075000;
    ImportSemaphoreWin32HandleInfoKhr :: 1000078000;
    ExportSemaphoreWin32HandleInfoKhr :: 1000078001;
    D3D12FenceSubmitInfoKhr :: 1000078002;
    SemaphoreGetWin32HandleInfoKhr :: 1000078003;
    ImportSemaphoreFdInfoKhr :: 1000079000;
    SemaphoreGetFdInfoKhr :: 1000079001;
    PhysicalDevicePushDescriptorPropertiesKhr :: 1000080000;
    CommandBufferInheritanceConditionalRenderingInfoExt :: 1000081000;
    PhysicalDeviceConditionalRenderingFeaturesExt :: 1000081001;
    ConditionalRenderingBeginInfoExt :: 1000081002;
    PresentRegionsKhr :: 1000084000;
    PipelineViewportW_scalingStateCreateInfoNv :: 1000087000;
    SurfaceCapabilities2_ext :: 1000090000;
    DisplayPowerInfoExt :: 1000091000;
    DeviceEventInfoExt :: 1000091001;
    DisplayEventInfoExt :: 1000091002;
    SwapchainCounterCreateInfoExt :: 1000091003;
    PresentTimesInfoGoogle :: 1000092000;
    PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx :: 1000097000;
    PipelineViewportSwizzleStateCreateInfoNv :: 1000098000;
    PhysicalDeviceDiscardRectanglePropertiesExt :: 1000099000;
    PipelineDiscardRectangleStateCreateInfoExt :: 1000099001;
    PhysicalDeviceConservativeRasterizationPropertiesExt :: 1000101000;
    PipelineRasterizationConservativeStateCreateInfoExt :: 1000101001;
    PhysicalDeviceDepthClipEnableFeaturesExt :: 1000102000;
    PipelineRasterizationDepthClipStateCreateInfoExt :: 1000102001;
    HdrMetadataExt :: 1000105000;
    SharedPresentSurfaceCapabilitiesKhr :: 1000111000;
    ImportFenceWin32HandleInfoKhr :: 1000114000;
    ExportFenceWin32HandleInfoKhr :: 1000114001;
    FenceGetWin32HandleInfoKhr :: 1000114002;
    ImportFenceFdInfoKhr :: 1000115000;
    FenceGetFdInfoKhr :: 1000115001;
    PhysicalDevicePerformanceQueryFeaturesKhr :: 1000116000;
    PhysicalDevicePerformanceQueryPropertiesKhr :: 1000116001;
    QueryPoolPerformanceCreateInfoKhr :: 1000116002;
    PerformanceQuerySubmitInfoKhr :: 1000116003;
    AcquireProfilingLockInfoKhr :: 1000116004;
    PerformanceCounterKhr :: 1000116005;
    PerformanceCounterDescriptionKhr :: 1000116006;
    PhysicalDeviceSurfaceInfo2_khr :: 1000119000;
    SurfaceCapabilities2_khr :: 1000119001;
    SurfaceFormat2_khr :: 1000119002;
    DisplayProperties2_khr :: 1000121000;
    DisplayPlaneProperties2_khr :: 1000121001;
    DisplayModeProperties2_khr :: 1000121002;
    DisplayPlaneInfo2_khr :: 1000121003;
    DisplayPlaneCapabilities2_khr :: 1000121004;
    IosSurfaceCreateInfoMvk :: 1000122000;
    MacosSurfaceCreateInfoMvk :: 1000123000;
    DebugUtilsObjectNameInfoExt :: 1000128000;
    DebugUtilsObjectTagInfoExt :: 1000128001;
    DebugUtilsLabelExt :: 1000128002;
    DebugUtilsMessengerCallbackDataExt :: 1000128003;
    DebugUtilsMessengerCreateInfoExt :: 1000128004;
    AndroidHardwareBufferUsageAndroid :: 1000129000;
    AndroidHardwareBufferPropertiesAndroid :: 1000129001;
    AndroidHardwareBufferFormatPropertiesAndroid :: 1000129002;
    ImportAndroidHardwareBufferInfoAndroid :: 1000129003;
    MemoryGetAndroidHardwareBufferInfoAndroid :: 1000129004;
    ExternalFormatAndroid :: 1000129005;
    PhysicalDeviceInlineUniformBlockFeaturesExt :: 1000138000;
    PhysicalDeviceInlineUniformBlockPropertiesExt :: 1000138001;
    WriteDescriptorSetInlineUniformBlockExt :: 1000138002;
    DescriptorPoolInlineUniformBlockCreateInfoExt :: 1000138003;
    SampleLocationsInfoExt :: 1000143000;
    RenderPassSampleLocationsBeginInfoExt :: 1000143001;
    PipelineSampleLocationsStateCreateInfoExt :: 1000143002;
    PhysicalDeviceSampleLocationsPropertiesExt :: 1000143003;
    MultisamplePropertiesExt :: 1000143004;
    PhysicalDeviceBlendOperationAdvancedFeaturesExt :: 1000148000;
    PhysicalDeviceBlendOperationAdvancedPropertiesExt :: 1000148001;
    PipelineColorBlendAdvancedStateCreateInfoExt :: 1000148002;
    PipelineCoverageToColorStateCreateInfoNv :: 1000149000;
    WriteDescriptorSetAccelerationStructureKhr :: 1000150007;
    AccelerationStructureBuildGeometryInfoKhr :: 1000150000;
    AccelerationStructureDeviceAddressInfoKhr :: 1000150002;
    AccelerationStructureGeometryAabbsDataKhr :: 1000150003;
    AccelerationStructureGeometryInstancesDataKhr :: 1000150004;
    AccelerationStructureGeometryTrianglesDataKhr :: 1000150005;
    AccelerationStructureGeometryKhr :: 1000150006;
    AccelerationStructureVersionInfoKhr :: 1000150009;
    CopyAccelerationStructureInfoKhr :: 1000150010;
    CopyAccelerationStructureToMemoryInfoKhr :: 1000150011;
    CopyMemoryToAccelerationStructureInfoKhr :: 1000150012;
    PhysicalDeviceAccelerationStructureFeaturesKhr :: 1000150013;
    PhysicalDeviceAccelerationStructurePropertiesKhr :: 1000150014;
    AccelerationStructureCreateInfoKhr :: 1000150017;
    AccelerationStructureBuildSizesInfoKhr :: 1000150020;
    PhysicalDeviceRayTracingPipelineFeaturesKhr :: 1000347000;
    PhysicalDeviceRayTracingPipelinePropertiesKhr :: 1000347001;
    RayTracingPipelineCreateInfoKhr :: 1000150015;
    RayTracingShaderGroupCreateInfoKhr :: 1000150016;
    RayTracingPipelineInterfaceCreateInfoKhr :: 1000150018;
    PhysicalDeviceRayQueryFeaturesKhr :: 1000348013;
    PipelineCoverageModulationStateCreateInfoNv :: 1000152000;
    PhysicalDeviceShaderSmBuiltinsFeaturesNv :: 1000154000;
    PhysicalDeviceShaderSmBuiltinsPropertiesNv :: 1000154001;
    DrmFormatModifierPropertiesListExt :: 1000158000;
    PhysicalDeviceImageDrmFormatModifierInfoExt :: 1000158002;
    ImageDrmFormatModifierListCreateInfoExt :: 1000158003;
    ImageDrmFormatModifierExplicitCreateInfoExt :: 1000158004;
    ImageDrmFormatModifierPropertiesExt :: 1000158005;
    ValidationCacheCreateInfoExt :: 1000160000;
    ShaderModuleValidationCacheCreateInfoExt :: 1000160001;
    PhysicalDevicePortabilitySubsetFeaturesKhr :: 1000163000;
    PhysicalDevicePortabilitySubsetPropertiesKhr :: 1000163001;
    PipelineViewportShadingRateImageStateCreateInfoNv :: 1000164000;
    PhysicalDeviceShadingRateImageFeaturesNv :: 1000164001;
    PhysicalDeviceShadingRateImagePropertiesNv :: 1000164002;
    PipelineViewportCoarseSampleOrderStateCreateInfoNv :: 1000164005;
    RayTracingPipelineCreateInfoNv :: 1000165000;
    AccelerationStructureCreateInfoNv :: 1000165001;
    GeometryNv :: 1000165003;
    GeometryTrianglesNv :: 1000165004;
    GeometryAabbNv :: 1000165005;
    BindAccelerationStructureMemoryInfoNv :: 1000165006;
    WriteDescriptorSetAccelerationStructureNv :: 1000165007;
    AccelerationStructureMemoryRequirementsInfoNv :: 1000165008;
    PhysicalDeviceRayTracingPropertiesNv :: 1000165009;
    RayTracingShaderGroupCreateInfoNv :: 1000165011;
    AccelerationStructureInfoNv :: 1000165012;
    PhysicalDeviceRepresentativeFragmentTestFeaturesNv :: 1000166000;
    PipelineRepresentativeFragmentTestStateCreateInfoNv :: 1000166001;
    PhysicalDeviceImageViewImageFormatInfoExt :: 1000170000;
    FilterCubicImageViewImageFormatPropertiesExt :: 1000170001;
    DeviceQueueGlobalPriorityCreateInfoExt :: 1000174000;
    ImportMemoryHostPointerInfoExt :: 1000178000;
    MemoryHostPointerPropertiesExt :: 1000178001;
    PhysicalDeviceExternalMemoryHostPropertiesExt :: 1000178002;
    PhysicalDeviceShaderClockFeaturesKhr :: 1000181000;
    PipelineCompilerControlCreateInfoAmd :: 1000183000;
    CalibratedTimestampInfoExt :: 1000184000;
    PhysicalDeviceShaderCorePropertiesAmd :: 1000185000;
    DeviceMemoryOverallocationCreateInfoAmd :: 1000189000;
    PhysicalDeviceVertexAttributeDivisorPropertiesExt :: 1000190000;
    PipelineVertexInputDivisorStateCreateInfoExt :: 1000190001;
    PhysicalDeviceVertexAttributeDivisorFeaturesExt :: 1000190002;
    PresentFrameTokenGgp :: 1000191000;
    PipelineCreationFeedbackCreateInfoExt :: 1000192000;
    PhysicalDeviceComputeShaderDerivativesFeaturesNv :: 1000201000;
    PhysicalDeviceMeshShaderFeaturesNv :: 1000202000;
    PhysicalDeviceMeshShaderPropertiesNv :: 1000202001;
    PhysicalDeviceFragmentShaderBarycentricFeaturesNv :: 1000203000;
    PhysicalDeviceShaderImageFootprintFeaturesNv :: 1000204000;
    PipelineViewportExclusiveScissorStateCreateInfoNv :: 1000205000;
    PhysicalDeviceExclusiveScissorFeaturesNv :: 1000205002;
    CheckpointDataNv :: 1000206000;
    QueueFamilyCheckpointPropertiesNv :: 1000206001;
    PhysicalDeviceShaderIntegerFunctions2_featuresIntel :: 1000209000;
    QueryPoolPerformanceQueryCreateInfoIntel :: 1000210000;
    InitializePerformanceApiInfoIntel :: 1000210001;
    PerformanceMarkerInfoIntel :: 1000210002;
    PerformanceStreamMarkerInfoIntel :: 1000210003;
    PerformanceOverrideInfoIntel :: 1000210004;
    PerformanceConfigurationAcquireInfoIntel :: 1000210005;
    PhysicalDevicePciBusInfoPropertiesExt :: 1000212000;
    DisplayNativeHdrSurfaceCapabilitiesAmd :: 1000213000;
    SwapchainDisplayNativeHdrCreateInfoAmd :: 1000213001;
    ImagepipeSurfaceCreateInfoFuchsia :: 1000214000;
    PhysicalDeviceShaderTerminateInvocationFeaturesKhr :: 1000215000;
    MetalSurfaceCreateInfoExt :: 1000217000;
    PhysicalDeviceFragmentDensityMapFeaturesExt :: 1000218000;
    PhysicalDeviceFragmentDensityMapPropertiesExt :: 1000218001;
    RenderPassFragmentDensityMapCreateInfoExt :: 1000218002;
    PhysicalDeviceSubgroupSizeControlPropertiesExt :: 1000225000;
    PipelineShaderStageRequiredSubgroupSizeCreateInfoExt :: 1000225001;
    PhysicalDeviceSubgroupSizeControlFeaturesExt :: 1000225002;
    FragmentShadingRateAttachmentInfoKhr :: 1000226000;
    PipelineFragmentShadingRateStateCreateInfoKhr :: 1000226001;
    PhysicalDeviceFragmentShadingRatePropertiesKhr :: 1000226002;
    PhysicalDeviceFragmentShadingRateFeaturesKhr :: 1000226003;
    PhysicalDeviceFragmentShadingRateKhr :: 1000226004;
    PhysicalDeviceShaderCoreProperties2_amd :: 1000227000;
    PhysicalDeviceCoherentMemoryFeaturesAmd :: 1000229000;
    PhysicalDeviceShaderImageAtomicInt64FeaturesExt :: 1000234000;
    PhysicalDeviceMemoryBudgetPropertiesExt :: 1000237000;
    PhysicalDeviceMemoryPriorityFeaturesExt :: 1000238000;
    MemoryPriorityAllocateInfoExt :: 1000238001;
    SurfaceProtectedCapabilitiesKhr :: 1000239000;
    PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNv :: 1000240000;
    PhysicalDeviceBufferDeviceAddressFeaturesExt :: 1000244000;
    BufferDeviceAddressCreateInfoExt :: 1000244002;
    PhysicalDeviceToolPropertiesExt :: 1000245000;
    ValidationFeaturesExt :: 1000247000;
    PhysicalDeviceCooperativeMatrixFeaturesNv :: 1000249000;
    CooperativeMatrixPropertiesNv :: 1000249001;
    PhysicalDeviceCooperativeMatrixPropertiesNv :: 1000249002;
    PhysicalDeviceCoverageReductionModeFeaturesNv :: 1000250000;
    PipelineCoverageReductionStateCreateInfoNv :: 1000250001;
    FramebufferMixedSamplesCombinationNv :: 1000250002;
    PhysicalDeviceFragmentShaderInterlockFeaturesExt :: 1000251000;
    PhysicalDeviceYcbcrImageArraysFeaturesExt :: 1000252000;
    SurfaceFullScreenExclusiveInfoExt :: 1000255000;
    SurfaceCapabilitiesFullScreenExclusiveExt :: 1000255002;
    SurfaceFullScreenExclusiveWin32InfoExt :: 1000255001;
    HeadlessSurfaceCreateInfoExt :: 1000256000;
    PhysicalDeviceLineRasterizationFeaturesExt :: 1000259000;
    PipelineRasterizationLineStateCreateInfoExt :: 1000259001;
    PhysicalDeviceLineRasterizationPropertiesExt :: 1000259002;
    PhysicalDeviceShaderAtomicFloatFeaturesExt :: 1000260000;
    PhysicalDeviceIndexTypeUint8FeaturesExt :: 1000265000;
    PhysicalDeviceExtendedDynamicStateFeaturesExt :: 1000267000;
    PhysicalDevicePipelineExecutablePropertiesFeaturesKhr :: 1000269000;
    PipelineInfoKhr :: 1000269001;
    PipelineExecutablePropertiesKhr :: 1000269002;
    PipelineExecutableInfoKhr :: 1000269003;
    PipelineExecutableStatisticKhr :: 1000269004;
    PipelineExecutableInternalRepresentationKhr :: 1000269005;
    PhysicalDeviceShaderDemoteToHelperInvocationFeaturesExt :: 1000276000;
    PhysicalDeviceDeviceGeneratedCommandsPropertiesNv :: 1000277000;
    GraphicsShaderGroupCreateInfoNv :: 1000277001;
    GraphicsPipelineShaderGroupsCreateInfoNv :: 1000277002;
    IndirectCommandsLayoutTokenNv :: 1000277003;
    IndirectCommandsLayoutCreateInfoNv :: 1000277004;
    GeneratedCommandsInfoNv :: 1000277005;
    GeneratedCommandsMemoryRequirementsInfoNv :: 1000277006;
    PhysicalDeviceDeviceGeneratedCommandsFeaturesNv :: 1000277007;
    PhysicalDeviceTexelBufferAlignmentFeaturesExt :: 1000281000;
    PhysicalDeviceTexelBufferAlignmentPropertiesExt :: 1000281001;
    CommandBufferInheritanceRenderPassTransformInfoQcom :: 1000282000;
    RenderPassTransformBeginInfoQcom :: 1000282001;
    PhysicalDeviceDeviceMemoryReportFeaturesExt :: 1000284000;
    DeviceDeviceMemoryReportCreateInfoExt :: 1000284001;
    DeviceMemoryReportCallbackDataExt :: 1000284002;
    PhysicalDeviceRobustness2_featuresExt :: 1000286000;
    PhysicalDeviceRobustness2_propertiesExt :: 1000286001;
    SamplerCustomBorderColorCreateInfoExt :: 1000287000;
    PhysicalDeviceCustomBorderColorPropertiesExt :: 1000287001;
    PhysicalDeviceCustomBorderColorFeaturesExt :: 1000287002;
    PipelineLibraryCreateInfoKhr :: 1000290000;
    PhysicalDevicePrivateDataFeaturesExt :: 1000295000;
    DevicePrivateDataCreateInfoExt :: 1000295001;
    PrivateDataSlotCreateInfoExt :: 1000295002;
    PhysicalDevicePipelineCreationCacheControlFeaturesExt :: 1000297000;
    PhysicalDeviceDiagnosticsConfigFeaturesNv :: 1000300000;
    DeviceDiagnosticsConfigCreateInfoNv :: 1000300001;
    PhysicalDeviceDescriptorBufferPropertiesExt :: 1000316000;
    PhysicalDeviceDescriptorBufferDensityMapPropertiesExt :: 1000316001;
    PhysicalDeviceDescriptorBufferFeaturesExt :: 1000316002;
    DescriptorAddressInfoExt :: 1000316003;
    DescriptorGetInfoExt :: 1000316004;
    BufferCaptureDescriptorDataInfoExt :: 1000316005;
    ImageCaptureDescriptorDataInfoExt :: 1000316006;
    ImageViewCaptureDescriptorDataInfoExt :: 1000316007;
    SamplerCaptureDescriptorDataInfoExt :: 1000316008;
    OpaqueCaptureDescriptorDataCreateInfoExt :: 1000316010;
    DescriptorBufferBindingInfoExt :: 1000316011;
    DescriptorBufferBindingPushDescriptorBufferHandleExt :: 1000316012;
    PhysicalDeviceFragmentShadingRateEnumsPropertiesNv :: 1000326000;
    PhysicalDeviceFragmentShadingRateEnumsFeaturesNv :: 1000326001;
    PipelineFragmentShadingRateEnumStateCreateInfoNv :: 1000326002;
    PhysicalDeviceFragmentDensityMap2_featuresExt :: 1000332000;
    PhysicalDeviceFragmentDensityMap2_propertiesExt :: 1000332001;
    CopyCommandTransformInfoQcom :: 1000333000;
    PhysicalDeviceImageRobustnessFeaturesExt :: 1000335000;
    CopyBufferInfo2_khr :: 1000337000;
    CopyImageInfo2_khr :: 1000337001;
    CopyBufferToImageInfo2_khr :: 1000337002;
    CopyImageToBufferInfo2_khr :: 1000337003;
    BlitImageInfo2_khr :: 1000337004;
    ResolveImageInfo2_khr :: 1000337005;
    BufferCopy2_khr :: 1000337006;
    ImageCopy2_khr :: 1000337007;
    ImageBlit2_khr :: 1000337008;
    BufferImageCopy2_khr :: 1000337009;
    ImageResolve2_khr :: 1000337010;
    PhysicalDevice4444FormatsFeaturesExt :: 1000340000;
    DirectfbSurfaceCreateInfoExt :: 1000346000;
    PhysicalDeviceVariablePointerFeatures :: 1000120000;
    PhysicalDeviceShaderDrawParameterFeatures :: 1000063000;
    DebugReportCreateInfoExt :: 1000011000;
    RenderPassMultiviewCreateInfoKhr :: 1000053000;
    PhysicalDeviceMultiviewFeaturesKhr :: 1000053001;
    PhysicalDeviceMultiviewPropertiesKhr :: 1000053002;
    PhysicalDeviceFeatures2_khr :: 1000059000;
    PhysicalDeviceProperties2_khr :: 1000059001;
    FormatProperties2_khr :: 1000059002;
    ImageFormatProperties2_khr :: 1000059003;
    PhysicalDeviceImageFormatInfo2_khr :: 1000059004;
    QueueFamilyProperties2_khr :: 1000059005;
    PhysicalDeviceMemoryProperties2_khr :: 1000059006;
    SparseImageFormatProperties2_khr :: 1000059007;
    PhysicalDeviceSparseImageFormatInfo2_khr :: 1000059008;
    MemoryAllocateFlagsInfoKhr :: 1000060000;
    DeviceGroupRenderPassBeginInfoKhr :: 1000060003;
    DeviceGroupCommandBufferBeginInfoKhr :: 1000060004;
    DeviceGroupSubmitInfoKhr :: 1000060005;
    DeviceGroupBindSparseInfoKhr :: 1000060006;
    BindBufferMemoryDeviceGroupInfoKhr :: 1000060013;
    BindImageMemoryDeviceGroupInfoKhr :: 1000060014;
    PhysicalDeviceGroupPropertiesKhr :: 1000070000;
    DeviceGroupDeviceCreateInfoKhr :: 1000070001;
    PhysicalDeviceExternalImageFormatInfoKhr :: 1000071000;
    ExternalImageFormatPropertiesKhr :: 1000071001;
    PhysicalDeviceExternalBufferInfoKhr :: 1000071002;
    ExternalBufferPropertiesKhr :: 1000071003;
    PhysicalDeviceIdPropertiesKhr :: 1000071004;
    ExternalMemoryBufferCreateInfoKhr :: 1000072000;
    ExternalMemoryImageCreateInfoKhr :: 1000072001;
    ExportMemoryAllocateInfoKhr :: 1000072002;
    PhysicalDeviceExternalSemaphoreInfoKhr :: 1000076000;
    ExternalSemaphorePropertiesKhr :: 1000076001;
    ExportSemaphoreCreateInfoKhr :: 1000077000;
    PhysicalDeviceShaderFloat16Int8FeaturesKhr :: 1000082000;
    PhysicalDeviceFloat16Int8FeaturesKhr :: 1000082000;
    PhysicalDevice16BitStorageFeaturesKhr :: 1000083000;
    DescriptorUpdateTemplateCreateInfoKhr :: 1000085000;
    SurfaceCapabilities2Ext :: 1000090000;
    PhysicalDeviceImagelessFramebufferFeaturesKhr :: 1000108000;
    FramebufferAttachmentsCreateInfoKhr :: 1000108001;
    FramebufferAttachmentImageInfoKhr :: 1000108002;
    RenderPassAttachmentBeginInfoKhr :: 1000108003;
    AttachmentDescription2_khr :: 1000109000;
    AttachmentReference2_khr :: 1000109001;
    SubpassDescription2_khr :: 1000109002;
    SubpassDependency2_khr :: 1000109003;
    RenderPassCreateInfo2_khr :: 1000109004;
    SubpassBeginInfoKhr :: 1000109005;
    SubpassEndInfoKhr :: 1000109006;
    PhysicalDeviceExternalFenceInfoKhr :: 1000112000;
    ExternalFencePropertiesKhr :: 1000112001;
    ExportFenceCreateInfoKhr :: 1000113000;
    PhysicalDevicePointClippingPropertiesKhr :: 1000117000;
    RenderPassInputAttachmentAspectCreateInfoKhr :: 1000117001;
    ImageViewUsageCreateInfoKhr :: 1000117002;
    PipelineTessellationDomainOriginStateCreateInfoKhr :: 1000117003;
    PhysicalDeviceVariablePointersFeaturesKhr :: 1000120000;
    PhysicalDeviceVariablePointerFeaturesKhr :: 1000120000;
    MemoryDedicatedRequirementsKhr :: 1000127000;
    MemoryDedicatedAllocateInfoKhr :: 1000127001;
    PhysicalDeviceSamplerFilterMinmaxPropertiesExt :: 1000130000;
    SamplerReductionModeCreateInfoExt :: 1000130001;
    BufferMemoryRequirementsInfo2_khr :: 1000146000;
    ImageMemoryRequirementsInfo2_khr :: 1000146001;
    ImageSparseMemoryRequirementsInfo2_khr :: 1000146002;
    MemoryRequirements2_khr :: 1000146003;
    SparseImageMemoryRequirements2_khr :: 1000146004;
    ImageFormatListCreateInfoKhr :: 1000147000;
    SamplerYcbcrConversionCreateInfoKhr :: 1000156000;
    SamplerYcbcrConversionInfoKhr :: 1000156001;
    BindImagePlaneMemoryInfoKhr :: 1000156002;
    ImagePlaneMemoryRequirementsInfoKhr :: 1000156003;
    PhysicalDeviceSamplerYcbcrConversionFeaturesKhr :: 1000156004;
    SamplerYcbcrConversionImageFormatPropertiesKhr :: 1000156005;
    BindBufferMemoryInfoKhr :: 1000157000;
    BindImageMemoryInfoKhr :: 1000157001;
    DescriptorSetLayoutBindingFlagsCreateInfoExt :: 1000161000;
    PhysicalDeviceDescriptorIndexingFeaturesExt :: 1000161001;
    PhysicalDeviceDescriptorIndexingPropertiesExt :: 1000161002;
    DescriptorSetVariableDescriptorCountAllocateInfoExt :: 1000161003;
    DescriptorSetVariableDescriptorCountLayoutSupportExt :: 1000161004;
    PhysicalDeviceMaintenance3_propertiesKhr :: 1000168000;
    DescriptorSetLayoutSupportKhr :: 1000168001;
    PhysicalDeviceShaderSubgroupExtendedTypesFeaturesKhr :: 1000175000;
    PhysicalDevice8BitStorageFeaturesKhr :: 1000177000;
    PhysicalDeviceShaderAtomicInt64FeaturesKhr :: 1000180000;
    PhysicalDeviceDriverPropertiesKhr :: 1000196000;
    PhysicalDeviceFloatControlsPropertiesKhr :: 1000197000;
    PhysicalDeviceDepthStencilResolvePropertiesKhr :: 1000199000;
    SubpassDescriptionDepthStencilResolveKhr :: 1000199001;
    PhysicalDeviceTimelineSemaphoreFeaturesKhr :: 1000207000;
    PhysicalDeviceTimelineSemaphorePropertiesKhr :: 1000207001;
    SemaphoreTypeCreateInfoKhr :: 1000207002;
    TimelineSemaphoreSubmitInfoKhr :: 1000207003;
    SemaphoreWaitInfoKhr :: 1000207004;
    SemaphoreSignalInfoKhr :: 1000207005;
    QueryPoolCreateInfoIntel :: 1000210000;
    PhysicalDeviceVulkanMemoryModelFeaturesKhr :: 1000211000;
    PhysicalDeviceScalarBlockLayoutFeaturesExt :: 1000221000;
    PhysicalDeviceSeparateDepthStencilLayoutsFeaturesKhr :: 1000241000;
    AttachmentReferenceStencilLayoutKhr :: 1000241001;
    AttachmentDescriptionStencilLayoutKhr :: 1000241002;
    PhysicalDeviceBufferAddressFeaturesExt :: 1000244000;
    BufferDeviceAddressInfoExt :: 1000244001;
    ImageStencilUsageCreateInfoExt :: 1000246000;
    PhysicalDeviceUniformBufferStandardLayoutFeaturesKhr :: 1000253000;
    PhysicalDeviceBufferDeviceAddressFeaturesKhr :: 1000257000;
    BufferDeviceAddressInfoKhr :: 1000244001;
    BufferOpaqueCaptureAddressCreateInfoKhr :: 1000257002;
    MemoryOpaqueCaptureAddressAllocateInfoKhr :: 1000257003;
    DeviceMemoryOpaqueCaptureAddressInfoKhr :: 1000257004;
    PhysicalDeviceHostQueryResetFeaturesExt :: 1000261000;
}

ImageLayout :: enum s32 {
    Undefined :: 0;
    General :: 1;
    ColorAttachmentOptimal :: 2;
    DepthStencilAttachmentOptimal :: 3;
    DepthStencilReadOnlyOptimal :: 4;
    ShaderReadOnlyOptimal :: 5;
    TransferSrcOptimal :: 6;
    TransferDstOptimal :: 7;
    Preinitialized :: 8;
    DepthReadOnlyStencilAttachmentOptimal :: 1000117000;
    DepthAttachmentStencilReadOnlyOptimal :: 1000117001;
    DepthAttachmentOptimal :: 1000241000;
    DepthReadOnlyOptimal :: 1000241001;
    StencilAttachmentOptimal :: 1000241002;
    StencilReadOnlyOptimal :: 1000241003;
    PresentSrcKhr :: 1000001002;
    SharedPresentKhr :: 1000111000;
    ShadingRateOptimalNv :: 1000164003;
    FragmentDensityMapOptimalExt :: 1000218000;
    DepthReadOnlyStencilAttachmentOptimalKhr :: 1000117000;
    DepthAttachmentStencilReadOnlyOptimalKhr :: 1000117001;
    FragmentShadingRateAttachmentOptimalKhr :: 1000164003;
    DepthAttachmentOptimalKhr :: 1000241000;
    DepthReadOnlyOptimalKhr :: 1000241001;
    StencilAttachmentOptimalKhr :: 1000241002;
    StencilReadOnlyOptimalKhr :: 1000241003;
}

ObjectType :: enum s32 {
    Unknown :: 0;
    Instance :: 1;
    PhysicalDevice :: 2;
    Device :: 3;
    Queue :: 4;
    Semaphore :: 5;
    CommandBuffer :: 6;
    Fence :: 7;
    DeviceMemory :: 8;
    Buffer :: 9;
    Image :: 10;
    Event :: 11;
    QueryPool :: 12;
    BufferView :: 13;
    ImageView :: 14;
    ShaderModule :: 15;
    PipelineCache :: 16;
    PipelineLayout :: 17;
    RenderPass :: 18;
    Pipeline :: 19;
    DescriptorSetLayout :: 20;
    Sampler :: 21;
    DescriptorPool :: 22;
    DescriptorSet :: 23;
    Framebuffer :: 24;
    CommandPool :: 25;
    SamplerYcbcrConversion :: 1000156000;
    DescriptorUpdateTemplate :: 1000085000;
    SurfaceKhr :: 1000000000;
    SwapchainKhr :: 1000001000;
    DisplayKhr :: 1000002000;
    DisplayModeKhr :: 1000002001;
    DebugReportCallbackExt :: 1000011000;
    DebugUtilsMessengerExt :: 1000128000;
    AccelerationStructureKhr :: 1000150000;
    ValidationCacheExt :: 1000160000;
    AccelerationStructureNv :: 1000165000;
    PerformanceConfigurationIntel :: 1000210000;
    DeferredOperationKhr :: 1000268000;
    IndirectCommandsLayoutNv :: 1000277000;
    PrivateDataSlotExt :: 1000295000;
    DescriptorUpdateTemplateKhr :: 1000085000;
    SamplerYcbcrConversionKhr :: 1000156000;
}

VendorId :: enum s32 {
    Viv :: 65537;
    Vsi :: 65538;
    Kazan :: 65539;
    Codeplay :: 65540;
    Mesa :: 65541;
}

PipelineCacheHeaderVersion :: enum s32 {
    One :: 1;
}

SystemAllocationScope :: enum s32 {
    Command :: 0;
    Object :: 1;
    Cache :: 2;
    Device :: 3;
    Instance :: 4;
}

InternalAllocationType :: enum s32 {
    Executable :: 0;
}

Format :: enum s32 {
    Undefined :: 0;
    R4G4UnormPack8 :: 1;
    R4G4B4A4UnormPack16 :: 2;
    B4G4R4A4UnormPack16 :: 3;
    R5G6B5UnormPack16 :: 4;
    B5G6R5UnormPack16 :: 5;
    R5G5B5A1UnormPack16 :: 6;
    B5G5R5A1UnormPack16 :: 7;
    A1R5G5B5UnormPack16 :: 8;
    R8Unorm :: 9;
    R8Snorm :: 10;
    R8Uscaled :: 11;
    R8Sscaled :: 12;
    R8Uint :: 13;
    R8Sint :: 14;
    R8Srgb :: 15;
    R8G8Unorm :: 16;
    R8G8Snorm :: 17;
    R8G8Uscaled :: 18;
    R8G8Sscaled :: 19;
    R8G8Uint :: 20;
    R8G8Sint :: 21;
    R8G8Srgb :: 22;
    R8G8B8Unorm :: 23;
    R8G8B8Snorm :: 24;
    R8G8B8Uscaled :: 25;
    R8G8B8Sscaled :: 26;
    R8G8B8Uint :: 27;
    R8G8B8Sint :: 28;
    R8G8B8Srgb :: 29;
    B8G8R8Unorm :: 30;
    B8G8R8Snorm :: 31;
    B8G8R8Uscaled :: 32;
    B8G8R8Sscaled :: 33;
    B8G8R8Uint :: 34;
    B8G8R8Sint :: 35;
    B8G8R8Srgb :: 36;
    R8G8B8A8Unorm :: 37;
    R8G8B8A8Snorm :: 38;
    R8G8B8A8Uscaled :: 39;
    R8G8B8A8Sscaled :: 40;
    R8G8B8A8Uint :: 41;
    R8G8B8A8Sint :: 42;
    R8G8B8A8Srgb :: 43;
    B8G8R8A8Unorm :: 44;
    B8G8R8A8Snorm :: 45;
    B8G8R8A8Uscaled :: 46;
    B8G8R8A8Sscaled :: 47;
    B8G8R8A8Uint :: 48;
    B8G8R8A8Sint :: 49;
    B8G8R8A8Srgb :: 50;
    A8B8G8R8UnormPack32 :: 51;
    A8B8G8R8SnormPack32 :: 52;
    A8B8G8R8UscaledPack32 :: 53;
    A8B8G8R8SscaledPack32 :: 54;
    A8B8G8R8UintPack32 :: 55;
    A8B8G8R8SintPack32 :: 56;
    A8B8G8R8SrgbPack32 :: 57;
    A2R10G10B10UnormPack32 :: 58;
    A2R10G10B10SnormPack32 :: 59;
    A2R10G10B10UscaledPack32 :: 60;
    A2R10G10B10SscaledPack32 :: 61;
    A2R10G10B10UintPack32 :: 62;
    A2R10G10B10SintPack32 :: 63;
    A2B10G10R10UnormPack32 :: 64;
    A2B10G10R10SnormPack32 :: 65;
    A2B10G10R10UscaledPack32 :: 66;
    A2B10G10R10SscaledPack32 :: 67;
    A2B10G10R10UintPack32 :: 68;
    A2B10G10R10SintPack32 :: 69;
    R16Unorm :: 70;
    R16Snorm :: 71;
    R16Uscaled :: 72;
    R16Sscaled :: 73;
    R16Uint :: 74;
    R16Sint :: 75;
    R16Sfloat :: 76;
    R16G16Unorm :: 77;
    R16G16Snorm :: 78;
    R16G16Uscaled :: 79;
    R16G16Sscaled :: 80;
    R16G16Uint :: 81;
    R16G16Sint :: 82;
    R16G16Sfloat :: 83;
    R16G16B16Unorm :: 84;
    R16G16B16Snorm :: 85;
    R16G16B16Uscaled :: 86;
    R16G16B16Sscaled :: 87;
    R16G16B16Uint :: 88;
    R16G16B16Sint :: 89;
    R16G16B16Sfloat :: 90;
    R16G16B16A16Unorm :: 91;
    R16G16B16A16Snorm :: 92;
    R16G16B16A16Uscaled :: 93;
    R16G16B16A16Sscaled :: 94;
    R16G16B16A16Uint :: 95;
    R16G16B16A16Sint :: 96;
    R16G16B16A16Sfloat :: 97;
    R32Uint :: 98;
    R32Sint :: 99;
    R32Sfloat :: 100;
    R32G32Uint :: 101;
    R32G32Sint :: 102;
    R32G32Sfloat :: 103;
    R32G32B32Uint :: 104;
    R32G32B32Sint :: 105;
    R32G32B32Sfloat :: 106;
    R32G32B32A32Uint :: 107;
    R32G32B32A32Sint :: 108;
    R32G32B32A32Sfloat :: 109;
    R64Uint :: 110;
    R64Sint :: 111;
    R64Sfloat :: 112;
    R64G64Uint :: 113;
    R64G64Sint :: 114;
    R64G64Sfloat :: 115;
    R64G64B64Uint :: 116;
    R64G64B64Sint :: 117;
    R64G64B64Sfloat :: 118;
    R64G64B64A64Uint :: 119;
    R64G64B64A64Sint :: 120;
    R64G64B64A64Sfloat :: 121;
    B10G11R11UfloatPack32 :: 122;
    E5B9G9R9UfloatPack32 :: 123;
    D16Unorm :: 124;
    X8D24UnormPack32 :: 125;
    D32Sfloat :: 126;
    S8Uint :: 127;
    D16UnormS8Uint :: 128;
    D24UnormS8Uint :: 129;
    D32SfloatS8Uint :: 130;
    Bc1RgbUnormBlock :: 131;
    Bc1RgbSrgbBlock :: 132;
    Bc1RgbaUnormBlock :: 133;
    Bc1RgbaSrgbBlock :: 134;
    Bc2UnormBlock :: 135;
    Bc2SrgbBlock :: 136;
    Bc3UnormBlock :: 137;
    Bc3SrgbBlock :: 138;
    Bc4UnormBlock :: 139;
    Bc4SnormBlock :: 140;
    Bc5UnormBlock :: 141;
    Bc5SnormBlock :: 142;
    Bc6HUfloatBlock :: 143;
    Bc6HSfloatBlock :: 144;
    Bc7UnormBlock :: 145;
    Bc7SrgbBlock :: 146;
    Etc2R8G8B8UnormBlock :: 147;
    Etc2R8G8B8SrgbBlock :: 148;
    Etc2R8G8B8A1UnormBlock :: 149;
    Etc2R8G8B8A1SrgbBlock :: 150;
    Etc2R8G8B8A8UnormBlock :: 151;
    Etc2R8G8B8A8SrgbBlock :: 152;
    EacR11UnormBlock :: 153;
    EacR11SnormBlock :: 154;
    EacR11G11UnormBlock :: 155;
    EacR11G11SnormBlock :: 156;
    Astc4X4UnormBlock :: 157;
    Astc4X4SrgbBlock :: 158;
    Astc5X4UnormBlock :: 159;
    Astc5X4SrgbBlock :: 160;
    Astc5X5UnormBlock :: 161;
    Astc5X5SrgbBlock :: 162;
    Astc6X5UnormBlock :: 163;
    Astc6X5SrgbBlock :: 164;
    Astc6X6UnormBlock :: 165;
    Astc6X6SrgbBlock :: 166;
    Astc8X5UnormBlock :: 167;
    Astc8X5SrgbBlock :: 168;
    Astc8X6UnormBlock :: 169;
    Astc8X6SrgbBlock :: 170;
    Astc8X8UnormBlock :: 171;
    Astc8X8SrgbBlock :: 172;
    Astc10X5UnormBlock :: 173;
    Astc10X5SrgbBlock :: 174;
    Astc10X6UnormBlock :: 175;
    Astc10X6SrgbBlock :: 176;
    Astc10X8UnormBlock :: 177;
    Astc10X8SrgbBlock :: 178;
    Astc10X10UnormBlock :: 179;
    Astc10X10SrgbBlock :: 180;
    Astc12X10UnormBlock :: 181;
    Astc12X10SrgbBlock :: 182;
    Astc12X12UnormBlock :: 183;
    Astc12X12SrgbBlock :: 184;
    G8B8G8R8422Unorm :: 1000156000;
    B8G8R8G8422Unorm :: 1000156001;
    G8B8R83Plane420Unorm :: 1000156002;
    G8B8R82Plane420Unorm :: 1000156003;
    G8B8R83Plane422Unorm :: 1000156004;
    G8B8R82Plane422Unorm :: 1000156005;
    G8B8R83Plane444Unorm :: 1000156006;
    R10X6UnormPack16 :: 1000156007;
    R10X6G10X6Unorm2Pack16 :: 1000156008;
    R10X6G10X6B10X6A10X6Unorm4Pack16 :: 1000156009;
    G10X6B10X6G10X6R10X6422Unorm4Pack16 :: 1000156010;
    B10X6G10X6R10X6G10X6422Unorm4Pack16 :: 1000156011;
    G10X6B10X6R10X63Plane420Unorm3Pack16 :: 1000156012;
    G10X6B10X6R10X62Plane420Unorm3Pack16 :: 1000156013;
    G10X6B10X6R10X63Plane422Unorm3Pack16 :: 1000156014;
    G10X6B10X6R10X62Plane422Unorm3Pack16 :: 1000156015;
    G10X6B10X6R10X63Plane444Unorm3Pack16 :: 1000156016;
    R12X4UnormPack16 :: 1000156017;
    R12X4G12X4Unorm2Pack16 :: 1000156018;
    R12X4G12X4B12X4A12X4Unorm4Pack16 :: 1000156019;
    G12X4B12X4G12X4R12X4422Unorm4Pack16 :: 1000156020;
    B12X4G12X4R12X4G12X4422Unorm4Pack16 :: 1000156021;
    G12X4B12X4R12X43Plane420Unorm3Pack16 :: 1000156022;
    G12X4B12X4R12X42Plane420Unorm3Pack16 :: 1000156023;
    G12X4B12X4R12X43Plane422Unorm3Pack16 :: 1000156024;
    G12X4B12X4R12X42Plane422Unorm3Pack16 :: 1000156025;
    G12X4B12X4R12X43Plane444Unorm3Pack16 :: 1000156026;
    G16B16G16R16422Unorm :: 1000156027;
    B16G16R16G16422Unorm :: 1000156028;
    G16B16R163Plane420Unorm :: 1000156029;
    G16B16R162Plane420Unorm :: 1000156030;
    G16B16R163Plane422Unorm :: 1000156031;
    G16B16R162Plane422Unorm :: 1000156032;
    G16B16R163Plane444Unorm :: 1000156033;
    Pvrtc12BppUnormBlockImg :: 1000054000;
    Pvrtc14BppUnormBlockImg :: 1000054001;
    Pvrtc22BppUnormBlockImg :: 1000054002;
    Pvrtc24BppUnormBlockImg :: 1000054003;
    Pvrtc12BppSrgbBlockImg :: 1000054004;
    Pvrtc14BppSrgbBlockImg :: 1000054005;
    Pvrtc22BppSrgbBlockImg :: 1000054006;
    Pvrtc24BppSrgbBlockImg :: 1000054007;
    Astc4X4SfloatBlockExt :: 1000066000;
    Astc5X4SfloatBlockExt :: 1000066001;
    Astc5X5SfloatBlockExt :: 1000066002;
    Astc6X5SfloatBlockExt :: 1000066003;
    Astc6X6SfloatBlockExt :: 1000066004;
    Astc8X5SfloatBlockExt :: 1000066005;
    Astc8X6SfloatBlockExt :: 1000066006;
    Astc8X8SfloatBlockExt :: 1000066007;
    Astc10X5SfloatBlockExt :: 1000066008;
    Astc10X6SfloatBlockExt :: 1000066009;
    Astc10X8SfloatBlockExt :: 1000066010;
    Astc10X10SfloatBlockExt :: 1000066011;
    Astc12X10SfloatBlockExt :: 1000066012;
    Astc12X12SfloatBlockExt :: 1000066013;
    A4R4G4B4UnormPack16Ext :: 1000340000;
    A4B4G4R4UnormPack16Ext :: 1000340001;
    G8B8G8R8422UnormKhr :: 1000156000;
    B8G8R8G8422UnormKhr :: 1000156001;
    G8B8R83Plane420UnormKhr :: 1000156002;
    G8B8R82Plane420UnormKhr :: 1000156003;
    G8B8R83Plane422UnormKhr :: 1000156004;
    G8B8R82Plane422UnormKhr :: 1000156005;
    G8B8R83Plane444UnormKhr :: 1000156006;
    R10X6UnormPack16Khr :: 1000156007;
    R10X6G10X6Unorm2Pack16Khr :: 1000156008;
    R10X6G10X6B10X6A10X6Unorm4Pack16Khr :: 1000156009;
    G10X6B10X6G10X6R10X6422Unorm4Pack16Khr :: 1000156010;
    B10X6G10X6R10X6G10X6422Unorm4Pack16Khr :: 1000156011;
    G10X6B10X6R10X63Plane420Unorm3Pack16Khr :: 1000156012;
    G10X6B10X6R10X62Plane420Unorm3Pack16Khr :: 1000156013;
    G10X6B10X6R10X63Plane422Unorm3Pack16Khr :: 1000156014;
    G10X6B10X6R10X62Plane422Unorm3Pack16Khr :: 1000156015;
    G10X6B10X6R10X63Plane444Unorm3Pack16Khr :: 1000156016;
    R12X4UnormPack16Khr :: 1000156017;
    R12X4G12X4Unorm2Pack16Khr :: 1000156018;
    R12X4G12X4B12X4A12X4Unorm4Pack16Khr :: 1000156019;
    G12X4B12X4G12X4R12X4422Unorm4Pack16Khr :: 1000156020;
    B12X4G12X4R12X4G12X4422Unorm4Pack16Khr :: 1000156021;
    G12X4B12X4R12X43Plane420Unorm3Pack16Khr :: 1000156022;
    G12X4B12X4R12X42Plane420Unorm3Pack16Khr :: 1000156023;
    G12X4B12X4R12X43Plane422Unorm3Pack16Khr :: 1000156024;
    G12X4B12X4R12X42Plane422Unorm3Pack16Khr :: 1000156025;
    G12X4B12X4R12X43Plane444Unorm3Pack16Khr :: 1000156026;
    G16B16G16R16422UnormKhr :: 1000156027;
    B16G16R16G16422UnormKhr :: 1000156028;
    G16B16R163Plane420UnormKhr :: 1000156029;
    G16B16R162Plane420UnormKhr :: 1000156030;
    G16B16R163Plane422UnormKhr :: 1000156031;
    G16B16R162Plane422UnormKhr :: 1000156032;
    G16B16R163Plane444UnormKhr :: 1000156033;
}

ImageTiling :: enum s32 {
    Optimal :: 0;
    Linear :: 1;
    DrmFormatModifierExt :: 1000158000;
}

ImageType :: enum s32 {
    _1D :: 0;
    _2D :: 1;
    _3D :: 2;
}

PhysicalDeviceType :: enum s32 {
    Other :: 0;
    IntegratedGpu :: 1;
    DiscreteGpu :: 2;
    VirtualGpu :: 3;
    Cpu :: 4;
}

QueryType :: enum s32 {
    Occlusion :: 0;
    PipelineStatistics :: 1;
    Timestamp :: 2;
    TransformFeedbackStreamExt :: 1000028004;
    PerformanceQueryKhr :: 1000116000;
    AccelerationStructureCompactedSizeKhr :: 1000150000;
    AccelerationStructureSerializationSizeKhr :: 1000150001;
    AccelerationStructureCompactedSizeNv :: 1000165000;
    PerformanceQueryIntel :: 1000210000;
}

SharingMode :: enum s32 {
    Exclusive :: 0;
    Concurrent :: 1;
}

ComponentSwizzle :: enum s32 {
    Identity :: 0;
    Zero :: 1;
    One :: 2;
    R :: 3;
    G :: 4;
    B :: 5;
    A :: 6;
}

ImageViewType :: enum s32 {
    _1D :: 0;
    _2D :: 1;
    _3D :: 2;
    Cube :: 3;
    _1DArray :: 4;
    _2DArray :: 5;
    CubeArray :: 6;
}

BlendFactor :: enum s32 {
    Zero :: 0;
    One :: 1;
    SrcColor :: 2;
    OneMinusSrcColor :: 3;
    DstColor :: 4;
    OneMinusDstColor :: 5;
    SrcAlpha :: 6;
    OneMinusSrcAlpha :: 7;
    DstAlpha :: 8;
    OneMinusDstAlpha :: 9;
    ConstantColor :: 10;
    OneMinusConstantColor :: 11;
    ConstantAlpha :: 12;
    OneMinusConstantAlpha :: 13;
    SrcAlphaSaturate :: 14;
    Src1Color :: 15;
    OneMinusSrc1Color :: 16;
    Src1Alpha :: 17;
    OneMinusSrc1Alpha :: 18;
}

BlendOp :: enum s32 {
    Add :: 0;
    Subtract :: 1;
    ReverseSubtract :: 2;
    Min :: 3;
    Max :: 4;
    ZeroExt :: 1000148000;
    SrcExt :: 1000148001;
    DstExt :: 1000148002;
    SrcOverExt :: 1000148003;
    DstOverExt :: 1000148004;
    SrcInExt :: 1000148005;
    DstInExt :: 1000148006;
    SrcOutExt :: 1000148007;
    DstOutExt :: 1000148008;
    SrcAtopExt :: 1000148009;
    DstAtopExt :: 1000148010;
    XorExt :: 1000148011;
    MultiplyExt :: 1000148012;
    ScreenExt :: 1000148013;
    OverlayExt :: 1000148014;
    DarkenExt :: 1000148015;
    LightenExt :: 1000148016;
    ColordodgeExt :: 1000148017;
    ColorburnExt :: 1000148018;
    HardlightExt :: 1000148019;
    SoftlightExt :: 1000148020;
    DifferenceExt :: 1000148021;
    ExclusionExt :: 1000148022;
    InvertExt :: 1000148023;
    InvertRgbExt :: 1000148024;
    LineardodgeExt :: 1000148025;
    LinearburnExt :: 1000148026;
    VividlightExt :: 1000148027;
    LinearlightExt :: 1000148028;
    PinlightExt :: 1000148029;
    HardmixExt :: 1000148030;
    HslHueExt :: 1000148031;
    HslSaturationExt :: 1000148032;
    HslColorExt :: 1000148033;
    HslLuminosityExt :: 1000148034;
    PlusExt :: 1000148035;
    PlusClampedExt :: 1000148036;
    PlusClampedAlphaExt :: 1000148037;
    PlusDarkerExt :: 1000148038;
    MinusExt :: 1000148039;
    MinusClampedExt :: 1000148040;
    ContrastExt :: 1000148041;
    InvertOvgExt :: 1000148042;
    RedExt :: 1000148043;
    GreenExt :: 1000148044;
    BlueExt :: 1000148045;
}

CompareOp :: enum s32 {
    Never :: 0;
    Less :: 1;
    Equal :: 2;
    LessOrEqual :: 3;
    Greater :: 4;
    NotEqual :: 5;
    GreaterOrEqual :: 6;
    Always :: 7;
}

DynamicState :: enum s32 {
    Viewport :: 0;
    Scissor :: 1;
    LineWidth :: 2;
    DepthBias :: 3;
    BlendConstants :: 4;
    DepthBounds :: 5;
    StencilCompareMask :: 6;
    StencilWriteMask :: 7;
    StencilReference :: 8;
    ViewportW_scalingNv :: 1000087000;
    DiscardRectangleExt :: 1000099000;
    SampleLocationsExt :: 1000143000;
    RayTracingPipelineStackSizeKhr :: 1000347000;
    ViewportShadingRatePaletteNv :: 1000164004;
    ViewportCoarseSampleOrderNv :: 1000164006;
    ExclusiveScissorNv :: 1000205001;
    FragmentShadingRateKhr :: 1000226000;
    LineStippleExt :: 1000259000;
    CullModeExt :: 1000267000;
    FrontFaceExt :: 1000267001;
    PrimitiveTopologyExt :: 1000267002;
    ViewportWithCountExt :: 1000267003;
    ScissorWithCountExt :: 1000267004;
    VertexInputBindingStrideExt :: 1000267005;
    DepthTestEnableExt :: 1000267006;
    DepthWriteEnableExt :: 1000267007;
    DepthCompareOpExt :: 1000267008;
    DepthBoundsTestEnableExt :: 1000267009;
    StencilTestEnableExt :: 1000267010;
    StencilOpExt :: 1000267011;
}

FrontFace :: enum s32 {
    CounterClockwise :: 0;
    Clockwise :: 1;
}

VertexInputRate :: enum s32 {
    Vertex :: 0;
    Instance :: 1;
}

PrimitiveTopology :: enum s32 {
    PointList :: 0;
    LineList :: 1;
    LineStrip :: 2;
    TriangleList :: 3;
    TriangleStrip :: 4;
    TriangleFan :: 5;
    LineListWithAdjacency :: 6;
    LineStripWithAdjacency :: 7;
    TriangleListWithAdjacency :: 8;
    TriangleStripWithAdjacency :: 9;
    PatchList :: 10;
}

PolygonMode :: enum s32 {
    Fill :: 0;
    Line :: 1;
    Point :: 2;
    FillRectangleNv :: 1000153000;
}

StencilOp :: enum s32 {
    Keep :: 0;
    Zero :: 1;
    Replace :: 2;
    IncrementAndClamp :: 3;
    DecrementAndClamp :: 4;
    Invert :: 5;
    IncrementAndWrap :: 6;
    DecrementAndWrap :: 7;
}

LogicOp :: enum s32 {
    Clear :: 0;
    And :: 1;
    AndReverse :: 2;
    Copy :: 3;
    AndInverted :: 4;
    NoOp :: 5;
    Xor :: 6;
    Or :: 7;
    Nor :: 8;
    Equivalent :: 9;
    Invert :: 10;
    OrReverse :: 11;
    CopyInverted :: 12;
    OrInverted :: 13;
    Nand :: 14;
    Set :: 15;
}

BorderColor :: enum s32 {
    FloatTransparentBlack :: 0;
    IntTransparentBlack :: 1;
    FloatOpaqueBlack :: 2;
    IntOpaqueBlack :: 3;
    FloatOpaqueWhite :: 4;
    IntOpaqueWhite :: 5;
    FloatCustomExt :: 1000287003;
    IntCustomExt :: 1000287004;
}

Filter :: enum s32 {
    Nearest :: 0;
    Linear :: 1;
    CubicImg :: 1000015000;
    CubicExt :: 1000015000;
}

SamplerAddressMode :: enum s32 {
    Repeat :: 0;
    MirroredRepeat :: 1;
    ClampToEdge :: 2;
    ClampToBorder :: 3;
    MirrorClampToEdge :: 4;
    MirrorClampToEdgeKhr :: 4;
}

SamplerMipmapMode :: enum s32 {
    Nearest :: 0;
    Linear :: 1;
}

DescriptorType :: enum s32 {
    Sampler :: 0;
    CombinedImageSampler :: 1;
    SampledImage :: 2;
    StorageImage :: 3;
    UniformTexelBuffer :: 4;
    StorageTexelBuffer :: 5;
    UniformBuffer :: 6;
    StorageBuffer :: 7;
    UniformBufferDynamic :: 8;
    StorageBufferDynamic :: 9;
    InputAttachment :: 10;
    InlineUniformBlockExt :: 1000138000;
    AccelerationStructureKhr :: 1000150000;
    AccelerationStructureNv :: 1000165000;
}

AttachmentLoadOp :: enum s32 {
    Load :: 0;
    Clear :: 1;
    DontCare :: 2;
}

AttachmentStoreOp :: enum s32 {
    Store :: 0;
    DontCare :: 1;
    NoneQcom :: 1000301000;
}

PipelineBindPoint :: enum s32 {
    Graphics :: 0;
    Compute :: 1;
    RayTracingKhr :: 1000165000;
    RayTracingNv :: 1000165000;
}

CommandBufferLevel :: enum s32 {
    Primary :: 0;
    Secondary :: 1;
}

IndexType :: enum s32 {
    Uint16 :: 0;
    Uint32 :: 1;
    NoneKhr :: 1000165000;
    Uint8Ext :: 1000265000;
    NoneNv :: 1000165000;
}

SubpassContents :: enum s32 {
    Inline :: 0;
    SecondaryCommandBuffers :: 1;
}

AccessFlagBits :: enum_flags u32 {
    IndirectCommandRead :: 1;
    IndexRead :: 2;
    VertexAttributeRead :: 4;
    UniformRead :: 8;
    InputAttachmentRead :: 16;
    ShaderRead :: 32;
    ShaderWrite :: 64;
    ColorAttachmentRead :: 128;
    ColorAttachmentWrite :: 256;
    DepthStencilAttachmentRead :: 512;
    DepthStencilAttachmentWrite :: 1024;
    TransferRead :: 2048;
    TransferWrite :: 4096;
    HostRead :: 8192;
    HostWrite :: 16384;
    MemoryRead :: 32768;
    MemoryWrite :: 65536;
    TransformFeedbackWriteExt :: 33554432;
    TransformFeedbackCounterReadExt :: 67108864;
    TransformFeedbackCounterWriteExt :: 134217728;
    ConditionalRenderingReadExt :: 1048576;
    ColorAttachmentReadNoncoherentExt :: 524288;
    AccelerationStructureReadKhr :: 2097152;
    AccelerationStructureWriteKhr :: 4194304;
    ShadingRateImageReadNv :: 8388608;
    FragmentDensityMapReadExt :: 16777216;
    CommandPreprocessReadNv :: 131072;
    CommandPreprocessWriteNv :: 262144;
    AccelerationStructureReadNv :: 2097152;
    AccelerationStructureWriteNv :: 4194304;
    FragmentShadingRateAttachmentReadKhr :: 8388608;
}

ImageAspectFlagBits :: enum_flags u32 {
    Color :: 1;
    Depth :: 2;
    Stencil :: 4;
    Metadata :: 8;
    Plane0 :: 16;
    Plane1 :: 32;
    Plane2 :: 64;
    MemoryPlane0_ext :: 128;
    MemoryPlane1_ext :: 256;
    MemoryPlane2_ext :: 512;
    MemoryPlane3_ext :: 1024;
    Plane0_khr :: 16;
    Plane1_khr :: 32;
    Plane2_khr :: 64;
}

FormatFeatureFlagBits :: enum_flags u32 {
    SampledImage :: 1;
    StorageImage :: 2;
    StorageImageAtomic :: 4;
    UniformTexelBuffer :: 8;
    StorageTexelBuffer :: 16;
    StorageTexelBufferAtomic :: 32;
    VertexBuffer :: 64;
    ColorAttachment :: 128;
    ColorAttachmentBlend :: 256;
    DepthStencilAttachment :: 512;
    BlitSrc :: 1024;
    BlitDst :: 2048;
    SampledImageFilterLinear :: 4096;
    TransferSrc :: 16384;
    TransferDst :: 32768;
    MidpointChromaSamples :: 131072;
    SampledImageYcbcrConversionLinearFilter :: 262144;
    SampledImageYcbcrConversionSeparateReconstructionFilter :: 524288;
    SampledImageYcbcrConversionChromaReconstructionExplicit :: 1048576;
    SampledImageYcbcrConversionChromaReconstructionExplicitForceable :: 2097152;
    Disjoint :: 4194304;
    CositedChromaSamples :: 8388608;
    SampledImageFilterMinmax :: 65536;
    SampledImageFilterCubicImg :: 8192;
    AccelerationStructureVertexBufferKhr :: 536870912;
    FragmentDensityMapExt :: 16777216;
    FragmentShadingRateAttachmentKhr :: 1073741824;
    TransferSrcKhr :: 16384;
    TransferDstKhr :: 32768;
    SampledImageFilterMinmaxExt :: 65536;
    MidpointChromaSamplesKhr :: 131072;
    SampledImageYcbcrConversionLinearFilterKhr :: 262144;
    SampledImageYcbcrConversionSeparateReconstructionFilterKhr :: 524288;
    SampledImageYcbcrConversionChromaReconstructionExplicitKhr :: 1048576;
    SampledImageYcbcrConversionChromaReconstructionExplicitForceableKhr :: 2097152;
    DisjointKhr :: 4194304;
    CositedChromaSamplesKhr :: 8388608;
    SampledImageFilterCubicExt :: 8192;
}

ImageCreateFlagBits :: enum_flags u32 {
    SparseBinding :: 1;
    SparseResidency :: 2;
    SparseAliased :: 4;
    MutableFormat :: 8;
    CubeCompatible :: 16;
    Alias :: 1024;
    SplitInstanceBindRegions :: 64;
    _2DArrayCompatible :: 32;
    BlockTexelViewCompatible :: 128;
    ExtendedUsage :: 256;
    Protected :: 2048;
    Disjoint :: 512;
    CornerSampledNv :: 8192;
    SampleLocationsCompatibleDepthExt :: 4096;
    SubsampledExt :: 16384;
    SplitInstanceBindRegionsKhr :: 64;
    _2DArrayCompatibleKhr :: 32;
    BlockTexelViewCompatibleKhr :: 128;
    ExtendedUsageKhr :: 256;
    DisjointKhr :: 512;
    AliasKhr :: 1024;
}

SampleCountFlagBits :: enum_flags u32 {
    _1 :: 1;
    _2 :: 2;
    _4 :: 4;
    _8 :: 8;
    _16 :: 16;
    _32 :: 32;
    _64 :: 64;
}

ImageUsageFlagBits :: enum_flags u32 {
    TransferSrc :: 1;
    TransferDst :: 2;
    Sampled :: 4;
    Storage :: 8;
    ColorAttachment :: 16;
    DepthStencilAttachment :: 32;
    TransientAttachment :: 64;
    InputAttachment :: 128;
    ShadingRateImageNv :: 256;
    FragmentDensityMapExt :: 512;
    FragmentShadingRateAttachmentKhr :: 256;
}

MemoryHeapFlagBits :: enum_flags u32 {
    DeviceLocal :: 1;
    MultiInstance :: 2;
    MultiInstanceKhr :: 2;
}

MemoryPropertyFlagBits :: enum_flags u32 {
    DeviceLocal :: 1;
    HostVisible :: 2;
    HostCoherent :: 4;
    HostCached :: 8;
    LazilyAllocated :: 16;
    Protected :: 32;
    DeviceCoherentAmd :: 64;
    DeviceUncachedAmd :: 128;
}

QueueFlagBits :: enum_flags u32 {
    Graphics :: 1;
    Compute :: 2;
    Transfer :: 4;
    SparseBinding :: 8;
    Protected :: 16;
}

DeviceQueueCreateFlagBits :: enum_flags u32 {
    Protected :: 1;
}

PipelineStageFlagBits :: enum_flags u32 {
    TopOfPipe :: 1;
    DrawIndirect :: 2;
    VertexInput :: 4;
    VertexShader :: 8;
    TessellationControlShader :: 16;
    TessellationEvaluationShader :: 32;
    GeometryShader :: 64;
    FragmentShader :: 128;
    EarlyFragmentTests :: 256;
    LateFragmentTests :: 512;
    ColorAttachmentOutput :: 1024;
    ComputeShader :: 2048;
    Transfer :: 4096;
    BottomOfPipe :: 8192;
    Host :: 16384;
    AllGraphics :: 32768;
    AllCommands :: 65536;
    TransformFeedbackExt :: 16777216;
    ConditionalRenderingExt :: 262144;
    AccelerationStructureBuildKhr :: 33554432;
    RayTracingShaderKhr :: 2097152;
    ShadingRateImageNv :: 4194304;
    TaskShaderNv :: 524288;
    MeshShaderNv :: 1048576;
    FragmentDensityProcessExt :: 8388608;
    CommandPreprocessNv :: 131072;
    RayTracingShaderNv :: 2097152;
    AccelerationStructureBuildNv :: 33554432;
    FragmentShadingRateAttachmentKhr :: 4194304;
}

SparseMemoryBindFlagBits :: enum_flags u32 {
    Metadata :: 1;
}

SparseImageFormatFlagBits :: enum_flags u32 {
    SingleMiptail :: 1;
    AlignedMipSize :: 2;
    NonstandardBlockSize :: 4;
}

FenceCreateFlagBits :: enum_flags u32 {
    Signaled :: 1;
}

QueryPipelineStatisticFlagBits :: enum_flags u32 {
    InputAssemblyVertices :: 1;
    InputAssemblyPrimitives :: 2;
    VertexShaderInvocations :: 4;
    GeometryShaderInvocations :: 8;
    GeometryShaderPrimitives :: 16;
    ClippingInvocations :: 32;
    ClippingPrimitives :: 64;
    FragmentShaderInvocations :: 128;
    TessellationControlShaderPatches :: 256;
    TessellationEvaluationShaderInvocations :: 512;
    ComputeShaderInvocations :: 1024;
}

QueryResultFlagBits :: enum_flags u32 {
    _64 :: 1;
    Wait :: 2;
    WithAvailability :: 4;
    Partial :: 8;
}

BufferCreateFlagBits :: enum_flags u32 {
    SparseBinding :: 1;
    SparseResidency :: 2;
    SparseAliased :: 4;
    Protected :: 8;
    DeviceAddressCaptureReplay :: 16;
    DeviceAddressCaptureReplayExt :: 16;
    DeviceAddressCaptureReplayKhr :: 16;
}

BufferUsageFlagBits :: enum_flags u32 {
    TransferSrc :: 1;
    TransferDst :: 2;
    UniformTexelBuffer :: 4;
    StorageTexelBuffer :: 8;
    UniformBuffer :: 16;
    StorageBuffer :: 32;
    IndexBuffer :: 64;
    VertexBuffer :: 128;
    IndirectBuffer :: 256;
    ShaderDeviceAddress :: 131072;
    TransformFeedbackBufferExt :: 2048;
    TransformFeedbackCounterBufferExt :: 4096;
    ConditionalRenderingExt :: 512;
    AccelerationStructureBuildInputReadOnlyKhr :: 524288;
    AccelerationStructureStorageKhr :: 1048576;
    ShaderBindingTableKhr :: 1024;
    RayTracingNv :: 1024;
    ShaderDeviceAddressExt :: 131072;
    ShaderDeviceAddressKhr :: 131072;
    ResourceDescriptorBuffer :: 4194304;
}

ImageViewCreateFlagBits :: enum_flags u32 {
    FragmentDensityMapDynamicExt :: 1;
    FragmentDensityMapDeferredExt :: 2;
}

ShaderModuleCreateFlagBits :: enum_flags u32 {
}

PipelineCacheCreateFlagBits :: enum_flags u32 {
    ExternallySynchronizedExt :: 1;
}

ColorComponentFlagBits :: enum_flags u32 {
    R :: 1;
    G :: 2;
    B :: 4;
    A :: 8;
}

PipelineCreateFlagBits :: enum_flags u32 {
    DisableOptimization :: 1;
    AllowDerivatives :: 2;
    Derivative :: 4;
    ViewIndexFromDeviceIndex :: 8;
    DispatchBase :: 16;
    RayTracingNoNullAnyHitShadersKhr :: 16384;
    RayTracingNoNullClosestHitShadersKhr :: 32768;
    RayTracingNoNullMissShadersKhr :: 65536;
    RayTracingNoNullIntersectionShadersKhr :: 131072;
    RayTracingSkipTrianglesKhr :: 4096;
    RayTracingSkipAabbsKhr :: 8192;
    RayTracingShaderGroupHandleCaptureReplayKhr :: 524288;
    DeferCompileNv :: 32;
    CaptureStatisticsKhr :: 64;
    CaptureInternalRepresentationsKhr :: 128;
    IndirectBindableNv :: 262144;
    LibraryKhr :: 2048;
    FailOnPipelineCompileRequiredExt :: 256;
    EarlyReturnOnFailureExt :: 512;
    ViewIndexFromDeviceIndexKhr :: 8;
    DispatchBaseKhr :: 16;
    DescriptorBufferExt :: 536870912;
}

PipelineShaderStageCreateFlagBits :: enum_flags u32 {
    AllowVaryingSubgroupSizeExt :: 1;
    RequireFullSubgroupsExt :: 2;
}

ShaderStageFlagBits :: enum_flags u32 {
    Vertex :: 1;
    TessellationControl :: 2;
    TessellationEvaluation :: 4;
    Geometry :: 8;
    Fragment :: 16;
    Compute :: 32;
    AllGraphics :: 31;
    All :: 2147483647;
    RaygenKhr :: 256;
    AnyHitKhr :: 512;
    ClosestHitKhr :: 1024;
    MissKhr :: 2048;
    IntersectionKhr :: 4096;
    CallableKhr :: 8192;
    TaskNv :: 64;
    MeshNv :: 128;
    RaygenNv :: 256;
    AnyHitNv :: 512;
    ClosestHitNv :: 1024;
    MissNv :: 2048;
    IntersectionNv :: 4096;
    CallableNv :: 8192;
}

CullModeFlagBits :: enum_flags u32 {
    None :: 0;
    Front :: 1;
    Back :: 2;
    FrontAndBack :: 3;
}

SamplerCreateFlagBits :: enum_flags u32 {
    SubsampledExt :: 1;
    SubsampledCoarseReconstructionExt :: 2;
}

DescriptorPoolCreateFlagBits :: enum_flags u32 {
    FreeDescriptorSet :: 1;
    UpdateAfterBind :: 2;
    UpdateAfterBindExt :: 2;
}

DescriptorSetLayoutCreateFlagBits :: enum_flags u32 {
    UpdateAfterBindPool :: 2;
    PushDescriptorKhr :: 1;
    DescriptorBufferExt :: 16;
    UpdateAfterBindPoolExt :: 2;
}

AttachmentDescriptionFlagBits :: enum_flags u32 {
    MayAlias :: 1;
}

DependencyFlagBits :: enum_flags u32 {
    ByRegion :: 1;
    DeviceGroup :: 4;
    ViewLocal :: 2;
    ViewLocalKhr :: 2;
    DeviceGroupKhr :: 4;
}

FramebufferCreateFlagBits :: enum_flags u32 {
    Imageless :: 1;
    ImagelessKhr :: 1;
}

RenderPassCreateFlagBits :: enum_flags u32 {
    TransformBitQcom :: 2;
}

SubpassDescriptionFlagBits :: enum_flags u32 {
    PerViewAttributesNvx :: 1;
    PerViewPositionX_onlyNvx :: 2;
    FragmentRegionBitQcom :: 4;
    ShaderResolveBitQcom :: 8;
}

CommandPoolCreateFlagBits :: enum_flags u32 {
    Transient :: 1;
    ResetCommandBuffer :: 2;
    Protected :: 4;
}

CommandPoolResetFlagBits :: enum_flags u32 {
    ReleaseResources :: 1;
}

CommandBufferUsageFlagBits :: enum_flags u32 {
    OneTimeSubmit :: 1;
    RenderPassContinue :: 2;
    SimultaneousUse :: 4;
}

QueryControlFlagBits :: enum_flags u32 {
    Precise :: 1;
}

CommandBufferResetFlagBits :: enum_flags u32 {
    ReleaseResources :: 1;
}

StencilFaceFlagBits :: enum_flags u32 {
    Front :: 1;
    Back :: 2;
    FrontAndBack :: 3;
    StencilFrontAndBack :: 3;
}

PointClippingBehavior :: enum s32 {
    AllClipPlanes :: 0;
    UserClipPlanesOnly :: 1;
    AllClipPlanesKhr :: 0;
    UserClipPlanesOnlyKhr :: 1;
}

TessellationDomainOrigin :: enum s32 {
    UpperLeft :: 0;
    LowerLeft :: 1;
    UpperLeftKhr :: 0;
    LowerLeftKhr :: 1;
}

SamplerYcbcrModelConversion :: enum s32 {
    RgbIdentity :: 0;
    YcbcrIdentity :: 1;
    Ycbcr709 :: 2;
    Ycbcr601 :: 3;
    Ycbcr2020 :: 4;
    RgbIdentityKhr :: 0;
    YcbcrIdentityKhr :: 1;
    Ycbcr709Khr :: 2;
    Ycbcr601Khr :: 3;
    Ycbcr2020Khr :: 4;
}

SamplerYcbcrRange :: enum s32 {
    ItuFull :: 0;
    ItuNarrow :: 1;
    ItuFullKhr :: 0;
    ItuNarrowKhr :: 1;
}

ChromaLocation :: enum s32 {
    CositedEven :: 0;
    Midpoint :: 1;
    CositedEvenKhr :: 0;
    MidpointKhr :: 1;
}

DescriptorUpdateTemplateType :: enum s32 {
    DescriptorSet :: 0;
    PushDescriptorsKhr :: 1;
    DescriptorSetKhr :: 0;
}

SubgroupFeatureFlagBits :: enum_flags u32 {
    Basic :: 1;
    Vote :: 2;
    Arithmetic :: 4;
    Ballot :: 8;
    Shuffle :: 16;
    ShuffleRelative :: 32;
    Clustered :: 64;
    Quad :: 128;
    PartitionedNv :: 256;
}

PeerMemoryFeatureFlagBits :: enum_flags u32 {
    CopySrc :: 1;
    CopyDst :: 2;
    GenericSrc :: 4;
    GenericDst :: 8;
    CopySrcKhr :: 1;
    CopyDstKhr :: 2;
    GenericSrcKhr :: 4;
    GenericDstKhr :: 8;
}

MemoryAllocateFlagBits :: enum_flags u32 {
    DeviceMask :: 1;
    DeviceAddress :: 2;
    DeviceAddressCaptureReplay :: 4;
    DeviceMaskKhr :: 1;
    DeviceAddressKhr :: 2;
    DeviceAddressCaptureReplayKhr :: 4;
}

ExternalMemoryHandleTypeFlagBits :: enum_flags u32 {
    OpaqueFd :: 1;
    OpaqueWin32 :: 2;
    OpaqueWin32Kmt :: 4;
    D3D11Texture :: 8;
    D3D11TextureKmt :: 16;
    D3D12Heap :: 32;
    D3D12Resource :: 64;
    DmaBufExt :: 512;
    AndroidHardwareBufferBitAndroid :: 1024;
    HostAllocationExt :: 128;
    HostMappedForeignMemoryExt :: 256;
    OpaqueFdKhr :: 1;
    OpaqueWin32Khr :: 2;
    OpaqueWin32KmtKhr :: 4;
    D3D11TextureKhr :: 8;
    D3D11TextureKmtKhr :: 16;
    D3D12HeapKhr :: 32;
    D3D12ResourceKhr :: 64;
}

ExternalMemoryFeatureFlagBits :: enum_flags u32 {
    DedicatedOnly :: 1;
    Exportable :: 2;
    Importable :: 4;
    DedicatedOnlyKhr :: 1;
    ExportableKhr :: 2;
    ImportableKhr :: 4;
}

ExternalFenceHandleTypeFlagBits :: enum_flags u32 {
    OpaqueFd :: 1;
    OpaqueWin32 :: 2;
    OpaqueWin32Kmt :: 4;
    SyncFd :: 8;
    OpaqueFdKhr :: 1;
    OpaqueWin32Khr :: 2;
    OpaqueWin32KmtKhr :: 4;
    SyncFdKhr :: 8;
}

ExternalFenceFeatureFlagBits :: enum_flags u32 {
    Exportable :: 1;
    Importable :: 2;
    ExportableKhr :: 1;
    ImportableKhr :: 2;
}

FenceImportFlagBits :: enum_flags u32 {
    Temporary :: 1;
    TemporaryKhr :: 1;
}

SemaphoreImportFlagBits :: enum_flags u32 {
    Temporary :: 1;
    TemporaryKhr :: 1;
}

ExternalSemaphoreHandleTypeFlagBits :: enum_flags u32 {
    OpaqueFd :: 1;
    OpaqueWin32 :: 2;
    OpaqueWin32Kmt :: 4;
    D3D12Fence :: 8;
    SyncFd :: 16;
    D3D11Fence :: 8;
    OpaqueFdKhr :: 1;
    OpaqueWin32Khr :: 2;
    OpaqueWin32KmtKhr :: 4;
    D3D12FenceKhr :: 8;
    SyncFdKhr :: 16;
}

ExternalSemaphoreFeatureFlagBits :: enum_flags u32 {
    Exportable :: 1;
    Importable :: 2;
    ExportableKhr :: 1;
    ImportableKhr :: 2;
}

DriverId :: enum s32 {
    AmdProprietary :: 1;
    AmdOpenSource :: 2;
    MesaRadv :: 3;
    NvidiaProprietary :: 4;
    IntelProprietaryWindows :: 5;
    IntelOpenSourceMesa :: 6;
    ImaginationProprietary :: 7;
    QualcommProprietary :: 8;
    ArmProprietary :: 9;
    GoogleSwiftshader :: 10;
    GgpProprietary :: 11;
    BroadcomProprietary :: 12;
    MesaLlvmpipe :: 13;
    Moltenvk :: 14;
    AmdProprietaryKhr :: 1;
    AmdOpenSourceKhr :: 2;
    MesaRadvKhr :: 3;
    NvidiaProprietaryKhr :: 4;
    IntelProprietaryWindowsKhr :: 5;
    IntelOpenSourceMesaKhr :: 6;
    ImaginationProprietaryKhr :: 7;
    QualcommProprietaryKhr :: 8;
    ArmProprietaryKhr :: 9;
    GoogleSwiftshaderKhr :: 10;
    GgpProprietaryKhr :: 11;
    BroadcomProprietaryKhr :: 12;
}

ShaderFloatControlsIndependence :: enum s32 {
    _32BitOnly :: 0;
    All :: 1;
    None :: 2;
    _32BitOnlyKhr :: 0;
    AllKhr :: 1;
    NoneKhr :: 2;
}

SamplerReductionMode :: enum s32 {
    WeightedAverage :: 0;
    Min :: 1;
    Max :: 2;
    WeightedAverageExt :: 0;
    MinExt :: 1;
    MaxExt :: 2;
}

SemaphoreType :: enum s32 {
    Binary :: 0;
    Timeline :: 1;
    BinaryKhr :: 0;
    TimelineKhr :: 1;
}

ResolveModeFlagBits :: enum_flags u32 {
    None :: 0;
    SampleZero :: 1;
    Average :: 2;
    Min :: 4;
    Max :: 8;
    NoneKhr :: 0;
    SampleZeroKhr :: 1;
    AverageKhr :: 2;
    MinKhr :: 4;
    MaxKhr :: 8;
}

DescriptorBindingFlagBits :: enum_flags u32 {
    UpdateAfterBind :: 1;
    UpdateUnusedWhilePending :: 2;
    PartiallyBound :: 4;
    VariableDescriptorCount :: 8;
    UpdateAfterBindExt :: 1;
    UpdateUnusedWhilePendingExt :: 2;
    PartiallyBoundExt :: 4;
    VariableDescriptorCountExt :: 8;
}

SemaphoreWaitFlagBits :: enum_flags u32 {
    _Any :: 1;
    AnyKhr :: 1;
}

PresentModeKHR :: enum s32 {
    Immediate :: 0;
    Mailbox :: 1;
    Fifo :: 2;
    FifoRelaxed :: 3;
    SharedDemandRefresh :: 1000111000;
    SharedContinuousRefresh :: 1000111001;
}

ColorSpaceKHR :: enum s32 {
    SrgbNonlinear :: 0;
    DisplayP3NonlinearExt :: 1000104001;
    ExtendedSrgbLinearExt :: 1000104002;
    DisplayP3LinearExt :: 1000104003;
    DciP3NonlinearExt :: 1000104004;
    Bt709LinearExt :: 1000104005;
    Bt709NonlinearExt :: 1000104006;
    Bt2020LinearExt :: 1000104007;
    Hdr10St2084Ext :: 1000104008;
    DolbyvisionExt :: 1000104009;
    Hdr10HlgExt :: 1000104010;
    AdobergbLinearExt :: 1000104011;
    AdobergbNonlinearExt :: 1000104012;
    PassThroughExt :: 1000104013;
    ExtendedSrgbNonlinearExt :: 1000104014;
    DisplayNativeAmd :: 1000213000;
    ColorspaceSrgbNonlinear :: 0;
    DciP3LinearExt :: 1000104003;
}

SurfaceTransformFlagBitsKHR :: enum_flags u32 {
    Identity :: 1;
    Rotate90 :: 2;
    Rotate180 :: 4;
    Rotate270 :: 8;
    HorizontalMirror :: 16;
    HorizontalMirrorRotate90 :: 32;
    HorizontalMirrorRotate180 :: 64;
    HorizontalMirrorRotate270 :: 128;
    Inherit :: 256;
}

CompositeAlphaFlagBitsKHR :: enum_flags u32 {
    Opaque :: 1;
    PreMultiplied :: 2;
    PostMultiplied :: 4;
    Inherit :: 8;
}

SwapchainCreateFlagBitsKHR :: enum_flags u32 {
    SplitInstanceBindRegions :: 1;
    Protected :: 2;
    MutableFormat :: 4;
}

DeviceGroupPresentModeFlagBitsKHR :: enum_flags u32 {
    Local :: 1;
    Remote :: 2;
    Sum :: 4;
    LocalMultiDevice :: 8;
}

DisplayPlaneAlphaFlagBitsKHR :: enum_flags u32 {
    Opaque :: 1;
    Global :: 2;
    PerPixel :: 4;
    PerPixelPremultiplied :: 8;
}

PerformanceCounterUnitKHR :: enum s32 {
    Generic :: 0;
    Percentage :: 1;
    Nanoseconds :: 2;
    Bytes :: 3;
    BytesPerSecond :: 4;
    Kelvin :: 5;
    Watts :: 6;
    Volts :: 7;
    Amps :: 8;
    Hertz :: 9;
    Cycles :: 10;
}

PerformanceCounterScopeKHR :: enum s32 {
    CommandBuffer :: 0;
    RenderPass :: 1;
    Command :: 2;
    QueryScopeCommandBuffer :: 0;
    QueryScopeRenderPass :: 1;
    QueryScopeCommand :: 2;
}

PerformanceCounterStorageKHR :: enum s32 {
    Int32 :: 0;
    Int64 :: 1;
    Uint32 :: 2;
    Uint64 :: 3;
    Float32 :: 4;
    Float64 :: 5;
}

PerformanceCounterDescriptionFlagBitsKHR :: enum_flags u32 {
    PerformanceImpacting :: 1;
    ConcurrentlyImpacted :: 2;
}

AcquireProfilingLockFlagBitsKHR :: enum_flags u32 {
}

FragmentShadingRateCombinerOpKHR :: enum s32 {
    Keep :: 0;
    Replace :: 1;
    Min :: 2;
    Max :: 3;
    Mul :: 4;
}

PipelineExecutableStatisticFormatKHR :: enum s32 {
    Bool32 :: 0;
    Int64 :: 1;
    Uint64 :: 2;
    Float64 :: 3;
}

DebugReportObjectTypeEXT :: enum s32 {
    Unknown :: 0;
    Instance :: 1;
    PhysicalDevice :: 2;
    Device :: 3;
    Queue :: 4;
    Semaphore :: 5;
    CommandBuffer :: 6;
    Fence :: 7;
    DeviceMemory :: 8;
    Buffer :: 9;
    Image :: 10;
    Event :: 11;
    QueryPool :: 12;
    BufferView :: 13;
    ImageView :: 14;
    ShaderModule :: 15;
    PipelineCache :: 16;
    PipelineLayout :: 17;
    RenderPass :: 18;
    Pipeline :: 19;
    DescriptorSetLayout :: 20;
    Sampler :: 21;
    DescriptorPool :: 22;
    DescriptorSet :: 23;
    Framebuffer :: 24;
    CommandPool :: 25;
    SurfaceKhr :: 26;
    SwapchainKhr :: 27;
    DebugReportCallback :: 28;
    DisplayKhr :: 29;
    DisplayModeKhr :: 30;
    ValidationCache :: 33;
    SamplerYcbcrConversion :: 1000156000;
    DescriptorUpdateTemplate :: 1000085000;
    AccelerationStructureKhr :: 1000150000;
    AccelerationStructureNv :: 1000165000;
    DebugReport :: 28;
    DescriptorUpdateTemplateKhr :: 1000085000;
    SamplerYcbcrConversionKhr :: 1000156000;
}

DebugReportFlagBitsEXT :: enum_flags u32 {
    Information :: 1;
    Warning :: 2;
    PerformanceWarning :: 4;
    Error :: 8;
    Debug :: 16;
}

RasterizationOrderAMD :: enum s32 {
    Strict :: 0;
    Relaxed :: 1;
}

ShaderInfoTypeAMD :: enum s32 {
    Statistics :: 0;
    Binary :: 1;
    Disassembly :: 2;
}

ExternalMemoryHandleTypeFlagBitsNV :: enum_flags u32 {
    OpaqueWin32 :: 1;
    OpaqueWin32Kmt :: 2;
    D3D11Image :: 4;
    D3D11ImageKmt :: 8;
}

ExternalMemoryFeatureFlagBitsNV :: enum_flags u32 {
    DedicatedOnly :: 1;
    Exportable :: 2;
    Importable :: 4;
}

ValidationCheckEXT :: enum s32 {
    All :: 0;
    Shaders :: 1;
}

ConditionalRenderingFlagBitsEXT :: enum_flags u32 {
    Inverted :: 1;
}

SurfaceCounterFlagBitsEXT :: enum_flags u32 {
    Vblank :: 1;
}

DisplayPowerStateEXT :: enum s32 {
    Off :: 0;
    Suspend :: 1;
    On :: 2;
}

DeviceEventTypeEXT :: enum s32 {
    DisplayHotplug :: 0;
}

DisplayEventTypeEXT :: enum s32 {
    FirstPixelOut :: 0;
}

ViewportCoordinateSwizzleNV :: enum s32 {
    PositiveX :: 0;
    NegativeX :: 1;
    PositiveY :: 2;
    NegativeY :: 3;
    PositiveZ :: 4;
    NegativeZ :: 5;
    PositiveW :: 6;
    NegativeW :: 7;
}

DiscardRectangleModeEXT :: enum s32 {
    Inclusive :: 0;
    Exclusive :: 1;
}

ConservativeRasterizationModeEXT :: enum s32 {
    Disabled :: 0;
    Overestimate :: 1;
    Underestimate :: 2;
}

DebugUtilsMessageSeverityFlagBitsEXT :: enum_flags u32 {
    Verbose :: 1;
    Info :: 16;
    Warning :: 256;
    Error :: 4096;
}

DebugUtilsMessageTypeFlagBitsEXT :: enum_flags u32 {
    General :: 1;
    Validation :: 2;
    Performance :: 4;
}

BlendOverlapEXT :: enum s32 {
    Uncorrelated :: 0;
    Disjoint :: 1;
    Conjoint :: 2;
}

CoverageModulationModeNV :: enum s32 {
    None :: 0;
    Rgb :: 1;
    Alpha :: 2;
    Rgba :: 3;
}

ValidationCacheHeaderVersionEXT :: enum s32 {
    One :: 1;
}

ShadingRatePaletteEntryNV :: enum s32 {
    NoInvocations :: 0;
    _16InvocationsPerPixel :: 1;
    _8_invocationsPerPixel :: 2;
    _4_invocationsPerPixel :: 3;
    _2_invocationsPerPixel :: 4;
    _1_invocationPerPixel :: 5;
    _1_invocationPer2X1Pixels :: 6;
    _1_invocationPer1X2Pixels :: 7;
    _1_invocationPer2X2Pixels :: 8;
    _1_invocationPer4X2Pixels :: 9;
    _1_invocationPer2X4Pixels :: 10;
    _1_invocationPer4X4Pixels :: 11;
}

CoarseSampleOrderTypeNV :: enum s32 {
    Default :: 0;
    Custom :: 1;
    PixelMajor :: 2;
    SampleMajor :: 3;
}

RayTracingShaderGroupTypeKHR :: enum s32 {
    General :: 0;
    TrianglesHitGroup :: 1;
    ProceduralHitGroup :: 2;
    GeneralNv :: 0;
    TrianglesHitGroupNv :: 1;
    ProceduralHitGroupNv :: 2;
}

GeometryTypeKHR :: enum s32 {
    Triangles :: 0;
    Aabbs :: 1;
    Instances :: 2;
    TrianglesNv :: 0;
    AabbsNv :: 1;
}

AccelerationStructureTypeKHR :: enum s32 {
    TopLevel :: 0;
    BottomLevel :: 1;
    Generic :: 2;
    TopLevelNv :: 0;
    BottomLevelNv :: 1;
}

CopyAccelerationStructureModeKHR :: enum s32 {
    Clone :: 0;
    Compact :: 1;
    Serialize :: 2;
    Deserialize :: 3;
    CloneNv :: 0;
    CompactNv :: 1;
}

AccelerationStructureMemoryRequirementsTypeNV :: enum s32 {
    Object :: 0;
    BuildScratch :: 1;
    UpdateScratch :: 2;
}

GeometryFlagBitsKHR :: enum_flags u32 {
    Opaque :: 1;
    NoDuplicateAnyHitInvocation :: 2;
    OpaqueNv :: 1;
    NoDuplicateAnyHitInvocationNv :: 2;
}

GeometryInstanceFlagBitsKHR :: enum_flags u32 {
    TriangleFacingCullDisable :: 1;
    TriangleFrontCounterclockwise :: 2;
    ForceOpaque :: 4;
    ForceNoOpaque :: 8;
    TriangleCullDisableNv :: 1;
    TriangleFrontCounterclockwiseNv :: 2;
    ForceOpaqueNv :: 4;
    ForceNoOpaqueNv :: 8;
}

BuildAccelerationStructureFlagBitsKHR :: enum_flags u32 {
    AllowUpdate :: 1;
    AllowCompaction :: 2;
    PreferFastTrace :: 4;
    PreferFastBuild :: 8;
    LowMemory :: 16;
    AllowUpdateNv :: 1;
    AllowCompactionNv :: 2;
    PreferFastTraceNv :: 4;
    PreferFastBuildNv :: 8;
    LowMemoryNv :: 16;
}

QueueGlobalPriorityEXT :: enum s32 {
    Low :: 128;
    Medium :: 256;
    High :: 512;
    Realtime :: 1024;
}

PipelineCompilerControlFlagBitsAMD :: enum_flags u32 {
}

TimeDomainEXT :: enum s32 {
    Device :: 0;
    ClockMonotonic :: 1;
    ClockMonotonicRaw :: 2;
    QueryPerformanceCounter :: 3;
}

MemoryOverallocationBehaviorAMD :: enum s32 {
    Default :: 0;
    Allowed :: 1;
    Disallowed :: 2;
}

PipelineCreationFeedbackFlagBitsEXT :: enum_flags u32 {
    Valid :: 1;
    ApplicationPipelineCacheHit :: 2;
    BasePipelineAcceleration :: 4;
}

PerformanceConfigurationTypeINTEL :: enum s32 {
    PerformanceConfigurationTypeCommandQueueMetricsDiscoveryActivatedIntel :: 0;
    PerformanceConfigurationTypeMaxEnumIntel :: 2147483647;
}

QueryPoolSamplingModeINTEL :: enum s32 {
    QueryPoolSamplingModeManualIntel :: 0;
    QueryPoolSamplingModeMaxEnumIntel :: 2147483647;
}

PerformanceOverrideTypeINTEL :: enum s32 {
    PerformanceOverrideTypeNullHardwareIntel :: 0;
    PerformanceOverrideTypeFlushGpuCachesIntel :: 1;
    PerformanceOverrideTypeMaxEnumIntel :: 2147483647;
}

PerformanceParameterTypeINTEL :: enum s32 {
    PerformanceParameterTypeHwCountersSupportedIntel :: 0;
    PerformanceParameterTypeStreamMarkerValidBitsIntel :: 1;
    PerformanceParameterTypeMaxEnumIntel :: 2147483647;
}

PerformanceValueTypeINTEL :: enum s32 {
    PerformanceValueTypeUint32Intel :: 0;
    PerformanceValueTypeUint64Intel :: 1;
    PerformanceValueTypeFloatIntel :: 2;
    PerformanceValueTypeBoolIntel :: 3;
    PerformanceValueTypeStringIntel :: 4;
    PerformanceValueTypeMaxEnumIntel :: 2147483647;
}

ShaderCorePropertiesFlagBitsAMD :: enum_flags u32 {
}

ToolPurposeFlagBitsEXT :: enum_flags u32 {
    Validation :: 1;
    Profiling :: 2;
    Tracing :: 4;
    AdditionalFeatures :: 8;
    ModifyingFeatures :: 16;
    DebugReporting :: 32;
    DebugMarkers :: 64;
}

ValidationFeatureEnableEXT :: enum s32 {
    GpuAssisted :: 0;
    GpuAssistedReserveBindingSlot :: 1;
    BestPractices :: 2;
    DebugPrintf :: 3;
    SynchronizationValidation :: 4;
}

ValidationFeatureDisableEXT :: enum s32 {
    All :: 0;
    Shaders :: 1;
    ThreadSafety :: 2;
    ApiParameters :: 3;
    ObjectLifetimes :: 4;
    CoreChecks :: 5;
    UniqueHandles :: 6;
}

ComponentTypeNV :: enum s32 {
    Float16 :: 0;
    Float32 :: 1;
    Float64 :: 2;
    Sint8 :: 3;
    Sint16 :: 4;
    Sint32 :: 5;
    Sint64 :: 6;
    Uint8 :: 7;
    Uint16 :: 8;
    Uint32 :: 9;
    Uint64 :: 10;
}

ScopeNV :: enum s32 {
    Device :: 1;
    Workgroup :: 2;
    Subgroup :: 3;
    QueueFamily :: 5;
}

CoverageReductionModeNV :: enum s32 {
    Merge :: 0;
    Truncate :: 1;
}

LineRasterizationModeEXT :: enum s32 {
    Default :: 0;
    Rectangular :: 1;
    Bresenham :: 2;
    RectangularSmooth :: 3;
}

IndirectCommandsTokenTypeNV :: enum s32 {
    ShaderGroup :: 0;
    StateFlags :: 1;
    IndexBuffer :: 2;
    VertexBuffer :: 3;
    PushConstant :: 4;
    DrawIndexed :: 5;
    Draw :: 6;
    DrawTasks :: 7;
}

IndirectStateFlagBitsNV :: enum_flags u32 {
    FlagFrontface :: 1;
}

IndirectCommandsLayoutUsageFlagBitsNV :: enum_flags u32 {
    ExplicitPreprocess :: 1;
    IndexedSequences :: 2;
    UnorderedSequences :: 4;
}

DeviceMemoryReportEventTypeEXT :: enum s32 {
    Allocate :: 0;
    Free :: 1;
    Import :: 2;
    Unimport :: 3;
    AllocationFailed :: 4;
}

PrivateDataSlotCreateFlagBitsEXT :: enum_flags u32 {
}

DeviceDiagnosticsConfigFlagBitsNV :: enum_flags u32 {
    EnableShaderDebugInfo :: 1;
    EnableResourceTracking :: 2;
    EnableAutomaticCheckpoints :: 4;
}

FragmentShadingRateTypeNV :: enum s32 {
    FragmentSize :: 0;
    Enums :: 1;
}

FragmentShadingRateNV :: enum s32 {
    _1_invocationPerPixel :: 0;
    _1_invocationPer1X2Pixels :: 1;
    _1_invocationPer2X1Pixels :: 4;
    _1_invocationPer2X2Pixels :: 5;
    _1_invocationPer2X4Pixels :: 6;
    _1_invocationPer4X2Pixels :: 9;
    _1_invocationPer4X4Pixels :: 10;
    _2_invocationsPerPixel :: 11;
    _4_invocationsPerPixel :: 12;
    _8_invocationsPerPixel :: 13;
    _16InvocationsPerPixel :: 14;
    NoInvocations :: 15;
}

BuildAccelerationStructureModeKHR :: enum s32 {
    Build :: 0;
    Update :: 1;
}

AccelerationStructureBuildTypeKHR :: enum s32 {
    Host :: 0;
    Device :: 1;
    HostOrDevice :: 2;
}

AccelerationStructureCompatibilityKHR :: enum s32 {
    Compatible :: 0;
    Incompatible :: 1;
}

AccelerationStructureCreateFlagBitsKHR :: enum_flags u32 {
    DeviceAddressCaptureReplay :: 1;
}

ShaderGroupShaderKHR :: enum s32 {
    General :: 0;
    ClosestHit :: 1;
    AnyHit :: 2;
    Intersection :: 3;
}

BufferT :: struct {}

ImageT :: struct {}

InstanceT :: struct {}

PhysicalDeviceT :: struct {}

DeviceT :: struct {}

QueueT :: struct {}

SemaphoreT :: struct {}

CommandBufferT :: struct {}

FenceT :: struct {}

DeviceMemoryT :: struct {}

EventT :: struct {}

QueryPoolT :: struct {}

BufferViewT :: struct {}

ImageViewT :: struct {}

ShaderModuleT :: struct {}

PipelineCacheT :: struct {}

PipelineLayoutT :: struct {}

PipelineT :: struct {}

RenderPassT :: struct {}

DescriptorSetLayoutT :: struct {}

SamplerT :: struct {}

DescriptorSetT :: struct {}

DescriptorPoolT :: struct {}

FramebufferT :: struct {}

CommandPoolT :: struct {}

Extent2D :: struct {
    width : u32;
    height : u32;
}

Extent3D :: struct {
    width : u32;
    height : u32;
    depth : u32;
}

Offset2D :: struct {
    x : s32;
    y : s32;
}

Offset3D :: struct {
    x : s32;
    y : s32;
    z : s32;
}

Rect2D :: struct {
    offset : Offset2D;
    extent : Extent2D;
}

BaseInStructure :: struct {
    sType : StructureType;
    pNext : *BaseInStructure;
}

BaseOutStructure :: struct {
    sType : StructureType;
    pNext : *BaseOutStructure;
}

BufferMemoryBarrier :: struct {
    sType : StructureType;
    pNext : *void;
    srcAccessMask : AccessFlags;
    dstAccessMask : AccessFlags;
    srcQueueFamilyIndex : u32;
    dstQueueFamilyIndex : u32;
    buffer : Buffer;
    offset : DeviceSize;
    size : DeviceSize;
}

DispatchIndirectCommand :: struct {
    x : u32;
    y : u32;
    z : u32;
}

DrawIndexedIndirectCommand :: struct {
    indexCount : u32;
    instanceCount : u32;
    firstIndex : u32;
    vertexOffset : s32;
    firstInstance : u32;
}

DrawIndirectCommand :: struct {
    vertexCount : u32;
    instanceCount : u32;
    firstVertex : u32;
    firstInstance : u32;
}

ImageSubresourceRange :: struct {
    aspectMask : ImageAspectFlags;
    baseMipLevel : u32;
    levelCount : u32;
    baseArrayLayer : u32;
    layerCount : u32;
}

ImageMemoryBarrier :: struct {
    sType : StructureType;
    pNext : *void;
    srcAccessMask : AccessFlags;
    dstAccessMask : AccessFlags;
    oldLayout : ImageLayout;
    newLayout : ImageLayout;
    srcQueueFamilyIndex : u32;
    dstQueueFamilyIndex : u32;
    image : Image;
    subresourceRange : ImageSubresourceRange;
}

MemoryBarrier :: struct {
    sType : StructureType;
    pNext : *void;
    srcAccessMask : AccessFlags;
    dstAccessMask : AccessFlags;
}

AllocationCallbacks :: struct {
    pUserData : *void;
    pfnAllocation : PFN_AllocationFunction;
    pfnReallocation : PFN_ReallocationFunction;
    pfnFree : PFN_FreeFunction;
    pfnInternalAllocation : PFN_InternalAllocationNotification;
    pfnInternalFree : PFN_InternalFreeNotification;
}

ApplicationInfo :: struct {
    sType : StructureType;
    pNext : *void;
    pApplicationName : *u8;
    applicationVersion : u32;
    pEngineName : *u8;
    engineVersion : u32;
    apiVersion : u32;
}

FormatProperties :: struct {
    linearTilingFeatures : FormatFeatureFlags;
    optimalTilingFeatures : FormatFeatureFlags;
    bufferFeatures : FormatFeatureFlags;
}

ImageFormatProperties :: struct {
    maxExtent : Extent3D;
    maxMipLevels : u32;
    maxArrayLayers : u32;
    sampleCounts : SampleCountFlags;
    maxResourceSize : DeviceSize;
}

InstanceCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : InstanceCreateFlags;
    pApplicationInfo : *ApplicationInfo;
    enabledLayerCount : u32;
    ppEnabledLayerNames : **u8;
    enabledExtensionCount : u32;
    ppEnabledExtensionNames : **u8;
}

MemoryHeap :: struct {
    size : DeviceSize;
    flags : MemoryHeapFlags;
}

MemoryType :: struct {
    propertyFlags : MemoryPropertyFlags;
    heapIndex : u32;
}

PhysicalDeviceFeatures :: struct {
    robustBufferAccess : Bool32;
    fullDrawIndexUint32 : Bool32;
    imageCubeArray : Bool32;
    independentBlend : Bool32;
    geometryShader : Bool32;
    tessellationShader : Bool32;
    sampleRateShading : Bool32;
    dualSrcBlend : Bool32;
    logicOp : Bool32;
    multiDrawIndirect : Bool32;
    drawIndirectFirstInstance : Bool32;
    depthClamp : Bool32;
    depthBiasClamp : Bool32;
    fillModeNonSolid : Bool32;
    depthBounds : Bool32;
    wideLines : Bool32;
    largePoints : Bool32;
    alphaToOne : Bool32;
    multiViewport : Bool32;
    samplerAnisotropy : Bool32;
    textureCompressionETC2 : Bool32;
    textureCompressionASTC_LDR : Bool32;
    textureCompressionBC : Bool32;
    occlusionQueryPrecise : Bool32;
    pipelineStatisticsQuery : Bool32;
    vertexPipelineStoresAndAtomics : Bool32;
    fragmentStoresAndAtomics : Bool32;
    shaderTessellationAndGeometryPointSize : Bool32;
    shaderImageGatherExtended : Bool32;
    shaderStorageImageExtendedFormats : Bool32;
    shaderStorageImageMultisample : Bool32;
    shaderStorageImageReadWithoutFormat : Bool32;
    shaderStorageImageWriteWithoutFormat : Bool32;
    shaderUniformBufferArrayDynamicIndexing : Bool32;
    shaderSampledImageArrayDynamicIndexing : Bool32;
    shaderStorageBufferArrayDynamicIndexing : Bool32;
    shaderStorageImageArrayDynamicIndexing : Bool32;
    shaderClipDistance : Bool32;
    shaderCullDistance : Bool32;
    shaderFloat64 : Bool32;
    shaderInt64 : Bool32;
    shaderInt16 : Bool32;
    shaderResourceResidency : Bool32;
    shaderResourceMinLod : Bool32;
    sparseBinding : Bool32;
    sparseResidencyBuffer : Bool32;
    sparseResidencyImage2D : Bool32;
    sparseResidencyImage3D : Bool32;
    sparseResidency2Samples : Bool32;
    sparseResidency4Samples : Bool32;
    sparseResidency8Samples : Bool32;
    sparseResidency16Samples : Bool32;
    sparseResidencyAliased : Bool32;
    variableMultisampleRate : Bool32;
    inheritedQueries : Bool32;
}

PhysicalDeviceLimits :: struct {
    maxImageDimension1D : u32;
    maxImageDimension2D : u32;
    maxImageDimension3D : u32;
    maxImageDimensionCube : u32;
    maxImageArrayLayers : u32;
    maxTexelBufferElements : u32;
    maxUniformBufferRange : u32;
    maxStorageBufferRange : u32;
    maxPushConstantsSize : u32;
    maxMemoryAllocationCount : u32;
    maxSamplerAllocationCount : u32;
    bufferImageGranularity : DeviceSize;
    sparseAddressSpaceSize : DeviceSize;
    maxBoundDescriptorSets : u32;
    maxPerStageDescriptorSamplers : u32;
    maxPerStageDescriptorUniformBuffers : u32;
    maxPerStageDescriptorStorageBuffers : u32;
    maxPerStageDescriptorSampledImages : u32;
    maxPerStageDescriptorStorageImages : u32;
    maxPerStageDescriptorInputAttachments : u32;
    maxPerStageResources : u32;
    maxDescriptorSetSamplers : u32;
    maxDescriptorSetUniformBuffers : u32;
    maxDescriptorSetUniformBuffersDynamic : u32;
    maxDescriptorSetStorageBuffers : u32;
    maxDescriptorSetStorageBuffersDynamic : u32;
    maxDescriptorSetSampledImages : u32;
    maxDescriptorSetStorageImages : u32;
    maxDescriptorSetInputAttachments : u32;
    maxVertexInputAttributes : u32;
    maxVertexInputBindings : u32;
    maxVertexInputAttributeOffset : u32;
    maxVertexInputBindingStride : u32;
    maxVertexOutputComponents : u32;
    maxTessellationGenerationLevel : u32;
    maxTessellationPatchSize : u32;
    maxTessellationControlPerVertexInputComponents : u32;
    maxTessellationControlPerVertexOutputComponents : u32;
    maxTessellationControlPerPatchOutputComponents : u32;
    maxTessellationControlTotalOutputComponents : u32;
    maxTessellationEvaluationInputComponents : u32;
    maxTessellationEvaluationOutputComponents : u32;
    maxGeometryShaderInvocations : u32;
    maxGeometryInputComponents : u32;
    maxGeometryOutputComponents : u32;
    maxGeometryOutputVertices : u32;
    maxGeometryTotalOutputComponents : u32;
    maxFragmentInputComponents : u32;
    maxFragmentOutputAttachments : u32;
    maxFragmentDualSrcAttachments : u32;
    maxFragmentCombinedOutputResources : u32;
    maxComputeSharedMemorySize : u32;
    maxComputeWorkGroupCount : [3]u32;
    maxComputeWorkGroupInvocations : u32;
    maxComputeWorkGroupSize : [3]u32;
    subPixelPrecisionBits : u32;
    subTexelPrecisionBits : u32;
    mipmapPrecisionBits : u32;
    maxDrawIndexedIndexValue : u32;
    maxDrawIndirectCount : u32;
    maxSamplerLodBias : float32;
    maxSamplerAnisotropy : float32;
    maxViewports : u32;
    maxViewportDimensions : [2]u32;
    viewportBoundsRange : [2]float32;
    viewportSubPixelBits : u32;
    minMemoryMapAlignment : u64;
    minTexelBufferOffsetAlignment : DeviceSize;
    minUniformBufferOffsetAlignment : DeviceSize;
    minStorageBufferOffsetAlignment : DeviceSize;
    minTexelOffset : s32;
    maxTexelOffset : u32;
    minTexelGatherOffset : s32;
    maxTexelGatherOffset : u32;
    minInterpolationOffset : float32;
    maxInterpolationOffset : float32;
    subPixelInterpolationOffsetBits : u32;
    maxFramebufferWidth : u32;
    maxFramebufferHeight : u32;
    maxFramebufferLayers : u32;
    framebufferColorSampleCounts : SampleCountFlags;
    framebufferDepthSampleCounts : SampleCountFlags;
    framebufferStencilSampleCounts : SampleCountFlags;
    framebufferNoAttachmentsSampleCounts : SampleCountFlags;
    maxColorAttachments : u32;
    sampledImageColorSampleCounts : SampleCountFlags;
    sampledImageIntegerSampleCounts : SampleCountFlags;
    sampledImageDepthSampleCounts : SampleCountFlags;
    sampledImageStencilSampleCounts : SampleCountFlags;
    storageImageSampleCounts : SampleCountFlags;
    maxSampleMaskWords : u32;
    timestampComputeAndGraphics : Bool32;
    timestampPeriod : float32;
    maxClipDistances : u32;
    maxCullDistances : u32;
    maxCombinedClipAndCullDistances : u32;
    discreteQueuePriorities : u32;
    pointSizeRange : [2]float32;
    lineWidthRange : [2]float32;
    pointSizeGranularity : float32;
    lineWidthGranularity : float32;
    strictLines : Bool32;
    standardSampleLocations : Bool32;
    optimalBufferCopyOffsetAlignment : DeviceSize;
    optimalBufferCopyRowPitchAlignment : DeviceSize;
    nonCoherentAtomSize : DeviceSize;
}

PhysicalDeviceMemoryProperties :: struct {
    memoryTypeCount : u32;
    memoryTypes : [32]MemoryType;
    memoryHeapCount : u32;
    memoryHeaps : [16]MemoryHeap;
}

PhysicalDeviceSparseProperties :: struct {
    residencyStandard2DBlockShape : Bool32;
    residencyStandard2DMultisampleBlockShape : Bool32;
    residencyStandard3DBlockShape : Bool32;
    residencyAlignedMipSize : Bool32;
    residencyNonResidentStrict : Bool32;
}

PhysicalDeviceProperties :: struct {
    apiVersion : u32;
    driverVersion : u32;
    vendorID : u32;
    deviceID : u32;
    deviceType : PhysicalDeviceType;
    deviceName : [256]u8;
    pipelineCacheUUID : [16]u8;
    limits : PhysicalDeviceLimits;
    sparseProperties : PhysicalDeviceSparseProperties;
}

QueueFamilyProperties :: struct {
    queueFlags : QueueFlags;
    queueCount : u32;
    timestampValidBits : u32;
    minImageTransferGranularity : Extent3D;
}

DeviceQueueCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : DeviceQueueCreateFlags;
    queueFamilyIndex : u32;
    queueCount : u32;
    pQueuePriorities : *float32;
}

DeviceCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : DeviceCreateFlags;
    queueCreateInfoCount : u32;
    pQueueCreateInfos : *DeviceQueueCreateInfo;
    enabledLayerCount : u32;
    ppEnabledLayerNames : **u8;
    enabledExtensionCount : u32;
    ppEnabledExtensionNames : **u8;
    pEnabledFeatures : *PhysicalDeviceFeatures;
}

ExtensionProperties :: struct {
    extensionName : [256]u8;
    specVersion : u32;
}

LayerProperties :: struct {
    layerName : [256]u8;
    specVersion : u32;
    implementationVersion : u32;
    description : [256]u8;
}

SubmitInfo :: struct {
    sType : StructureType;
    pNext : *void;
    waitSemaphoreCount : u32;
    pWaitSemaphores : *Semaphore;
    pWaitDstStageMask : *PipelineStageFlags;
    commandBufferCount : u32;
    pCommandBuffers : *CommandBuffer;
    signalSemaphoreCount : u32;
    pSignalSemaphores : *Semaphore;
}

MappedMemoryRange :: struct {
    sType : StructureType;
    pNext : *void;
    memory : DeviceMemory;
    offset : DeviceSize;
    size : DeviceSize;
}

MemoryAllocateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    allocationSize : DeviceSize;
    memoryTypeIndex : u32;
}

MemoryRequirements :: struct {
    size : DeviceSize;
    alignment : DeviceSize;
    memoryTypeBits : u32;
}

SparseMemoryBind :: struct {
    resourceOffset : DeviceSize;
    size : DeviceSize;
    memory : DeviceMemory;
    memoryOffset : DeviceSize;
    flags : SparseMemoryBindFlags;
}

SparseBufferMemoryBindInfo :: struct {
    buffer : Buffer;
    bindCount : u32;
    pBinds : *SparseMemoryBind;
}

SparseImageOpaqueMemoryBindInfo :: struct {
    image : Image;
    bindCount : u32;
    pBinds : *SparseMemoryBind;
}

ImageSubresource :: struct {
    aspectMask : ImageAspectFlags;
    mipLevel : u32;
    arrayLayer : u32;
}

SparseImageMemoryBind :: struct {
    subresource : ImageSubresource;
    offset : Offset3D;
    extent : Extent3D;
    memory : DeviceMemory;
    memoryOffset : DeviceSize;
    flags : SparseMemoryBindFlags;
}

SparseImageMemoryBindInfo :: struct {
    image : Image;
    bindCount : u32;
    pBinds : *SparseImageMemoryBind;
}

BindSparseInfo :: struct {
    sType : StructureType;
    pNext : *void;
    waitSemaphoreCount : u32;
    pWaitSemaphores : *Semaphore;
    bufferBindCount : u32;
    pBufferBinds : *SparseBufferMemoryBindInfo;
    imageOpaqueBindCount : u32;
    pImageOpaqueBinds : *SparseImageOpaqueMemoryBindInfo;
    imageBindCount : u32;
    pImageBinds : *SparseImageMemoryBindInfo;
    signalSemaphoreCount : u32;
    pSignalSemaphores : *Semaphore;
}

SparseImageFormatProperties :: struct {
    aspectMask : ImageAspectFlags;
    imageGranularity : Extent3D;
    flags : SparseImageFormatFlags;
}

SparseImageMemoryRequirements :: struct {
    formatProperties : SparseImageFormatProperties;
    imageMipTailFirstLod : u32;
    imageMipTailSize : DeviceSize;
    imageMipTailOffset : DeviceSize;
    imageMipTailStride : DeviceSize;
}

FenceCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : FenceCreateFlags;
}

SemaphoreCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : SemaphoreCreateFlags;
}

EventCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : EventCreateFlags;
}

QueryPoolCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : QueryPoolCreateFlags;
    queryType : QueryType;
    queryCount : u32;
    pipelineStatistics : QueryPipelineStatisticFlags;
}

BufferCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : BufferCreateFlags;
    size : DeviceSize;
    usage : BufferUsageFlags;
    sharingMode : SharingMode;
    queueFamilyIndexCount : u32;
    pQueueFamilyIndices : *u32;
}

BufferViewCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : BufferViewCreateFlags;
    buffer : Buffer;
    format : Format;
    offset : DeviceSize;
    range : DeviceSize;
}

ImageCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : ImageCreateFlags;
    imageType : ImageType;
    format : Format;
    extent : Extent3D;
    mipLevels : u32;
    arrayLayers : u32;
    samples : SampleCountFlagBits;
    tiling : ImageTiling;
    usage : ImageUsageFlags;
    sharingMode : SharingMode;
    queueFamilyIndexCount : u32;
    pQueueFamilyIndices : *u32;
    initialLayout : ImageLayout;
}

SubresourceLayout :: struct {
    offset : DeviceSize;
    size : DeviceSize;
    rowPitch : DeviceSize;
    arrayPitch : DeviceSize;
    depthPitch : DeviceSize;
}

ComponentMapping :: struct {
    r : ComponentSwizzle;
    g : ComponentSwizzle;
    b : ComponentSwizzle;
    a : ComponentSwizzle;
}

ImageViewCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : ImageViewCreateFlags;
    image : Image;
    viewType : ImageViewType;
    format : Format;
    components : ComponentMapping;
    subresourceRange : ImageSubresourceRange;
}

ShaderModuleCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : ShaderModuleCreateFlags;
    codeSize : u64;
    pCode : *u32;
}

PipelineCacheCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : PipelineCacheCreateFlags;
    initialDataSize : u64;
    pInitialData : *void;
}

SpecializationMapEntry :: struct {
    constantID : u32;
    offset : u32;
    size : u64;
}

SpecializationInfo :: struct {
    mapEntryCount : u32;
    pMapEntries : *SpecializationMapEntry;
    dataSize : u64;
    pData : *void;
}

PipelineShaderStageCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : PipelineShaderStageCreateFlags;
    stage : ShaderStageFlagBits;
    module : ShaderModule;
    pName : *u8;
    pSpecializationInfo : *SpecializationInfo;
}

ComputePipelineCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : PipelineCreateFlags;
    stage : PipelineShaderStageCreateInfo;
    layout : PipelineLayout;
    basePipelineHandle : Pipeline;
    basePipelineIndex : s32;
}

VertexInputBindingDescription :: struct {
    binding : u32;
    stride : u32;
    inputRate : VertexInputRate;
}

VertexInputAttributeDescription :: struct {
    location : u32;
    binding : u32;
    format : Format;
    offset : u32;
}

PipelineVertexInputStateCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : PipelineVertexInputStateCreateFlags;
    vertexBindingDescriptionCount : u32;
    pVertexBindingDescriptions : *VertexInputBindingDescription;
    vertexAttributeDescriptionCount : u32;
    pVertexAttributeDescriptions : *VertexInputAttributeDescription;
}

PipelineInputAssemblyStateCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : PipelineInputAssemblyStateCreateFlags;
    topology : PrimitiveTopology;
    primitiveRestartEnable : Bool32;
}

PipelineTessellationStateCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : PipelineTessellationStateCreateFlags;
    patchControlPoints : u32;
}

Viewport :: struct {
    x : float32;
    y : float32;
    width : float32;
    height : float32;
    minDepth : float32;
    maxDepth : float32;
}

PipelineViewportStateCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : PipelineViewportStateCreateFlags;
    viewportCount : u32;
    pViewports : *Viewport;
    scissorCount : u32;
    pScissors : *Rect2D;
}

PipelineRasterizationStateCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : PipelineRasterizationStateCreateFlags;
    depthClampEnable : Bool32;
    rasterizerDiscardEnable : Bool32;
    polygonMode : PolygonMode;
    cullMode : CullModeFlags;
    frontFace : FrontFace;
    depthBiasEnable : Bool32;
    depthBiasConstantFactor : float32;
    depthBiasClamp : float32;
    depthBiasSlopeFactor : float32;
    lineWidth : float32;
}

PipelineMultisampleStateCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : PipelineMultisampleStateCreateFlags;
    rasterizationSamples : SampleCountFlagBits;
    sampleShadingEnable : Bool32;
    minSampleShading : float32;
    pSampleMask : *SampleMask;
    alphaToCoverageEnable : Bool32;
    alphaToOneEnable : Bool32;
}

StencilOpState :: struct {
    failOp : StencilOp;
    passOp : StencilOp;
    depthFailOp : StencilOp;
    compareOp : CompareOp;
    compareMask : u32;
    writeMask : u32;
    reference : u32;
}

PipelineDepthStencilStateCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : PipelineDepthStencilStateCreateFlags;
    depthTestEnable : Bool32;
    depthWriteEnable : Bool32;
    depthCompareOp : CompareOp;
    depthBoundsTestEnable : Bool32;
    stencilTestEnable : Bool32;
    front : StencilOpState;
    back : StencilOpState;
    minDepthBounds : float32;
    maxDepthBounds : float32;
}

PipelineColorBlendAttachmentState :: struct {
    blendEnable : Bool32;
    srcColorBlendFactor : BlendFactor;
    dstColorBlendFactor : BlendFactor;
    colorBlendOp : BlendOp;
    srcAlphaBlendFactor : BlendFactor;
    dstAlphaBlendFactor : BlendFactor;
    alphaBlendOp : BlendOp;
    colorWriteMask : ColorComponentFlags;
}

PipelineColorBlendStateCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : PipelineColorBlendStateCreateFlags;
    logicOpEnable : Bool32;
    logicOp : LogicOp;
    attachmentCount : u32;
    pAttachments : *PipelineColorBlendAttachmentState;
    blendConstants : [4]float32;
}

PipelineDynamicStateCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : PipelineDynamicStateCreateFlags;
    dynamicStateCount : u32;
    pDynamicStates : *DynamicState;
}

GraphicsPipelineCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : PipelineCreateFlags;
    stageCount : u32;
    pStages : *PipelineShaderStageCreateInfo;
    pVertexInputState : *PipelineVertexInputStateCreateInfo;
    pInputAssemblyState : *PipelineInputAssemblyStateCreateInfo;
    pTessellationState : *PipelineTessellationStateCreateInfo;
    pViewportState : *PipelineViewportStateCreateInfo;
    pRasterizationState : *PipelineRasterizationStateCreateInfo;
    pMultisampleState : *PipelineMultisampleStateCreateInfo;
    pDepthStencilState : *PipelineDepthStencilStateCreateInfo;
    pColorBlendState : *PipelineColorBlendStateCreateInfo;
    pDynamicState : *PipelineDynamicStateCreateInfo;
    layout : PipelineLayout;
    renderPass : RenderPass;
    subpass : u32;
    basePipelineHandle : Pipeline;
    basePipelineIndex : s32;
}

PushConstantRange :: struct {
    stageFlags : ShaderStageFlags;
    offset : u32;
    size : u32;
}

PipelineLayoutCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : PipelineLayoutCreateFlags;
    setLayoutCount : u32;
    pSetLayouts : *DescriptorSetLayout;
    pushConstantRangeCount : u32;
    pPushConstantRanges : *PushConstantRange;
}

SamplerCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : SamplerCreateFlags;
    magFilter : Filter;
    minFilter : Filter;
    mipmapMode : SamplerMipmapMode;
    addressModeU : SamplerAddressMode;
    addressModeV : SamplerAddressMode;
    addressModeW : SamplerAddressMode;
    mipLodBias : float32;
    anisotropyEnable : Bool32;
    maxAnisotropy : float32;
    compareEnable : Bool32;
    compareOp : CompareOp;
    minLod : float32;
    maxLod : float32;
    borderColor : BorderColor;
    unnormalizedCoordinates : Bool32;
}

CopyDescriptorSet :: struct {
    sType : StructureType;
    pNext : *void;
    srcSet : DescriptorSet;
    srcBinding : u32;
    srcArrayElement : u32;
    dstSet : DescriptorSet;
    dstBinding : u32;
    dstArrayElement : u32;
    descriptorCount : u32;
}

DescriptorBufferInfo :: struct {
    buffer : Buffer;
    offset : DeviceSize;
    range : DeviceSize;
}

DescriptorImageInfo :: struct {
    sampler : Sampler;
    imageView : ImageView;
    imageLayout : ImageLayout;
}

DescriptorPoolSize :: struct {
    type : DescriptorType;
    descriptorCount : u32;
}

DescriptorPoolCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : DescriptorPoolCreateFlags;
    maxSets : u32;
    poolSizeCount : u32;
    pPoolSizes : *DescriptorPoolSize;
}

DescriptorSetAllocateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    descriptorPool : DescriptorPool;
    descriptorSetCount : u32;
    pSetLayouts : *DescriptorSetLayout;
}

DescriptorSetLayoutBinding :: struct {
    binding : u32;
    descriptorType : DescriptorType;
    descriptorCount : u32;
    stageFlags : ShaderStageFlags;
    pImmutableSamplers : *Sampler;
}

DescriptorSetLayoutCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : DescriptorSetLayoutCreateFlags;
    bindingCount : u32;
    pBindings : *DescriptorSetLayoutBinding;
}

WriteDescriptorSet :: struct {
    sType : StructureType;
    pNext : *void;
    dstSet : DescriptorSet;
    dstBinding : u32;
    dstArrayElement : u32;
    descriptorCount : u32;
    descriptorType : DescriptorType;
    pImageInfo : *DescriptorImageInfo;
    pBufferInfo : *DescriptorBufferInfo;
    pTexelBufferView : *BufferView;
}

AttachmentDescription :: struct {
    flags : AttachmentDescriptionFlags;
    format : Format;
    samples : SampleCountFlagBits;
    loadOp : AttachmentLoadOp;
    storeOp : AttachmentStoreOp;
    stencilLoadOp : AttachmentLoadOp;
    stencilStoreOp : AttachmentStoreOp;
    initialLayout : ImageLayout;
    finalLayout : ImageLayout;
}

AttachmentReference :: struct {
    attachment : u32;
    layout : ImageLayout;
}

FramebufferCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : FramebufferCreateFlags;
    renderPass : RenderPass;
    attachmentCount : u32;
    pAttachments : *ImageView;
    width : u32;
    height : u32;
    layers : u32;
}

SubpassDescription :: struct {
    flags : SubpassDescriptionFlags;
    pipelineBindPoint : PipelineBindPoint;
    inputAttachmentCount : u32;
    pInputAttachments : *AttachmentReference;
    colorAttachmentCount : u32;
    pColorAttachments : *AttachmentReference;
    pResolveAttachments : *AttachmentReference;
    pDepthStencilAttachment : *AttachmentReference;
    preserveAttachmentCount : u32;
    pPreserveAttachments : *u32;
}

SubpassDependency :: struct {
    srcSubpass : u32;
    dstSubpass : u32;
    srcStageMask : PipelineStageFlags;
    dstStageMask : PipelineStageFlags;
    srcAccessMask : AccessFlags;
    dstAccessMask : AccessFlags;
    dependencyFlags : DependencyFlags;
}

RenderPassCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : RenderPassCreateFlags;
    attachmentCount : u32;
    pAttachments : *AttachmentDescription;
    subpassCount : u32;
    pSubpasses : *SubpassDescription;
    dependencyCount : u32;
    pDependencies : *SubpassDependency;
}

CommandPoolCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : CommandPoolCreateFlags;
    queueFamilyIndex : u32;
}

CommandBufferAllocateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    commandPool : CommandPool;
    level : CommandBufferLevel;
    commandBufferCount : u32;
}

CommandBufferInheritanceInfo :: struct {
    sType : StructureType;
    pNext : *void;
    renderPass : RenderPass;
    subpass : u32;
    framebuffer : Framebuffer;
    occlusionQueryEnable : Bool32;
    queryFlags : QueryControlFlags;
    pipelineStatistics : QueryPipelineStatisticFlags;
}

CommandBufferBeginInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : CommandBufferUsageFlags;
    pInheritanceInfo : *CommandBufferInheritanceInfo;
}

BufferCopy :: struct {
    srcOffset : DeviceSize;
    dstOffset : DeviceSize;
    size : DeviceSize;
}

ImageSubresourceLayers :: struct {
    aspectMask : ImageAspectFlags;
    mipLevel : u32;
    baseArrayLayer : u32;
    layerCount : u32;
}

BufferImageCopy :: struct {
    bufferOffset : DeviceSize;
    bufferRowLength : u32;
    bufferImageHeight : u32;
    imageSubresource : ImageSubresourceLayers;
    imageOffset : Offset3D;
    imageExtent : Extent3D;
}

ClearDepthStencilValue :: struct {
    depth : float32;
    stencil : u32;
}

ClearAttachment :: struct {
    aspectMask : ImageAspectFlags;
    colorAttachment : u32;
    clearValue : ClearValue;
}

ClearRect :: struct {
    rect : Rect2D;
    baseArrayLayer : u32;
    layerCount : u32;
}

ImageBlit :: struct {
    srcSubresource : ImageSubresourceLayers;
    srcOffsets : [2]Offset3D;
    dstSubresource : ImageSubresourceLayers;
    dstOffsets : [2]Offset3D;
}

ImageCopy :: struct {
    srcSubresource : ImageSubresourceLayers;
    srcOffset : Offset3D;
    dstSubresource : ImageSubresourceLayers;
    dstOffset : Offset3D;
    extent : Extent3D;
}

ImageResolve :: struct {
    srcSubresource : ImageSubresourceLayers;
    srcOffset : Offset3D;
    dstSubresource : ImageSubresourceLayers;
    dstOffset : Offset3D;
    extent : Extent3D;
}

RenderPassBeginInfo :: struct {
    sType : StructureType;
    pNext : *void;
    renderPass : RenderPass;
    framebuffer : Framebuffer;
    renderArea : Rect2D;
    clearValueCount : u32;
    pClearValues : *ClearValue;
}

SamplerYcbcrConversionT :: struct {}

DescriptorUpdateTemplateT :: struct {}

PhysicalDeviceSubgroupProperties :: struct {
    sType : StructureType;
    pNext : *void;
    subgroupSize : u32;
    supportedStages : ShaderStageFlags;
    supportedOperations : SubgroupFeatureFlags;
    quadOperationsInAllStages : Bool32;
}

BindBufferMemoryInfo :: struct {
    sType : StructureType;
    pNext : *void;
    buffer : Buffer;
    memory : DeviceMemory;
    memoryOffset : DeviceSize;
}

BindImageMemoryInfo :: struct {
    sType : StructureType;
    pNext : *void;
    image : Image;
    memory : DeviceMemory;
    memoryOffset : DeviceSize;
}

PhysicalDevice16BitStorageFeatures :: struct {
    sType : StructureType;
    pNext : *void;
    storageBuffer16BitAccess : Bool32;
    uniformAndStorageBuffer16BitAccess : Bool32;
    storagePushConstant16 : Bool32;
    storageInputOutput16 : Bool32;
}

MemoryDedicatedRequirements :: struct {
    sType : StructureType;
    pNext : *void;
    prefersDedicatedAllocation : Bool32;
    requiresDedicatedAllocation : Bool32;
}

MemoryDedicatedAllocateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    image : Image;
    buffer : Buffer;
}

MemoryAllocateFlagsInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : MemoryAllocateFlags;
    deviceMask : u32;
}

DeviceGroupRenderPassBeginInfo :: struct {
    sType : StructureType;
    pNext : *void;
    deviceMask : u32;
    deviceRenderAreaCount : u32;
    pDeviceRenderAreas : *Rect2D;
}

DeviceGroupCommandBufferBeginInfo :: struct {
    sType : StructureType;
    pNext : *void;
    deviceMask : u32;
}

DeviceGroupSubmitInfo :: struct {
    sType : StructureType;
    pNext : *void;
    waitSemaphoreCount : u32;
    pWaitSemaphoreDeviceIndices : *u32;
    commandBufferCount : u32;
    pCommandBufferDeviceMasks : *u32;
    signalSemaphoreCount : u32;
    pSignalSemaphoreDeviceIndices : *u32;
}

DeviceGroupBindSparseInfo :: struct {
    sType : StructureType;
    pNext : *void;
    resourceDeviceIndex : u32;
    memoryDeviceIndex : u32;
}

BindBufferMemoryDeviceGroupInfo :: struct {
    sType : StructureType;
    pNext : *void;
    deviceIndexCount : u32;
    pDeviceIndices : *u32;
}

BindImageMemoryDeviceGroupInfo :: struct {
    sType : StructureType;
    pNext : *void;
    deviceIndexCount : u32;
    pDeviceIndices : *u32;
    splitInstanceBindRegionCount : u32;
    pSplitInstanceBindRegions : *Rect2D;
}

PhysicalDeviceGroupProperties :: struct {
    sType : StructureType;
    pNext : *void;
    physicalDeviceCount : u32;
    physicalDevices : [32]PhysicalDevice;
    subsetAllocation : Bool32;
}

DeviceGroupDeviceCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    physicalDeviceCount : u32;
    pPhysicalDevices : *PhysicalDevice;
}

BufferMemoryRequirementsInfo2 :: struct {
    sType : StructureType;
    pNext : *void;
    buffer : Buffer;
}

ImageMemoryRequirementsInfo2 :: struct {
    sType : StructureType;
    pNext : *void;
    image : Image;
}

ImageSparseMemoryRequirementsInfo2 :: struct {
    sType : StructureType;
    pNext : *void;
    image : Image;
}

MemoryRequirements2 :: struct {
    sType : StructureType;
    pNext : *void;
    memoryRequirements : MemoryRequirements;
}

SparseImageMemoryRequirements2 :: struct {
    sType : StructureType;
    pNext : *void;
    memoryRequirements : SparseImageMemoryRequirements;
}

PhysicalDeviceFeatures2 :: struct {
    sType : StructureType;
    pNext : *void;
    features : PhysicalDeviceFeatures;
}

PhysicalDeviceProperties2 :: struct {
    sType : StructureType;
    pNext : *void;
    properties : PhysicalDeviceProperties;
}

FormatProperties2 :: struct {
    sType : StructureType;
    pNext : *void;
    formatProperties : FormatProperties;
}

ImageFormatProperties2 :: struct {
    sType : StructureType;
    pNext : *void;
    imageFormatProperties : ImageFormatProperties;
}

PhysicalDeviceImageFormatInfo2 :: struct {
    sType : StructureType;
    pNext : *void;
    format : Format;
    type : ImageType;
    tiling : ImageTiling;
    usage : ImageUsageFlags;
    flags : ImageCreateFlags;
}

QueueFamilyProperties2 :: struct {
    sType : StructureType;
    pNext : *void;
    queueFamilyProperties : QueueFamilyProperties;
}

PhysicalDeviceMemoryProperties2 :: struct {
    sType : StructureType;
    pNext : *void;
    memoryProperties : PhysicalDeviceMemoryProperties;
}

SparseImageFormatProperties2 :: struct {
    sType : StructureType;
    pNext : *void;
    properties : SparseImageFormatProperties;
}

PhysicalDeviceSparseImageFormatInfo2 :: struct {
    sType : StructureType;
    pNext : *void;
    format : Format;
    type : ImageType;
    samples : SampleCountFlagBits;
    usage : ImageUsageFlags;
    tiling : ImageTiling;
}

PhysicalDevicePointClippingProperties :: struct {
    sType : StructureType;
    pNext : *void;
    pointClippingBehavior : PointClippingBehavior;
}

InputAttachmentAspectReference :: struct {
    subpass : u32;
    inputAttachmentIndex : u32;
    aspectMask : ImageAspectFlags;
}

RenderPassInputAttachmentAspectCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    aspectReferenceCount : u32;
    pAspectReferences : *InputAttachmentAspectReference;
}

ImageViewUsageCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    usage : ImageUsageFlags;
}

PipelineTessellationDomainOriginStateCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    domainOrigin : TessellationDomainOrigin;
}

RenderPassMultiviewCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    subpassCount : u32;
    pViewMasks : *u32;
    dependencyCount : u32;
    pViewOffsets : *s32;
    correlationMaskCount : u32;
    pCorrelationMasks : *u32;
}

PhysicalDeviceMultiviewFeatures :: struct {
    sType : StructureType;
    pNext : *void;
    multiview : Bool32;
    multiviewGeometryShader : Bool32;
    multiviewTessellationShader : Bool32;
}

PhysicalDeviceMultiviewProperties :: struct {
    sType : StructureType;
    pNext : *void;
    maxMultiviewViewCount : u32;
    maxMultiviewInstanceIndex : u32;
}

PhysicalDeviceVariablePointersFeatures :: struct {
    sType : StructureType;
    pNext : *void;
    variablePointersStorageBuffer : Bool32;
    variablePointers : Bool32;
}

PhysicalDeviceProtectedMemoryFeatures :: struct {
    sType : StructureType;
    pNext : *void;
    protectedMemory : Bool32;
}

PhysicalDeviceProtectedMemoryProperties :: struct {
    sType : StructureType;
    pNext : *void;
    protectedNoFault : Bool32;
}

DeviceQueueInfo2 :: struct {
    sType : StructureType;
    pNext : *void;
    flags : DeviceQueueCreateFlags;
    queueFamilyIndex : u32;
    queueIndex : u32;
}

ProtectedSubmitInfo :: struct {
    sType : StructureType;
    pNext : *void;
    protectedSubmit : Bool32;
}

SamplerYcbcrConversionCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    format : Format;
    ycbcrModel : SamplerYcbcrModelConversion;
    ycbcrRange : SamplerYcbcrRange;
    components : ComponentMapping;
    xChromaOffset : ChromaLocation;
    yChromaOffset : ChromaLocation;
    chromaFilter : Filter;
    forceExplicitReconstruction : Bool32;
}

SamplerYcbcrConversionInfo :: struct {
    sType : StructureType;
    pNext : *void;
    conversion : SamplerYcbcrConversion;
}

BindImagePlaneMemoryInfo :: struct {
    sType : StructureType;
    pNext : *void;
    planeAspect : ImageAspectFlagBits;
}

ImagePlaneMemoryRequirementsInfo :: struct {
    sType : StructureType;
    pNext : *void;
    planeAspect : ImageAspectFlagBits;
}

PhysicalDeviceSamplerYcbcrConversionFeatures :: struct {
    sType : StructureType;
    pNext : *void;
    samplerYcbcrConversion : Bool32;
}

SamplerYcbcrConversionImageFormatProperties :: struct {
    sType : StructureType;
    pNext : *void;
    combinedImageSamplerDescriptorCount : u32;
}

DescriptorUpdateTemplateEntry :: struct {
    dstBinding : u32;
    dstArrayElement : u32;
    descriptorCount : u32;
    descriptorType : DescriptorType;
    offset : u64;
    stride : u64;
}

DescriptorUpdateTemplateCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : DescriptorUpdateTemplateCreateFlags;
    descriptorUpdateEntryCount : u32;
    pDescriptorUpdateEntries : *DescriptorUpdateTemplateEntry;
    templateType : DescriptorUpdateTemplateType;
    descriptorSetLayout : DescriptorSetLayout;
    pipelineBindPoint : PipelineBindPoint;
    pipelineLayout : PipelineLayout;
    set : u32;
}

ExternalMemoryProperties :: struct {
    externalMemoryFeatures : ExternalMemoryFeatureFlags;
    exportFromImportedHandleTypes : ExternalMemoryHandleTypeFlags;
    compatibleHandleTypes : ExternalMemoryHandleTypeFlags;
}

PhysicalDeviceExternalImageFormatInfo :: struct {
    sType : StructureType;
    pNext : *void;
    handleType : ExternalMemoryHandleTypeFlagBits;
}

ExternalImageFormatProperties :: struct {
    sType : StructureType;
    pNext : *void;
    externalMemoryProperties : ExternalMemoryProperties;
}

PhysicalDeviceExternalBufferInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : BufferCreateFlags;
    usage : BufferUsageFlags;
    handleType : ExternalMemoryHandleTypeFlagBits;
}

ExternalBufferProperties :: struct {
    sType : StructureType;
    pNext : *void;
    externalMemoryProperties : ExternalMemoryProperties;
}

PhysicalDeviceIDProperties :: struct {
    sType : StructureType;
    pNext : *void;
    deviceUUID : [16]u8;
    driverUUID : [16]u8;
    deviceLUID : [8]u8;
    deviceNodeMask : u32;
    deviceLUIDValid : Bool32;
}

ExternalMemoryImageCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    handleTypes : ExternalMemoryHandleTypeFlags;
}

ExternalMemoryBufferCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    handleTypes : ExternalMemoryHandleTypeFlags;
}

ExportMemoryAllocateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    handleTypes : ExternalMemoryHandleTypeFlags;
}

PhysicalDeviceExternalFenceInfo :: struct {
    sType : StructureType;
    pNext : *void;
    handleType : ExternalFenceHandleTypeFlagBits;
}

ExternalFenceProperties :: struct {
    sType : StructureType;
    pNext : *void;
    exportFromImportedHandleTypes : ExternalFenceHandleTypeFlags;
    compatibleHandleTypes : ExternalFenceHandleTypeFlags;
    externalFenceFeatures : ExternalFenceFeatureFlags;
}

ExportFenceCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    handleTypes : ExternalFenceHandleTypeFlags;
}

ExportSemaphoreCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    handleTypes : ExternalSemaphoreHandleTypeFlags;
}

PhysicalDeviceExternalSemaphoreInfo :: struct {
    sType : StructureType;
    pNext : *void;
    handleType : ExternalSemaphoreHandleTypeFlagBits;
}

ExternalSemaphoreProperties :: struct {
    sType : StructureType;
    pNext : *void;
    exportFromImportedHandleTypes : ExternalSemaphoreHandleTypeFlags;
    compatibleHandleTypes : ExternalSemaphoreHandleTypeFlags;
    externalSemaphoreFeatures : ExternalSemaphoreFeatureFlags;
}

PhysicalDeviceMaintenance3Properties :: struct {
    sType : StructureType;
    pNext : *void;
    maxPerSetDescriptors : u32;
    maxMemoryAllocationSize : DeviceSize;
}

DescriptorSetLayoutSupport :: struct {
    sType : StructureType;
    pNext : *void;
    supported : Bool32;
}

PhysicalDeviceShaderDrawParametersFeatures :: struct {
    sType : StructureType;
    pNext : *void;
    shaderDrawParameters : Bool32;
}

PhysicalDeviceVulkan11Features :: struct {
    sType : StructureType;
    pNext : *void;
    storageBuffer16BitAccess : Bool32;
    uniformAndStorageBuffer16BitAccess : Bool32;
    storagePushConstant16 : Bool32;
    storageInputOutput16 : Bool32;
    multiview : Bool32;
    multiviewGeometryShader : Bool32;
    multiviewTessellationShader : Bool32;
    variablePointersStorageBuffer : Bool32;
    variablePointers : Bool32;
    protectedMemory : Bool32;
    samplerYcbcrConversion : Bool32;
    shaderDrawParameters : Bool32;
}

PhysicalDeviceVulkan11Properties :: struct {
    sType : StructureType;
    pNext : *void;
    deviceUUID : [16]u8;
    driverUUID : [16]u8;
    deviceLUID : [8]u8;
    deviceNodeMask : u32;
    deviceLUIDValid : Bool32;
    subgroupSize : u32;
    subgroupSupportedStages : ShaderStageFlags;
    subgroupSupportedOperations : SubgroupFeatureFlags;
    subgroupQuadOperationsInAllStages : Bool32;
    pointClippingBehavior : PointClippingBehavior;
    maxMultiviewViewCount : u32;
    maxMultiviewInstanceIndex : u32;
    protectedNoFault : Bool32;
    maxPerSetDescriptors : u32;
    maxMemoryAllocationSize : DeviceSize;
}

PhysicalDeviceVulkan12Features :: struct {
    sType : StructureType;
    pNext : *void;
    samplerMirrorClampToEdge : Bool32;
    drawIndirectCount : Bool32;
    storageBuffer8BitAccess : Bool32;
    uniformAndStorageBuffer8BitAccess : Bool32;
    storagePushConstant8 : Bool32;
    shaderBufferInt64Atomics : Bool32;
    shaderSharedInt64Atomics : Bool32;
    shaderFloat16 : Bool32;
    shaderInt8 : Bool32;
    descriptorIndexing : Bool32;
    shaderInputAttachmentArrayDynamicIndexing : Bool32;
    shaderUniformTexelBufferArrayDynamicIndexing : Bool32;
    shaderStorageTexelBufferArrayDynamicIndexing : Bool32;
    shaderUniformBufferArrayNonUniformIndexing : Bool32;
    shaderSampledImageArrayNonUniformIndexing : Bool32;
    shaderStorageBufferArrayNonUniformIndexing : Bool32;
    shaderStorageImageArrayNonUniformIndexing : Bool32;
    shaderInputAttachmentArrayNonUniformIndexing : Bool32;
    shaderUniformTexelBufferArrayNonUniformIndexing : Bool32;
    shaderStorageTexelBufferArrayNonUniformIndexing : Bool32;
    descriptorBindingUniformBufferUpdateAfterBind : Bool32;
    descriptorBindingSampledImageUpdateAfterBind : Bool32;
    descriptorBindingStorageImageUpdateAfterBind : Bool32;
    descriptorBindingStorageBufferUpdateAfterBind : Bool32;
    descriptorBindingUniformTexelBufferUpdateAfterBind : Bool32;
    descriptorBindingStorageTexelBufferUpdateAfterBind : Bool32;
    descriptorBindingUpdateUnusedWhilePending : Bool32;
    descriptorBindingPartiallyBound : Bool32;
    descriptorBindingVariableDescriptorCount : Bool32;
    runtimeDescriptorArray : Bool32;
    samplerFilterMinmax : Bool32;
    scalarBlockLayout : Bool32;
    imagelessFramebuffer : Bool32;
    uniformBufferStandardLayout : Bool32;
    shaderSubgroupExtendedTypes : Bool32;
    separateDepthStencilLayouts : Bool32;
    hostQueryReset : Bool32;
    timelineSemaphore : Bool32;
    bufferDeviceAddress : Bool32;
    bufferDeviceAddressCaptureReplay : Bool32;
    bufferDeviceAddressMultiDevice : Bool32;
    vulkanMemoryModel : Bool32;
    vulkanMemoryModelDeviceScope : Bool32;
    vulkanMemoryModelAvailabilityVisibilityChains : Bool32;
    shaderOutputViewportIndex : Bool32;
    shaderOutputLayer : Bool32;
    subgroupBroadcastDynamicId : Bool32;
}

ConformanceVersion :: struct {
    major : u8;
    minor : u8;
    subminor : u8;
    patch : u8;
}

PhysicalDeviceVulkan12Properties :: struct {
    sType : StructureType;
    pNext : *void;
    driverID : DriverId;
    driverName : [256]u8;
    driverInfo : [256]u8;
    conformanceVersion : ConformanceVersion;
    denormBehaviorIndependence : ShaderFloatControlsIndependence;
    roundingModeIndependence : ShaderFloatControlsIndependence;
    shaderSignedZeroInfNanPreserveFloat16 : Bool32;
    shaderSignedZeroInfNanPreserveFloat32 : Bool32;
    shaderSignedZeroInfNanPreserveFloat64 : Bool32;
    shaderDenormPreserveFloat16 : Bool32;
    shaderDenormPreserveFloat32 : Bool32;
    shaderDenormPreserveFloat64 : Bool32;
    shaderDenormFlushToZeroFloat16 : Bool32;
    shaderDenormFlushToZeroFloat32 : Bool32;
    shaderDenormFlushToZeroFloat64 : Bool32;
    shaderRoundingModeRTEFloat16 : Bool32;
    shaderRoundingModeRTEFloat32 : Bool32;
    shaderRoundingModeRTEFloat64 : Bool32;
    shaderRoundingModeRTZFloat16 : Bool32;
    shaderRoundingModeRTZFloat32 : Bool32;
    shaderRoundingModeRTZFloat64 : Bool32;
    maxUpdateAfterBindDescriptorsInAllPools : u32;
    shaderUniformBufferArrayNonUniformIndexingNative : Bool32;
    shaderSampledImageArrayNonUniformIndexingNative : Bool32;
    shaderStorageBufferArrayNonUniformIndexingNative : Bool32;
    shaderStorageImageArrayNonUniformIndexingNative : Bool32;
    shaderInputAttachmentArrayNonUniformIndexingNative : Bool32;
    robustBufferAccessUpdateAfterBind : Bool32;
    quadDivergentImplicitLod : Bool32;
    maxPerStageDescriptorUpdateAfterBindSamplers : u32;
    maxPerStageDescriptorUpdateAfterBindUniformBuffers : u32;
    maxPerStageDescriptorUpdateAfterBindStorageBuffers : u32;
    maxPerStageDescriptorUpdateAfterBindSampledImages : u32;
    maxPerStageDescriptorUpdateAfterBindStorageImages : u32;
    maxPerStageDescriptorUpdateAfterBindInputAttachments : u32;
    maxPerStageUpdateAfterBindResources : u32;
    maxDescriptorSetUpdateAfterBindSamplers : u32;
    maxDescriptorSetUpdateAfterBindUniformBuffers : u32;
    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic : u32;
    maxDescriptorSetUpdateAfterBindStorageBuffers : u32;
    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic : u32;
    maxDescriptorSetUpdateAfterBindSampledImages : u32;
    maxDescriptorSetUpdateAfterBindStorageImages : u32;
    maxDescriptorSetUpdateAfterBindInputAttachments : u32;
    supportedDepthResolveModes : ResolveModeFlags;
    supportedStencilResolveModes : ResolveModeFlags;
    independentResolveNone : Bool32;
    independentResolve : Bool32;
    filterMinmaxSingleComponentFormats : Bool32;
    filterMinmaxImageComponentMapping : Bool32;
    maxTimelineSemaphoreValueDifference : u64;
    framebufferIntegerColorSampleCounts : SampleCountFlags;
}

ImageFormatListCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    viewFormatCount : u32;
    pViewFormats : *Format;
}

AttachmentDescription2 :: struct {
    sType : StructureType;
    pNext : *void;
    flags : AttachmentDescriptionFlags;
    format : Format;
    samples : SampleCountFlagBits;
    loadOp : AttachmentLoadOp;
    storeOp : AttachmentStoreOp;
    stencilLoadOp : AttachmentLoadOp;
    stencilStoreOp : AttachmentStoreOp;
    initialLayout : ImageLayout;
    finalLayout : ImageLayout;
}

AttachmentReference2 :: struct {
    sType : StructureType;
    pNext : *void;
    attachment : u32;
    layout : ImageLayout;
    aspectMask : ImageAspectFlags;
}

SubpassDescription2 :: struct {
    sType : StructureType;
    pNext : *void;
    flags : SubpassDescriptionFlags;
    pipelineBindPoint : PipelineBindPoint;
    viewMask : u32;
    inputAttachmentCount : u32;
    pInputAttachments : *AttachmentReference2;
    colorAttachmentCount : u32;
    pColorAttachments : *AttachmentReference2;
    pResolveAttachments : *AttachmentReference2;
    pDepthStencilAttachment : *AttachmentReference2;
    preserveAttachmentCount : u32;
    pPreserveAttachments : *u32;
}

SubpassDependency2 :: struct {
    sType : StructureType;
    pNext : *void;
    srcSubpass : u32;
    dstSubpass : u32;
    srcStageMask : PipelineStageFlags;
    dstStageMask : PipelineStageFlags;
    srcAccessMask : AccessFlags;
    dstAccessMask : AccessFlags;
    dependencyFlags : DependencyFlags;
    viewOffset : s32;
}

RenderPassCreateInfo2 :: struct {
    sType : StructureType;
    pNext : *void;
    flags : RenderPassCreateFlags;
    attachmentCount : u32;
    pAttachments : *AttachmentDescription2;
    subpassCount : u32;
    pSubpasses : *SubpassDescription2;
    dependencyCount : u32;
    pDependencies : *SubpassDependency2;
    correlatedViewMaskCount : u32;
    pCorrelatedViewMasks : *u32;
}

SubpassBeginInfo :: struct {
    sType : StructureType;
    pNext : *void;
    contents : SubpassContents;
}

SubpassEndInfo :: struct {
    sType : StructureType;
    pNext : *void;
}

PhysicalDevice8BitStorageFeatures :: struct {
    sType : StructureType;
    pNext : *void;
    storageBuffer8BitAccess : Bool32;
    uniformAndStorageBuffer8BitAccess : Bool32;
    storagePushConstant8 : Bool32;
}

PhysicalDeviceDriverProperties :: struct {
    sType : StructureType;
    pNext : *void;
    driverID : DriverId;
    driverName : [256]u8;
    driverInfo : [256]u8;
    conformanceVersion : ConformanceVersion;
}

PhysicalDeviceShaderAtomicInt64Features :: struct {
    sType : StructureType;
    pNext : *void;
    shaderBufferInt64Atomics : Bool32;
    shaderSharedInt64Atomics : Bool32;
}

PhysicalDeviceShaderFloat16Int8Features :: struct {
    sType : StructureType;
    pNext : *void;
    shaderFloat16 : Bool32;
    shaderInt8 : Bool32;
}

PhysicalDeviceFloatControlsProperties :: struct {
    sType : StructureType;
    pNext : *void;
    denormBehaviorIndependence : ShaderFloatControlsIndependence;
    roundingModeIndependence : ShaderFloatControlsIndependence;
    shaderSignedZeroInfNanPreserveFloat16 : Bool32;
    shaderSignedZeroInfNanPreserveFloat32 : Bool32;
    shaderSignedZeroInfNanPreserveFloat64 : Bool32;
    shaderDenormPreserveFloat16 : Bool32;
    shaderDenormPreserveFloat32 : Bool32;
    shaderDenormPreserveFloat64 : Bool32;
    shaderDenormFlushToZeroFloat16 : Bool32;
    shaderDenormFlushToZeroFloat32 : Bool32;
    shaderDenormFlushToZeroFloat64 : Bool32;
    shaderRoundingModeRTEFloat16 : Bool32;
    shaderRoundingModeRTEFloat32 : Bool32;
    shaderRoundingModeRTEFloat64 : Bool32;
    shaderRoundingModeRTZFloat16 : Bool32;
    shaderRoundingModeRTZFloat32 : Bool32;
    shaderRoundingModeRTZFloat64 : Bool32;
}

DescriptorSetLayoutBindingFlagsCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    bindingCount : u32;
    pBindingFlags : *DescriptorBindingFlags;
}

PhysicalDeviceDescriptorIndexingFeatures :: struct {
    sType : StructureType;
    pNext : *void;
    shaderInputAttachmentArrayDynamicIndexing : Bool32;
    shaderUniformTexelBufferArrayDynamicIndexing : Bool32;
    shaderStorageTexelBufferArrayDynamicIndexing : Bool32;
    shaderUniformBufferArrayNonUniformIndexing : Bool32;
    shaderSampledImageArrayNonUniformIndexing : Bool32;
    shaderStorageBufferArrayNonUniformIndexing : Bool32;
    shaderStorageImageArrayNonUniformIndexing : Bool32;
    shaderInputAttachmentArrayNonUniformIndexing : Bool32;
    shaderUniformTexelBufferArrayNonUniformIndexing : Bool32;
    shaderStorageTexelBufferArrayNonUniformIndexing : Bool32;
    descriptorBindingUniformBufferUpdateAfterBind : Bool32;
    descriptorBindingSampledImageUpdateAfterBind : Bool32;
    descriptorBindingStorageImageUpdateAfterBind : Bool32;
    descriptorBindingStorageBufferUpdateAfterBind : Bool32;
    descriptorBindingUniformTexelBufferUpdateAfterBind : Bool32;
    descriptorBindingStorageTexelBufferUpdateAfterBind : Bool32;
    descriptorBindingUpdateUnusedWhilePending : Bool32;
    descriptorBindingPartiallyBound : Bool32;
    descriptorBindingVariableDescriptorCount : Bool32;
    runtimeDescriptorArray : Bool32;
}

PhysicalDeviceDescriptorIndexingProperties :: struct {
    sType : StructureType;
    pNext : *void;
    maxUpdateAfterBindDescriptorsInAllPools : u32;
    shaderUniformBufferArrayNonUniformIndexingNative : Bool32;
    shaderSampledImageArrayNonUniformIndexingNative : Bool32;
    shaderStorageBufferArrayNonUniformIndexingNative : Bool32;
    shaderStorageImageArrayNonUniformIndexingNative : Bool32;
    shaderInputAttachmentArrayNonUniformIndexingNative : Bool32;
    robustBufferAccessUpdateAfterBind : Bool32;
    quadDivergentImplicitLod : Bool32;
    maxPerStageDescriptorUpdateAfterBindSamplers : u32;
    maxPerStageDescriptorUpdateAfterBindUniformBuffers : u32;
    maxPerStageDescriptorUpdateAfterBindStorageBuffers : u32;
    maxPerStageDescriptorUpdateAfterBindSampledImages : u32;
    maxPerStageDescriptorUpdateAfterBindStorageImages : u32;
    maxPerStageDescriptorUpdateAfterBindInputAttachments : u32;
    maxPerStageUpdateAfterBindResources : u32;
    maxDescriptorSetUpdateAfterBindSamplers : u32;
    maxDescriptorSetUpdateAfterBindUniformBuffers : u32;
    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic : u32;
    maxDescriptorSetUpdateAfterBindStorageBuffers : u32;
    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic : u32;
    maxDescriptorSetUpdateAfterBindSampledImages : u32;
    maxDescriptorSetUpdateAfterBindStorageImages : u32;
    maxDescriptorSetUpdateAfterBindInputAttachments : u32;
}

DescriptorSetVariableDescriptorCountAllocateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    descriptorSetCount : u32;
    pDescriptorCounts : *u32;
}

DescriptorSetVariableDescriptorCountLayoutSupport :: struct {
    sType : StructureType;
    pNext : *void;
    maxVariableDescriptorCount : u32;
}

SubpassDescriptionDepthStencilResolve :: struct {
    sType : StructureType;
    pNext : *void;
    depthResolveMode : ResolveModeFlagBits;
    stencilResolveMode : ResolveModeFlagBits;
    pDepthStencilResolveAttachment : *AttachmentReference2;
}

PhysicalDeviceDepthStencilResolveProperties :: struct {
    sType : StructureType;
    pNext : *void;
    supportedDepthResolveModes : ResolveModeFlags;
    supportedStencilResolveModes : ResolveModeFlags;
    independentResolveNone : Bool32;
    independentResolve : Bool32;
}

PhysicalDeviceScalarBlockLayoutFeatures :: struct {
    sType : StructureType;
    pNext : *void;
    scalarBlockLayout : Bool32;
}

ImageStencilUsageCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    stencilUsage : ImageUsageFlags;
}

SamplerReductionModeCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    reductionMode : SamplerReductionMode;
}

PhysicalDeviceSamplerFilterMinmaxProperties :: struct {
    sType : StructureType;
    pNext : *void;
    filterMinmaxSingleComponentFormats : Bool32;
    filterMinmaxImageComponentMapping : Bool32;
}

PhysicalDeviceVulkanMemoryModelFeatures :: struct {
    sType : StructureType;
    pNext : *void;
    vulkanMemoryModel : Bool32;
    vulkanMemoryModelDeviceScope : Bool32;
    vulkanMemoryModelAvailabilityVisibilityChains : Bool32;
}

PhysicalDeviceImagelessFramebufferFeatures :: struct {
    sType : StructureType;
    pNext : *void;
    imagelessFramebuffer : Bool32;
}

FramebufferAttachmentImageInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : ImageCreateFlags;
    usage : ImageUsageFlags;
    width : u32;
    height : u32;
    layerCount : u32;
    viewFormatCount : u32;
    pViewFormats : *Format;
}

FramebufferAttachmentsCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    attachmentImageInfoCount : u32;
    pAttachmentImageInfos : *FramebufferAttachmentImageInfo;
}

RenderPassAttachmentBeginInfo :: struct {
    sType : StructureType;
    pNext : *void;
    attachmentCount : u32;
    pAttachments : *ImageView;
}

PhysicalDeviceUniformBufferStandardLayoutFeatures :: struct {
    sType : StructureType;
    pNext : *void;
    uniformBufferStandardLayout : Bool32;
}

PhysicalDeviceShaderSubgroupExtendedTypesFeatures :: struct {
    sType : StructureType;
    pNext : *void;
    shaderSubgroupExtendedTypes : Bool32;
}

PhysicalDeviceSeparateDepthStencilLayoutsFeatures :: struct {
    sType : StructureType;
    pNext : *void;
    separateDepthStencilLayouts : Bool32;
}

AttachmentReferenceStencilLayout :: struct {
    sType : StructureType;
    pNext : *void;
    stencilLayout : ImageLayout;
}

AttachmentDescriptionStencilLayout :: struct {
    sType : StructureType;
    pNext : *void;
    stencilInitialLayout : ImageLayout;
    stencilFinalLayout : ImageLayout;
}

PhysicalDeviceHostQueryResetFeatures :: struct {
    sType : StructureType;
    pNext : *void;
    hostQueryReset : Bool32;
}

PhysicalDeviceDescriptorBufferPropertiesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    combinedImageSamplerDescriptorSingleArray : Bool32;
    bufferlessPushDescriptors : Bool32;
    allowSamplerImageViewPostSubmitCreation : Bool32;
    descriptorBufferOffsetAlignment : DeviceSize;
    maxDescriptorBufferBindings : u32;
    maxResourceDescriptorBufferBindings : u32;
    maxSamplerDescriptorBufferBindings : u32;
    maxEmbeddedImmutableSamplerBindings : u32;
    maxEmbeddedImmutableSamplers : u32;
    bufferCaptureReplayDescriptorDataSize : u64;
    imageCaptureReplayDescriptorDataSize : u64;
    imageViewCaptureReplayDescriptorDataSize : u64;
    samplerCaptureReplayDescriptorDataSize : u64;
    accelerationStructureCaptureReplayDescriptorDataSize : u64;
    samplerDescriptorSize : u64;
    combinedImageSamplerDescriptorSize : u64;
    sampledImageDescriptorSize : u64;
    storageImageDescriptorSize : u64;
    uniformTexelBufferDescriptorSize : u64;
    robustUniformTexelBufferDescriptorSize : u64;
    storageTexelBufferDescriptorSize : u64;
    robustStorageTexelBufferDescriptorSize : u64;
    uniformBufferDescriptorSize : u64;
    robustUniformBufferDescriptorSize : u64;
    storageBufferDescriptorSize : u64;
    robustStorageBufferDescriptorSize : u64;
    inputAttachmentDescriptorSize : u64;
    accelerationStructureDescriptorSize : u64;
    maxSamplerDescriptorBufferRange : DeviceSize;
    maxResourceDescriptorBufferRange : DeviceSize;
    samplerDescriptorBufferAddressSpaceSize : DeviceSize;
    resourceDescriptorBufferAddressSpaceSize : DeviceSize;
    descriptorBufferAddressSpaceSize : DeviceSize;
}

PhysicalDeviceDescriptorBufferFeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    descriptorBuffer : Bool32;
    descriptorBufferCaptureReplay : Bool32;
    descriptorBufferImageLayoutIgnored : Bool32;
    descriptorBufferPushDescriptors : Bool32;
}

PhysicalDeviceTimelineSemaphoreFeatures :: struct {
    sType : StructureType;
    pNext : *void;
    timelineSemaphore : Bool32;
}

PhysicalDeviceTimelineSemaphoreProperties :: struct {
    sType : StructureType;
    pNext : *void;
    maxTimelineSemaphoreValueDifference : u64;
}

SemaphoreTypeCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    semaphoreType : SemaphoreType;
    initialValue : u64;
}

TimelineSemaphoreSubmitInfo :: struct {
    sType : StructureType;
    pNext : *void;
    waitSemaphoreValueCount : u32;
    pWaitSemaphoreValues : *u64;
    signalSemaphoreValueCount : u32;
    pSignalSemaphoreValues : *u64;
}

SemaphoreWaitInfo :: struct {
    sType : StructureType;
    pNext : *void;
    flags : SemaphoreWaitFlags;
    semaphoreCount : u32;
    pSemaphores : *Semaphore;
    pValues : *u64;
}

SemaphoreSignalInfo :: struct {
    sType : StructureType;
    pNext : *void;
    semaphore : Semaphore;
    value : u64;
}

PhysicalDeviceBufferDeviceAddressFeatures :: struct {
    sType : StructureType;
    pNext : *void;
    bufferDeviceAddress : Bool32;
    bufferDeviceAddressCaptureReplay : Bool32;
    bufferDeviceAddressMultiDevice : Bool32;
}

BufferDeviceAddressInfo :: struct {
    sType : StructureType;
    pNext : *void;
    buffer : Buffer;
}

BufferOpaqueCaptureAddressCreateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    opaqueCaptureAddress : u64;
}

MemoryOpaqueCaptureAddressAllocateInfo :: struct {
    sType : StructureType;
    pNext : *void;
    opaqueCaptureAddress : u64;
}

DeviceMemoryOpaqueCaptureAddressInfo :: struct {
    sType : StructureType;
    pNext : *void;
    memory : DeviceMemory;
}

SurfaceKHRT :: struct {}

SurfaceCapabilitiesKHR :: struct {
    minImageCount : u32;
    maxImageCount : u32;
    currentExtent : Extent2D;
    minImageExtent : Extent2D;
    maxImageExtent : Extent2D;
    maxImageArrayLayers : u32;
    supportedTransforms : SurfaceTransformFlagsKHR;
    currentTransform : SurfaceTransformFlagBitsKHR;
    supportedCompositeAlpha : CompositeAlphaFlagsKHR;
    supportedUsageFlags : ImageUsageFlags;
}

SurfaceFormatKHR :: struct {
    format : Format;
    colorSpace : ColorSpaceKHR;
}

SwapchainKHRT :: struct {}

SwapchainCreateInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    flags : SwapchainCreateFlagsKHR;
    surface : SurfaceKHR;
    minImageCount : u32;
    imageFormat : Format;
    imageColorSpace : ColorSpaceKHR;
    imageExtent : Extent2D;
    imageArrayLayers : u32;
    imageUsage : ImageUsageFlags;
    imageSharingMode : SharingMode;
    queueFamilyIndexCount : u32;
    pQueueFamilyIndices : *u32;
    preTransform : SurfaceTransformFlagBitsKHR;
    compositeAlpha : CompositeAlphaFlagBitsKHR;
    presentMode : PresentModeKHR;
    clipped : Bool32;
    oldSwapchain : SwapchainKHR;
}

PresentInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    waitSemaphoreCount : u32;
    pWaitSemaphores : *Semaphore;
    swapchainCount : u32;
    pSwapchains : *SwapchainKHR;
    pImageIndices : *u32;
    pResults : *Result;
}

ImageSwapchainCreateInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    swapchain : SwapchainKHR;
}

BindImageMemorySwapchainInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    swapchain : SwapchainKHR;
    imageIndex : u32;
}

AcquireNextImageInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    swapchain : SwapchainKHR;
    timeout : u64;
    semaphore : Semaphore;
    fence : Fence;
    deviceMask : u32;
}

DeviceGroupPresentCapabilitiesKHR :: struct {
    sType : StructureType;
    pNext : *void;
    presentMask : [32]u32;
    modes : DeviceGroupPresentModeFlagsKHR;
}

DeviceGroupPresentInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    swapchainCount : u32;
    pDeviceMasks : *u32;
    mode : DeviceGroupPresentModeFlagBitsKHR;
}

DeviceGroupSwapchainCreateInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    modes : DeviceGroupPresentModeFlagsKHR;
}

DisplayKHRT :: struct {}

DisplayModeKHRT :: struct {}

DisplayModeParametersKHR :: struct {
    visibleRegion : Extent2D;
    refreshRate : u32;
}

DisplayModeCreateInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    flags : DisplayModeCreateFlagsKHR;
    parameters : DisplayModeParametersKHR;
}

DisplayModePropertiesKHR :: struct {
    displayMode : DisplayModeKHR;
    parameters : DisplayModeParametersKHR;
}

DisplayPlaneCapabilitiesKHR :: struct {
    supportedAlpha : DisplayPlaneAlphaFlagsKHR;
    minSrcPosition : Offset2D;
    maxSrcPosition : Offset2D;
    minSrcExtent : Extent2D;
    maxSrcExtent : Extent2D;
    minDstPosition : Offset2D;
    maxDstPosition : Offset2D;
    minDstExtent : Extent2D;
    maxDstExtent : Extent2D;
}

DisplayPlanePropertiesKHR :: struct {
    currentDisplay : DisplayKHR;
    currentStackIndex : u32;
}

DisplayPropertiesKHR :: struct {
    display : DisplayKHR;
    displayName : *u8;
    physicalDimensions : Extent2D;
    physicalResolution : Extent2D;
    supportedTransforms : SurfaceTransformFlagsKHR;
    planeReorderPossible : Bool32;
    persistentContent : Bool32;
}

DisplaySurfaceCreateInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    flags : DisplaySurfaceCreateFlagsKHR;
    displayMode : DisplayModeKHR;
    planeIndex : u32;
    planeStackIndex : u32;
    transform : SurfaceTransformFlagBitsKHR;
    globalAlpha : float32;
    alphaMode : DisplayPlaneAlphaFlagBitsKHR;
    imageExtent : Extent2D;
}

DisplayPresentInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    srcRect : Rect2D;
    dstRect : Rect2D;
    persistent : Bool32;
}

ImportMemoryFdInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    handleType : ExternalMemoryHandleTypeFlagBits;
    fd : s32;
}

MemoryFdPropertiesKHR :: struct {
    sType : StructureType;
    pNext : *void;
    memoryTypeBits : u32;
}

MemoryGetFdInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    memory : DeviceMemory;
    handleType : ExternalMemoryHandleTypeFlagBits;
}

ImportSemaphoreFdInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    semaphore : Semaphore;
    flags : SemaphoreImportFlags;
    handleType : ExternalSemaphoreHandleTypeFlagBits;
    fd : s32;
}

SemaphoreGetFdInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    semaphore : Semaphore;
    handleType : ExternalSemaphoreHandleTypeFlagBits;
}

PhysicalDevicePushDescriptorPropertiesKHR :: struct {
    sType : StructureType;
    pNext : *void;
    maxPushDescriptors : u32;
}

RectLayerKHR :: struct {
    offset : Offset2D;
    extent : Extent2D;
    layer : u32;
}

PresentRegionKHR :: struct {
    rectangleCount : u32;
    pRectangles : *RectLayerKHR;
}

PresentRegionsKHR :: struct {
    sType : StructureType;
    pNext : *void;
    swapchainCount : u32;
    pRegions : *PresentRegionKHR;
}

SharedPresentSurfaceCapabilitiesKHR :: struct {
    sType : StructureType;
    pNext : *void;
    sharedPresentSupportedUsageFlags : ImageUsageFlags;
}

ImportFenceFdInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    fence : Fence;
    flags : FenceImportFlags;
    handleType : ExternalFenceHandleTypeFlagBits;
    fd : s32;
}

FenceGetFdInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    fence : Fence;
    handleType : ExternalFenceHandleTypeFlagBits;
}

PhysicalDevicePerformanceQueryFeaturesKHR :: struct {
    sType : StructureType;
    pNext : *void;
    performanceCounterQueryPools : Bool32;
    performanceCounterMultipleQueryPools : Bool32;
}

PhysicalDevicePerformanceQueryPropertiesKHR :: struct {
    sType : StructureType;
    pNext : *void;
    allowCommandBufferQueryCopies : Bool32;
}

PerformanceCounterKHR :: struct {
    sType : StructureType;
    pNext : *void;
    unit : PerformanceCounterUnitKHR;
    scope : PerformanceCounterScopeKHR;
    storage : PerformanceCounterStorageKHR;
    uuid : [16]u8;
}

PerformanceCounterDescriptionKHR :: struct {
    sType : StructureType;
    pNext : *void;
    flags : PerformanceCounterDescriptionFlagsKHR;
    name : [256]u8;
    category : [256]u8;
    description : [256]u8;
}

QueryPoolPerformanceCreateInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    queueFamilyIndex : u32;
    counterIndexCount : u32;
    pCounterIndices : *u32;
}

AcquireProfilingLockInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    flags : AcquireProfilingLockFlagsKHR;
    timeout : u64;
}

PerformanceQuerySubmitInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    counterPassIndex : u32;
}

PhysicalDeviceSurfaceInfo2KHR :: struct {
    sType : StructureType;
    pNext : *void;
    surface : SurfaceKHR;
}

SurfaceCapabilities2KHR :: struct {
    sType : StructureType;
    pNext : *void;
    surfaceCapabilities : SurfaceCapabilitiesKHR;
}

SurfaceFormat2KHR :: struct {
    sType : StructureType;
    pNext : *void;
    surfaceFormat : SurfaceFormatKHR;
}

DisplayProperties2KHR :: struct {
    sType : StructureType;
    pNext : *void;
    displayProperties : DisplayPropertiesKHR;
}

DisplayPlaneProperties2KHR :: struct {
    sType : StructureType;
    pNext : *void;
    displayPlaneProperties : DisplayPlanePropertiesKHR;
}

DisplayModeProperties2KHR :: struct {
    sType : StructureType;
    pNext : *void;
    displayModeProperties : DisplayModePropertiesKHR;
}

DisplayPlaneInfo2KHR :: struct {
    sType : StructureType;
    pNext : *void;
    mode : DisplayModeKHR;
    planeIndex : u32;
}

DisplayPlaneCapabilities2KHR :: struct {
    sType : StructureType;
    pNext : *void;
    capabilities : DisplayPlaneCapabilitiesKHR;
}

PhysicalDeviceShaderClockFeaturesKHR :: struct {
    sType : StructureType;
    pNext : *void;
    shaderSubgroupClock : Bool32;
    shaderDeviceClock : Bool32;
}

PhysicalDeviceShaderTerminateInvocationFeaturesKHR :: struct {
    sType : StructureType;
    pNext : *void;
    shaderTerminateInvocation : Bool32;
}

FragmentShadingRateAttachmentInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    pFragmentShadingRateAttachment : *AttachmentReference2;
    shadingRateAttachmentTexelSize : Extent2D;
}

PipelineFragmentShadingRateStateCreateInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    fragmentSize : Extent2D;
    combinerOps : [2]FragmentShadingRateCombinerOpKHR;
}

PhysicalDeviceFragmentShadingRateFeaturesKHR :: struct {
    sType : StructureType;
    pNext : *void;
    pipelineFragmentShadingRate : Bool32;
    primitiveFragmentShadingRate : Bool32;
    attachmentFragmentShadingRate : Bool32;
}

PhysicalDeviceFragmentShadingRatePropertiesKHR :: struct {
    sType : StructureType;
    pNext : *void;
    minFragmentShadingRateAttachmentTexelSize : Extent2D;
    maxFragmentShadingRateAttachmentTexelSize : Extent2D;
    maxFragmentShadingRateAttachmentTexelSizeAspectRatio : u32;
    primitiveFragmentShadingRateWithMultipleViewports : Bool32;
    layeredShadingRateAttachments : Bool32;
    fragmentShadingRateNonTrivialCombinerOps : Bool32;
    maxFragmentSize : Extent2D;
    maxFragmentSizeAspectRatio : u32;
    maxFragmentShadingRateCoverageSamples : u32;
    maxFragmentShadingRateRasterizationSamples : SampleCountFlagBits;
    fragmentShadingRateWithShaderDepthStencilWrites : Bool32;
    fragmentShadingRateWithSampleMask : Bool32;
    fragmentShadingRateWithShaderSampleMask : Bool32;
    fragmentShadingRateWithConservativeRasterization : Bool32;
    fragmentShadingRateWithFragmentShaderInterlock : Bool32;
    fragmentShadingRateWithCustomSampleLocations : Bool32;
    fragmentShadingRateStrictMultiplyCombiner : Bool32;
}

PhysicalDeviceFragmentShadingRateKHR :: struct {
    sType : StructureType;
    pNext : *void;
    sampleCounts : SampleCountFlags;
    fragmentSize : Extent2D;
}

SurfaceProtectedCapabilitiesKHR :: struct {
    sType : StructureType;
    pNext : *void;
    supportsProtected : Bool32;
}

DeferredOperationKHRT :: struct {}

PhysicalDevicePipelineExecutablePropertiesFeaturesKHR :: struct {
    sType : StructureType;
    pNext : *void;
    pipelineExecutableInfo : Bool32;
}

PipelineInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    pipeline : Pipeline;
}

PipelineExecutablePropertiesKHR :: struct {
    sType : StructureType;
    pNext : *void;
    stages : ShaderStageFlags;
    name : [256]u8;
    description : [256]u8;
    subgroupSize : u32;
}

PipelineExecutableInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    pipeline : Pipeline;
    executableIndex : u32;
}

PipelineExecutableStatisticKHR :: struct {
    sType : StructureType;
    pNext : *void;
    name : [256]u8;
    description : [256]u8;
    format : PipelineExecutableStatisticFormatKHR;
    value : PipelineExecutableStatisticValueKHR;
}

PipelineExecutableInternalRepresentationKHR :: struct {
    sType : StructureType;
    pNext : *void;
    name : [256]u8;
    description : [256]u8;
    isText : Bool32;
    dataSize : u64;
    pData : *void;
}

PipelineLibraryCreateInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    libraryCount : u32;
    pLibraries : *Pipeline;
}

BufferCopy2KHR :: struct {
    sType : StructureType;
    pNext : *void;
    srcOffset : DeviceSize;
    dstOffset : DeviceSize;
    size : DeviceSize;
}

CopyBufferInfo2KHR :: struct {
    sType : StructureType;
    pNext : *void;
    srcBuffer : Buffer;
    dstBuffer : Buffer;
    regionCount : u32;
    pRegions : *BufferCopy2KHR;
}

ImageCopy2KHR :: struct {
    sType : StructureType;
    pNext : *void;
    srcSubresource : ImageSubresourceLayers;
    srcOffset : Offset3D;
    dstSubresource : ImageSubresourceLayers;
    dstOffset : Offset3D;
    extent : Extent3D;
}

CopyImageInfo2KHR :: struct {
    sType : StructureType;
    pNext : *void;
    srcImage : Image;
    srcImageLayout : ImageLayout;
    dstImage : Image;
    dstImageLayout : ImageLayout;
    regionCount : u32;
    pRegions : *ImageCopy2KHR;
}

BufferImageCopy2KHR :: struct {
    sType : StructureType;
    pNext : *void;
    bufferOffset : DeviceSize;
    bufferRowLength : u32;
    bufferImageHeight : u32;
    imageSubresource : ImageSubresourceLayers;
    imageOffset : Offset3D;
    imageExtent : Extent3D;
}

CopyBufferToImageInfo2KHR :: struct {
    sType : StructureType;
    pNext : *void;
    srcBuffer : Buffer;
    dstImage : Image;
    dstImageLayout : ImageLayout;
    regionCount : u32;
    pRegions : *BufferImageCopy2KHR;
}

CopyImageToBufferInfo2KHR :: struct {
    sType : StructureType;
    pNext : *void;
    srcImage : Image;
    srcImageLayout : ImageLayout;
    dstBuffer : Buffer;
    regionCount : u32;
    pRegions : *BufferImageCopy2KHR;
}

ImageBlit2KHR :: struct {
    sType : StructureType;
    pNext : *void;
    srcSubresource : ImageSubresourceLayers;
    srcOffsets : [2]Offset3D;
    dstSubresource : ImageSubresourceLayers;
    dstOffsets : [2]Offset3D;
}

BlitImageInfo2KHR :: struct {
    sType : StructureType;
    pNext : *void;
    srcImage : Image;
    srcImageLayout : ImageLayout;
    dstImage : Image;
    dstImageLayout : ImageLayout;
    regionCount : u32;
    pRegions : *ImageBlit2KHR;
    filter : Filter;
}

ImageResolve2KHR :: struct {
    sType : StructureType;
    pNext : *void;
    srcSubresource : ImageSubresourceLayers;
    srcOffset : Offset3D;
    dstSubresource : ImageSubresourceLayers;
    dstOffset : Offset3D;
    extent : Extent3D;
}

ResolveImageInfo2KHR :: struct {
    sType : StructureType;
    pNext : *void;
    srcImage : Image;
    srcImageLayout : ImageLayout;
    dstImage : Image;
    dstImageLayout : ImageLayout;
    regionCount : u32;
    pRegions : *ImageResolve2KHR;
}

DebugReportCallbackEXTT :: struct {}

DebugReportCallbackCreateInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    flags : DebugReportFlagsEXT;
    pfnCallback : PFN_DebugReportCallbackEXT;
    pUserData : *void;
}

PipelineRasterizationStateRasterizationOrderAMD :: struct {
    sType : StructureType;
    pNext : *void;
    rasterizationOrder : RasterizationOrderAMD;
}

DebugMarkerObjectNameInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    objectType : DebugReportObjectTypeEXT;
    object : u64;
    pObjectName : *u8;
}

DebugMarkerObjectTagInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    objectType : DebugReportObjectTypeEXT;
    object : u64;
    tagName : u64;
    tagSize : u64;
    pTag : *void;
}

DebugMarkerMarkerInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    pMarkerName : *u8;
    color : [4]float32;
}

DedicatedAllocationImageCreateInfoNV :: struct {
    sType : StructureType;
    pNext : *void;
    dedicatedAllocation : Bool32;
}

DedicatedAllocationBufferCreateInfoNV :: struct {
    sType : StructureType;
    pNext : *void;
    dedicatedAllocation : Bool32;
}

DedicatedAllocationMemoryAllocateInfoNV :: struct {
    sType : StructureType;
    pNext : *void;
    image : Image;
    buffer : Buffer;
}

PhysicalDeviceTransformFeedbackFeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    transformFeedback : Bool32;
    geometryStreams : Bool32;
}

PhysicalDeviceTransformFeedbackPropertiesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    maxTransformFeedbackStreams : u32;
    maxTransformFeedbackBuffers : u32;
    maxTransformFeedbackBufferSize : DeviceSize;
    maxTransformFeedbackStreamDataSize : u32;
    maxTransformFeedbackBufferDataSize : u32;
    maxTransformFeedbackBufferDataStride : u32;
    transformFeedbackQueries : Bool32;
    transformFeedbackStreamsLinesTriangles : Bool32;
    transformFeedbackRasterizationStreamSelect : Bool32;
    transformFeedbackDraw : Bool32;
}

PipelineRasterizationStateStreamCreateInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    flags : PipelineRasterizationStateStreamCreateFlagsEXT;
    rasterizationStream : u32;
}

ImageViewHandleInfoNVX :: struct {
    sType : StructureType;
    pNext : *void;
    imageView : ImageView;
    descriptorType : DescriptorType;
    sampler : Sampler;
}

ImageViewAddressPropertiesNVX :: struct {
    sType : StructureType;
    pNext : *void;
    deviceAddress : DeviceAddress;
    size : DeviceSize;
}

TextureLODGatherFormatPropertiesAMD :: struct {
    sType : StructureType;
    pNext : *void;
    supportsTextureGatherLODBiasAMD : Bool32;
}

ShaderResourceUsageAMD :: struct {
    numUsedVgprs : u32;
    numUsedSgprs : u32;
    ldsSizePerLocalWorkGroup : u32;
    ldsUsageSizeInBytes : u64;
    scratchMemUsageInBytes : u64;
}

ShaderStatisticsInfoAMD :: struct {
    shaderStageMask : ShaderStageFlags;
    resourceUsage : ShaderResourceUsageAMD;
    numPhysicalVgprs : u32;
    numPhysicalSgprs : u32;
    numAvailableVgprs : u32;
    numAvailableSgprs : u32;
    computeWorkGroupSize : [3]u32;
}

PhysicalDeviceCornerSampledImageFeaturesNV :: struct {
    sType : StructureType;
    pNext : *void;
    cornerSampledImage : Bool32;
}

ExternalImageFormatPropertiesNV :: struct {
    imageFormatProperties : ImageFormatProperties;
    externalMemoryFeatures : ExternalMemoryFeatureFlagsNV;
    exportFromImportedHandleTypes : ExternalMemoryHandleTypeFlagsNV;
    compatibleHandleTypes : ExternalMemoryHandleTypeFlagsNV;
}

ExternalMemoryImageCreateInfoNV :: struct {
    sType : StructureType;
    pNext : *void;
    handleTypes : ExternalMemoryHandleTypeFlagsNV;
}

ExportMemoryAllocateInfoNV :: struct {
    sType : StructureType;
    pNext : *void;
    handleTypes : ExternalMemoryHandleTypeFlagsNV;
}

ValidationFlagsEXT :: struct {
    sType : StructureType;
    pNext : *void;
    disabledValidationCheckCount : u32;
    pDisabledValidationChecks : *ValidationCheckEXT;
}

PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    textureCompressionASTC_HDR : Bool32;
}

ImageViewASTCDecodeModeEXT :: struct {
    sType : StructureType;
    pNext : *void;
    decodeMode : Format;
}

PhysicalDeviceASTCDecodeFeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    decodeModeSharedExponent : Bool32;
}

ConditionalRenderingBeginInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    buffer : Buffer;
    offset : DeviceSize;
    flags : ConditionalRenderingFlagsEXT;
}

PhysicalDeviceConditionalRenderingFeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    conditionalRendering : Bool32;
    inheritedConditionalRendering : Bool32;
}

CommandBufferInheritanceConditionalRenderingInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    conditionalRenderingEnable : Bool32;
}

ViewportWScalingNV :: struct {
    xcoeff : float32;
    ycoeff : float32;
}

PipelineViewportWScalingStateCreateInfoNV :: struct {
    sType : StructureType;
    pNext : *void;
    viewportWScalingEnable : Bool32;
    viewportCount : u32;
    pViewportWScalings : *ViewportWScalingNV;
}

SurfaceCapabilities2EXT :: struct {
    sType : StructureType;
    pNext : *void;
    minImageCount : u32;
    maxImageCount : u32;
    currentExtent : Extent2D;
    minImageExtent : Extent2D;
    maxImageExtent : Extent2D;
    maxImageArrayLayers : u32;
    supportedTransforms : SurfaceTransformFlagsKHR;
    currentTransform : SurfaceTransformFlagBitsKHR;
    supportedCompositeAlpha : CompositeAlphaFlagsKHR;
    supportedUsageFlags : ImageUsageFlags;
    supportedSurfaceCounters : SurfaceCounterFlagsEXT;
}

DisplayPowerInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    powerState : DisplayPowerStateEXT;
}

DeviceEventInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    deviceEvent : DeviceEventTypeEXT;
}

DisplayEventInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    displayEvent : DisplayEventTypeEXT;
}

SwapchainCounterCreateInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    surfaceCounters : SurfaceCounterFlagsEXT;
}

RefreshCycleDurationGOOGLE :: struct {
    refreshDuration : u64;
}

PastPresentationTimingGOOGLE :: struct {
    presentID : u32;
    desiredPresentTime : u64;
    actualPresentTime : u64;
    earliestPresentTime : u64;
    presentMargin : u64;
}

PresentTimeGOOGLE :: struct {
    presentID : u32;
    desiredPresentTime : u64;
}

PresentTimesInfoGOOGLE :: struct {
    sType : StructureType;
    pNext : *void;
    swapchainCount : u32;
    pTimes : *PresentTimeGOOGLE;
}

PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX :: struct {
    sType : StructureType;
    pNext : *void;
    perViewPositionAllComponents : Bool32;
}

ViewportSwizzleNV :: struct {
    x : ViewportCoordinateSwizzleNV;
    y : ViewportCoordinateSwizzleNV;
    z : ViewportCoordinateSwizzleNV;
    w : ViewportCoordinateSwizzleNV;
}

PipelineViewportSwizzleStateCreateInfoNV :: struct {
    sType : StructureType;
    pNext : *void;
    flags : PipelineViewportSwizzleStateCreateFlagsNV;
    viewportCount : u32;
    pViewportSwizzles : *ViewportSwizzleNV;
}

PhysicalDeviceDiscardRectanglePropertiesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    maxDiscardRectangles : u32;
}

PipelineDiscardRectangleStateCreateInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    flags : PipelineDiscardRectangleStateCreateFlagsEXT;
    discardRectangleMode : DiscardRectangleModeEXT;
    discardRectangleCount : u32;
    pDiscardRectangles : *Rect2D;
}

PhysicalDeviceConservativeRasterizationPropertiesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    primitiveOverestimationSize : float32;
    maxExtraPrimitiveOverestimationSize : float32;
    extraPrimitiveOverestimationSizeGranularity : float32;
    primitiveUnderestimation : Bool32;
    conservativePointAndLineRasterization : Bool32;
    degenerateTrianglesRasterized : Bool32;
    degenerateLinesRasterized : Bool32;
    fullyCoveredFragmentShaderInputVariable : Bool32;
    conservativeRasterizationPostDepthCoverage : Bool32;
}

PipelineRasterizationConservativeStateCreateInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    flags : PipelineRasterizationConservativeStateCreateFlagsEXT;
    conservativeRasterizationMode : ConservativeRasterizationModeEXT;
    extraPrimitiveOverestimationSize : float32;
}

PhysicalDeviceDepthClipEnableFeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    depthClipEnable : Bool32;
}

PipelineRasterizationDepthClipStateCreateInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    flags : PipelineRasterizationDepthClipStateCreateFlagsEXT;
    depthClipEnable : Bool32;
}

XYColorEXT :: struct {
    x : float32;
    y : float32;
}

HdrMetadataEXT :: struct {
    sType : StructureType;
    pNext : *void;
    displayPrimaryRed : XYColorEXT;
    displayPrimaryGreen : XYColorEXT;
    displayPrimaryBlue : XYColorEXT;
    whitePoint : XYColorEXT;
    maxLuminance : float32;
    minLuminance : float32;
    maxContentLightLevel : float32;
    maxFrameAverageLightLevel : float32;
}

DebugUtilsMessengerEXTT :: struct {}

DebugUtilsLabelEXT :: struct {
    sType : StructureType;
    pNext : *void;
    pLabelName : *u8;
    color : [4]float32;
}

DebugUtilsObjectNameInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    objectType : ObjectType;
    objectHandle : u64;
    pObjectName : *u8;
}

DebugUtilsMessengerCallbackDataEXT :: struct {
    sType : StructureType;
    pNext : *void;
    flags : DebugUtilsMessengerCallbackDataFlagsEXT;
    pMessageIdName : *u8;
    messageIdNumber : s32;
    pMessage : *u8;
    queueLabelCount : u32;
    pQueueLabels : *DebugUtilsLabelEXT;
    cmdBufLabelCount : u32;
    pCmdBufLabels : *DebugUtilsLabelEXT;
    objectCount : u32;
    pObjects : *DebugUtilsObjectNameInfoEXT;
}

DebugUtilsMessengerCreateInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    flags : DebugUtilsMessengerCreateFlagsEXT;
    messageSeverity : DebugUtilsMessageSeverityFlagsEXT;
    messageType : DebugUtilsMessageTypeFlagsEXT;
    pfnUserCallback : PFN_DebugUtilsMessengerCallbackEXT;
    pUserData : *void;
}

DebugUtilsObjectTagInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    objectType : ObjectType;
    objectHandle : u64;
    tagName : u64;
    tagSize : u64;
    pTag : *void;
}

PhysicalDeviceInlineUniformBlockFeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    inlineUniformBlock : Bool32;
    descriptorBindingInlineUniformBlockUpdateAfterBind : Bool32;
}

PhysicalDeviceInlineUniformBlockPropertiesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    maxInlineUniformBlockSize : u32;
    maxPerStageDescriptorInlineUniformBlocks : u32;
    maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks : u32;
    maxDescriptorSetInlineUniformBlocks : u32;
    maxDescriptorSetUpdateAfterBindInlineUniformBlocks : u32;
}

WriteDescriptorSetInlineUniformBlockEXT :: struct {
    sType : StructureType;
    pNext : *void;
    dataSize : u32;
    pData : *void;
}

DescriptorPoolInlineUniformBlockCreateInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    maxInlineUniformBlockBindings : u32;
}

SampleLocationEXT :: struct {
    x : float32;
    y : float32;
}

SampleLocationsInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    sampleLocationsPerPixel : SampleCountFlagBits;
    sampleLocationGridSize : Extent2D;
    sampleLocationsCount : u32;
    pSampleLocations : *SampleLocationEXT;
}

AttachmentSampleLocationsEXT :: struct {
    attachmentIndex : u32;
    sampleLocationsInfo : SampleLocationsInfoEXT;
}

SubpassSampleLocationsEXT :: struct {
    subpassIndex : u32;
    sampleLocationsInfo : SampleLocationsInfoEXT;
}

RenderPassSampleLocationsBeginInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    attachmentInitialSampleLocationsCount : u32;
    pAttachmentInitialSampleLocations : *AttachmentSampleLocationsEXT;
    postSubpassSampleLocationsCount : u32;
    pPostSubpassSampleLocations : *SubpassSampleLocationsEXT;
}

PipelineSampleLocationsStateCreateInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    sampleLocationsEnable : Bool32;
    sampleLocationsInfo : SampleLocationsInfoEXT;
}

PhysicalDeviceSampleLocationsPropertiesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    sampleLocationSampleCounts : SampleCountFlags;
    maxSampleLocationGridSize : Extent2D;
    sampleLocationCoordinateRange : [2]float32;
    sampleLocationSubPixelBits : u32;
    variableSampleLocations : Bool32;
}

MultisamplePropertiesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    maxSampleLocationGridSize : Extent2D;
}

PhysicalDeviceBlendOperationAdvancedFeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    advancedBlendCoherentOperations : Bool32;
}

PhysicalDeviceBlendOperationAdvancedPropertiesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    advancedBlendMaxColorAttachments : u32;
    advancedBlendIndependentBlend : Bool32;
    advancedBlendNonPremultipliedSrcColor : Bool32;
    advancedBlendNonPremultipliedDstColor : Bool32;
    advancedBlendCorrelatedOverlap : Bool32;
    advancedBlendAllOperations : Bool32;
}

PipelineColorBlendAdvancedStateCreateInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    srcPremultiplied : Bool32;
    dstPremultiplied : Bool32;
    blendOverlap : BlendOverlapEXT;
}

PipelineCoverageToColorStateCreateInfoNV :: struct {
    sType : StructureType;
    pNext : *void;
    flags : PipelineCoverageToColorStateCreateFlagsNV;
    coverageToColorEnable : Bool32;
    coverageToColorLocation : u32;
}

PipelineCoverageModulationStateCreateInfoNV :: struct {
    sType : StructureType;
    pNext : *void;
    flags : PipelineCoverageModulationStateCreateFlagsNV;
    coverageModulationMode : CoverageModulationModeNV;
    coverageModulationTableEnable : Bool32;
    coverageModulationTableCount : u32;
    pCoverageModulationTable : *float32;
}

PhysicalDeviceShaderSMBuiltinsPropertiesNV :: struct {
    sType : StructureType;
    pNext : *void;
    shaderSMCount : u32;
    shaderWarpsPerSM : u32;
}

PhysicalDeviceShaderSMBuiltinsFeaturesNV :: struct {
    sType : StructureType;
    pNext : *void;
    shaderSMBuiltins : Bool32;
}

DrmFormatModifierPropertiesEXT :: struct {
    drmFormatModifier : u64;
    drmFormatModifierPlaneCount : u32;
    drmFormatModifierTilingFeatures : FormatFeatureFlags;
}

DrmFormatModifierPropertiesListEXT :: struct {
    sType : StructureType;
    pNext : *void;
    drmFormatModifierCount : u32;
    pDrmFormatModifierProperties : *DrmFormatModifierPropertiesEXT;
}

PhysicalDeviceImageDrmFormatModifierInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    drmFormatModifier : u64;
    sharingMode : SharingMode;
    queueFamilyIndexCount : u32;
    pQueueFamilyIndices : *u32;
}

ImageDrmFormatModifierListCreateInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    drmFormatModifierCount : u32;
    pDrmFormatModifiers : *u64;
}

ImageDrmFormatModifierExplicitCreateInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    drmFormatModifier : u64;
    drmFormatModifierPlaneCount : u32;
    pPlaneLayouts : *SubresourceLayout;
}

ImageDrmFormatModifierPropertiesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    drmFormatModifier : u64;
}

ValidationCacheEXTT :: struct {}

ValidationCacheCreateInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    flags : ValidationCacheCreateFlagsEXT;
    initialDataSize : u64;
    pInitialData : *void;
}

ShaderModuleValidationCacheCreateInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    validationCache : ValidationCacheEXT;
}

ShadingRatePaletteNV :: struct {
    shadingRatePaletteEntryCount : u32;
    pShadingRatePaletteEntries : *ShadingRatePaletteEntryNV;
}

PipelineViewportShadingRateImageStateCreateInfoNV :: struct {
    sType : StructureType;
    pNext : *void;
    shadingRateImageEnable : Bool32;
    viewportCount : u32;
    pShadingRatePalettes : *ShadingRatePaletteNV;
}

PhysicalDeviceShadingRateImageFeaturesNV :: struct {
    sType : StructureType;
    pNext : *void;
    shadingRateImage : Bool32;
    shadingRateCoarseSampleOrder : Bool32;
}

PhysicalDeviceShadingRateImagePropertiesNV :: struct {
    sType : StructureType;
    pNext : *void;
    shadingRateTexelSize : Extent2D;
    shadingRatePaletteSize : u32;
    shadingRateMaxCoarseSamples : u32;
}

CoarseSampleLocationNV :: struct {
    pixelX : u32;
    pixelY : u32;
    sample : u32;
}

CoarseSampleOrderCustomNV :: struct {
    shadingRate : ShadingRatePaletteEntryNV;
    sampleCount : u32;
    sampleLocationCount : u32;
    pSampleLocations : *CoarseSampleLocationNV;
}

PipelineViewportCoarseSampleOrderStateCreateInfoNV :: struct {
    sType : StructureType;
    pNext : *void;
    sampleOrderType : CoarseSampleOrderTypeNV;
    customSampleOrderCount : u32;
    pCustomSampleOrders : *CoarseSampleOrderCustomNV;
}

AccelerationStructureNVT :: struct {}

RayTracingShaderGroupCreateInfoNV :: struct {
    sType : StructureType;
    pNext : *void;
    type : RayTracingShaderGroupTypeKHR;
    generalShader : u32;
    closestHitShader : u32;
    anyHitShader : u32;
    intersectionShader : u32;
}

RayTracingPipelineCreateInfoNV :: struct {
    sType : StructureType;
    pNext : *void;
    flags : PipelineCreateFlags;
    stageCount : u32;
    pStages : *PipelineShaderStageCreateInfo;
    groupCount : u32;
    pGroups : *RayTracingShaderGroupCreateInfoNV;
    maxRecursionDepth : u32;
    layout : PipelineLayout;
    basePipelineHandle : Pipeline;
    basePipelineIndex : s32;
}

GeometryTrianglesNV :: struct {
    sType : StructureType;
    pNext : *void;
    vertexData : Buffer;
    vertexOffset : DeviceSize;
    vertexCount : u32;
    vertexStride : DeviceSize;
    vertexFormat : Format;
    indexData : Buffer;
    indexOffset : DeviceSize;
    indexCount : u32;
    indexType : IndexType;
    transformData : Buffer;
    transformOffset : DeviceSize;
}

GeometryAABBNV :: struct {
    sType : StructureType;
    pNext : *void;
    aabbData : Buffer;
    numAABBs : u32;
    stride : u32;
    offset : DeviceSize;
}

GeometryDataNV :: struct {
    triangles : GeometryTrianglesNV;
    aabbs : GeometryAABBNV;
}

GeometryNV :: struct {
    sType : StructureType;
    pNext : *void;
    geometryType : GeometryTypeKHR;
    geometry : GeometryDataNV;
    flags : GeometryFlagsKHR;
}

AccelerationStructureInfoNV :: struct {
    sType : StructureType;
    pNext : *void;
    type : AccelerationStructureTypeNV;
    flags : BuildAccelerationStructureFlagsNV;
    instanceCount : u32;
    geometryCount : u32;
    pGeometries : *GeometryNV;
}

AccelerationStructureCreateInfoNV :: struct {
    sType : StructureType;
    pNext : *void;
    compactedSize : DeviceSize;
    info : AccelerationStructureInfoNV;
}

BindAccelerationStructureMemoryInfoNV :: struct {
    sType : StructureType;
    pNext : *void;
    accelerationStructure : AccelerationStructureNV;
    memory : DeviceMemory;
    memoryOffset : DeviceSize;
    deviceIndexCount : u32;
    pDeviceIndices : *u32;
}

WriteDescriptorSetAccelerationStructureNV :: struct {
    sType : StructureType;
    pNext : *void;
    accelerationStructureCount : u32;
    pAccelerationStructures : *AccelerationStructureNV;
}

AccelerationStructureMemoryRequirementsInfoNV :: struct {
    sType : StructureType;
    pNext : *void;
    type : AccelerationStructureMemoryRequirementsTypeNV;
    accelerationStructure : AccelerationStructureNV;
}

PhysicalDeviceRayTracingPropertiesNV :: struct {
    sType : StructureType;
    pNext : *void;
    shaderGroupHandleSize : u32;
    maxRecursionDepth : u32;
    maxShaderGroupStride : u32;
    shaderGroupBaseAlignment : u32;
    maxGeometryCount : u64;
    maxInstanceCount : u64;
    maxTriangleCount : u64;
    maxDescriptorSetAccelerationStructures : u32;
}

TransformMatrixKHR :: struct {
    matrix : [3][4]float32;
}

AabbPositionsKHR :: struct {
    minX : float32;
    minY : float32;
    minZ : float32;
    maxX : float32;
    maxY : float32;
    maxZ : float32;
}

AccelerationStructureInstanceKHR :: struct {
    transform : TransformMatrixKHR;
    instanceCustomIndex24_mask8 : u32; // @note Was bitfields
    instanceShaderBindingTableRecordOffset24_flags8 : u32; // @note Was bitfields
    accelerationStructureReference : u64;
}

PhysicalDeviceRepresentativeFragmentTestFeaturesNV :: struct {
    sType : StructureType;
    pNext : *void;
    representativeFragmentTest : Bool32;
}

PipelineRepresentativeFragmentTestStateCreateInfoNV :: struct {
    sType : StructureType;
    pNext : *void;
    representativeFragmentTestEnable : Bool32;
}

PhysicalDeviceImageViewImageFormatInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    imageViewType : ImageViewType;
}

FilterCubicImageViewImageFormatPropertiesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    filterCubic : Bool32;
    filterCubicMinmax : Bool32;
}

DeviceQueueGlobalPriorityCreateInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    globalPriority : QueueGlobalPriorityEXT;
}

ImportMemoryHostPointerInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    handleType : ExternalMemoryHandleTypeFlagBits;
    pHostPointer : *void;
}

MemoryHostPointerPropertiesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    memoryTypeBits : u32;
}

PhysicalDeviceExternalMemoryHostPropertiesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    minImportedHostPointerAlignment : DeviceSize;
}

PipelineCompilerControlCreateInfoAMD :: struct {
    sType : StructureType;
    pNext : *void;
    compilerControlFlags : PipelineCompilerControlFlagsAMD;
}

CalibratedTimestampInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    timeDomain : TimeDomainEXT;
}

PhysicalDeviceShaderCorePropertiesAMD :: struct {
    sType : StructureType;
    pNext : *void;
    shaderEngineCount : u32;
    shaderArraysPerEngineCount : u32;
    computeUnitsPerShaderArray : u32;
    simdPerComputeUnit : u32;
    wavefrontsPerSimd : u32;
    wavefrontSize : u32;
    sgprsPerSimd : u32;
    minSgprAllocation : u32;
    maxSgprAllocation : u32;
    sgprAllocationGranularity : u32;
    vgprsPerSimd : u32;
    minVgprAllocation : u32;
    maxVgprAllocation : u32;
    vgprAllocationGranularity : u32;
}

DeviceMemoryOverallocationCreateInfoAMD :: struct {
    sType : StructureType;
    pNext : *void;
    overallocationBehavior : MemoryOverallocationBehaviorAMD;
}

PhysicalDeviceVertexAttributeDivisorPropertiesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    maxVertexAttribDivisor : u32;
}

VertexInputBindingDivisorDescriptionEXT :: struct {
    binding : u32;
    divisor : u32;
}

PipelineVertexInputDivisorStateCreateInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    vertexBindingDivisorCount : u32;
    pVertexBindingDivisors : *VertexInputBindingDivisorDescriptionEXT;
}

PhysicalDeviceVertexAttributeDivisorFeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    vertexAttributeInstanceRateDivisor : Bool32;
    vertexAttributeInstanceRateZeroDivisor : Bool32;
}

PipelineCreationFeedbackEXT :: struct {
    flags : PipelineCreationFeedbackFlagsEXT;
    duration : u64;
}

PipelineCreationFeedbackCreateInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    pPipelineCreationFeedback : *PipelineCreationFeedbackEXT;
    pipelineStageCreationFeedbackCount : u32;
    pPipelineStageCreationFeedbacks : *PipelineCreationFeedbackEXT;
}

PhysicalDeviceComputeShaderDerivativesFeaturesNV :: struct {
    sType : StructureType;
    pNext : *void;
    computeDerivativeGroupQuads : Bool32;
    computeDerivativeGroupLinear : Bool32;
}

PhysicalDeviceMeshShaderFeaturesNV :: struct {
    sType : StructureType;
    pNext : *void;
    taskShader : Bool32;
    meshShader : Bool32;
}

PhysicalDeviceMeshShaderPropertiesNV :: struct {
    sType : StructureType;
    pNext : *void;
    maxDrawMeshTasksCount : u32;
    maxTaskWorkGroupInvocations : u32;
    maxTaskWorkGroupSize : [3]u32;
    maxTaskTotalMemorySize : u32;
    maxTaskOutputCount : u32;
    maxMeshWorkGroupInvocations : u32;
    maxMeshWorkGroupSize : [3]u32;
    maxMeshTotalMemorySize : u32;
    maxMeshOutputVertices : u32;
    maxMeshOutputPrimitives : u32;
    maxMeshMultiviewViewCount : u32;
    meshOutputPerVertexGranularity : u32;
    meshOutputPerPrimitiveGranularity : u32;
}

DrawMeshTasksIndirectCommandNV :: struct {
    taskCount : u32;
    firstTask : u32;
}

PhysicalDeviceFragmentShaderBarycentricFeaturesNV :: struct {
    sType : StructureType;
    pNext : *void;
    fragmentShaderBarycentric : Bool32;
}

PhysicalDeviceShaderImageFootprintFeaturesNV :: struct {
    sType : StructureType;
    pNext : *void;
    imageFootprint : Bool32;
}

PipelineViewportExclusiveScissorStateCreateInfoNV :: struct {
    sType : StructureType;
    pNext : *void;
    exclusiveScissorCount : u32;
    pExclusiveScissors : *Rect2D;
}

PhysicalDeviceExclusiveScissorFeaturesNV :: struct {
    sType : StructureType;
    pNext : *void;
    exclusiveScissor : Bool32;
}

QueueFamilyCheckpointPropertiesNV :: struct {
    sType : StructureType;
    pNext : *void;
    checkpointExecutionStageMask : PipelineStageFlags;
}

CheckpointDataNV :: struct {
    sType : StructureType;
    pNext : *void;
    stage : PipelineStageFlagBits;
    pCheckpointMarker : *void;
}

PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL :: struct {
    sType : StructureType;
    pNext : *void;
    shaderIntegerFunctions2 : Bool32;
}

PerformanceConfigurationINTELT :: struct {}

PerformanceValueINTEL :: struct {
    type : PerformanceValueTypeINTEL;
    data : PerformanceValueDataINTEL;
}

InitializePerformanceApiInfoINTEL :: struct {
    sType : StructureType;
    pNext : *void;
    pUserData : *void;
}

QueryPoolPerformanceQueryCreateInfoINTEL :: struct {
    sType : StructureType;
    pNext : *void;
    performanceCountersSampling : QueryPoolSamplingModeINTEL;
}

PerformanceMarkerInfoINTEL :: struct {
    sType : StructureType;
    pNext : *void;
    marker : u64;
}

PerformanceStreamMarkerInfoINTEL :: struct {
    sType : StructureType;
    pNext : *void;
    marker : u32;
}

PerformanceOverrideInfoINTEL :: struct {
    sType : StructureType;
    pNext : *void;
    type : PerformanceOverrideTypeINTEL;
    enable : Bool32;
    parameter : u64;
}

PerformanceConfigurationAcquireInfoINTEL :: struct {
    sType : StructureType;
    pNext : *void;
    type : PerformanceConfigurationTypeINTEL;
}

PhysicalDevicePCIBusInfoPropertiesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    pciDomain : u32;
    pciBus : u32;
    pciDevice : u32;
    pciFunction : u32;
}

DisplayNativeHdrSurfaceCapabilitiesAMD :: struct {
    sType : StructureType;
    pNext : *void;
    localDimmingSupport : Bool32;
}

SwapchainDisplayNativeHdrCreateInfoAMD :: struct {
    sType : StructureType;
    pNext : *void;
    localDimmingEnable : Bool32;
}

PhysicalDeviceFragmentDensityMapFeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    fragmentDensityMap : Bool32;
    fragmentDensityMapDynamic : Bool32;
    fragmentDensityMapNonSubsampledImages : Bool32;
}

PhysicalDeviceFragmentDensityMapPropertiesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    minFragmentDensityTexelSize : Extent2D;
    maxFragmentDensityTexelSize : Extent2D;
    fragmentDensityInvocations : Bool32;
}

RenderPassFragmentDensityMapCreateInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    fragmentDensityMapAttachment : AttachmentReference;
}

PhysicalDeviceSubgroupSizeControlFeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    subgroupSizeControl : Bool32;
    computeFullSubgroups : Bool32;
}

PhysicalDeviceSubgroupSizeControlPropertiesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    minSubgroupSize : u32;
    maxSubgroupSize : u32;
    maxComputeWorkgroupSubgroups : u32;
    requiredSubgroupSizeStages : ShaderStageFlags;
}

PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    requiredSubgroupSize : u32;
}

PhysicalDeviceShaderCoreProperties2AMD :: struct {
    sType : StructureType;
    pNext : *void;
    shaderCoreFeatures : ShaderCorePropertiesFlagsAMD;
    activeComputeUnitCount : u32;
}

PhysicalDeviceCoherentMemoryFeaturesAMD :: struct {
    sType : StructureType;
    pNext : *void;
    deviceCoherentMemory : Bool32;
}

PhysicalDeviceShaderImageAtomicInt64FeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    shaderImageInt64Atomics : Bool32;
    sparseImageInt64Atomics : Bool32;
}

PhysicalDeviceMemoryBudgetPropertiesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    heapBudget : [16]DeviceSize;
    heapUsage : [16]DeviceSize;
}

PhysicalDeviceMemoryPriorityFeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    memoryPriority : Bool32;
}

MemoryPriorityAllocateInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    priority : float32;
}

PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV :: struct {
    sType : StructureType;
    pNext : *void;
    dedicatedAllocationImageAliasing : Bool32;
}

PhysicalDeviceBufferDeviceAddressFeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    bufferDeviceAddress : Bool32;
    bufferDeviceAddressCaptureReplay : Bool32;
    bufferDeviceAddressMultiDevice : Bool32;
}

BufferDeviceAddressCreateInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    deviceAddress : DeviceAddress;
}

PhysicalDeviceToolPropertiesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    name : [256]u8;
    version : [256]u8;
    purposes : ToolPurposeFlagsEXT;
    description : [256]u8;
    layer : [256]u8;
}

ValidationFeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    enabledValidationFeatureCount : u32;
    pEnabledValidationFeatures : *ValidationFeatureEnableEXT;
    disabledValidationFeatureCount : u32;
    pDisabledValidationFeatures : *ValidationFeatureDisableEXT;
}

CooperativeMatrixPropertiesNV :: struct {
    sType : StructureType;
    pNext : *void;
    MSize : u32;
    NSize : u32;
    KSize : u32;
    AType : ComponentTypeNV;
    BType : ComponentTypeNV;
    CType : ComponentTypeNV;
    DType : ComponentTypeNV;
    scope : ScopeNV;
}

PhysicalDeviceCooperativeMatrixFeaturesNV :: struct {
    sType : StructureType;
    pNext : *void;
    cooperativeMatrix : Bool32;
    cooperativeMatrixRobustBufferAccess : Bool32;
}

PhysicalDeviceCooperativeMatrixPropertiesNV :: struct {
    sType : StructureType;
    pNext : *void;
    cooperativeMatrixSupportedStages : ShaderStageFlags;
}

PhysicalDeviceCoverageReductionModeFeaturesNV :: struct {
    sType : StructureType;
    pNext : *void;
    coverageReductionMode : Bool32;
}

PipelineCoverageReductionStateCreateInfoNV :: struct {
    sType : StructureType;
    pNext : *void;
    flags : PipelineCoverageReductionStateCreateFlagsNV;
    coverageReductionMode : CoverageReductionModeNV;
}

FramebufferMixedSamplesCombinationNV :: struct {
    sType : StructureType;
    pNext : *void;
    coverageReductionMode : CoverageReductionModeNV;
    rasterizationSamples : SampleCountFlagBits;
    depthStencilSamples : SampleCountFlags;
    colorSamples : SampleCountFlags;
}

PhysicalDeviceFragmentShaderInterlockFeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    fragmentShaderSampleInterlock : Bool32;
    fragmentShaderPixelInterlock : Bool32;
    fragmentShaderShadingRateInterlock : Bool32;
}

PhysicalDeviceYcbcrImageArraysFeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    ycbcrImageArrays : Bool32;
}

HeadlessSurfaceCreateInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    flags : HeadlessSurfaceCreateFlagsEXT;
}

PhysicalDeviceLineRasterizationFeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    rectangularLines : Bool32;
    bresenhamLines : Bool32;
    smoothLines : Bool32;
    stippledRectangularLines : Bool32;
    stippledBresenhamLines : Bool32;
    stippledSmoothLines : Bool32;
}

PhysicalDeviceLineRasterizationPropertiesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    lineSubPixelPrecisionBits : u32;
}

PipelineRasterizationLineStateCreateInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    lineRasterizationMode : LineRasterizationModeEXT;
    stippledLineEnable : Bool32;
    lineStippleFactor : u32;
    lineStipplePattern : u16;
}

PhysicalDeviceShaderAtomicFloatFeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    shaderBufferFloat32Atomics : Bool32;
    shaderBufferFloat32AtomicAdd : Bool32;
    shaderBufferFloat64Atomics : Bool32;
    shaderBufferFloat64AtomicAdd : Bool32;
    shaderSharedFloat32Atomics : Bool32;
    shaderSharedFloat32AtomicAdd : Bool32;
    shaderSharedFloat64Atomics : Bool32;
    shaderSharedFloat64AtomicAdd : Bool32;
    shaderImageFloat32Atomics : Bool32;
    shaderImageFloat32AtomicAdd : Bool32;
    sparseImageFloat32Atomics : Bool32;
    sparseImageFloat32AtomicAdd : Bool32;
}

PhysicalDeviceIndexTypeUint8FeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    indexTypeUint8 : Bool32;
}

PhysicalDeviceExtendedDynamicStateFeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    extendedDynamicState : Bool32;
}

PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    shaderDemoteToHelperInvocation : Bool32;
}

IndirectCommandsLayoutNVT :: struct {}

PhysicalDeviceDeviceGeneratedCommandsPropertiesNV :: struct {
    sType : StructureType;
    pNext : *void;
    maxGraphicsShaderGroupCount : u32;
    maxIndirectSequenceCount : u32;
    maxIndirectCommandsTokenCount : u32;
    maxIndirectCommandsStreamCount : u32;
    maxIndirectCommandsTokenOffset : u32;
    maxIndirectCommandsStreamStride : u32;
    minSequencesCountBufferOffsetAlignment : u32;
    minSequencesIndexBufferOffsetAlignment : u32;
    minIndirectCommandsBufferOffsetAlignment : u32;
}

PhysicalDeviceDeviceGeneratedCommandsFeaturesNV :: struct {
    sType : StructureType;
    pNext : *void;
    deviceGeneratedCommands : Bool32;
}

GraphicsShaderGroupCreateInfoNV :: struct {
    sType : StructureType;
    pNext : *void;
    stageCount : u32;
    pStages : *PipelineShaderStageCreateInfo;
    pVertexInputState : *PipelineVertexInputStateCreateInfo;
    pTessellationState : *PipelineTessellationStateCreateInfo;
}

GraphicsPipelineShaderGroupsCreateInfoNV :: struct {
    sType : StructureType;
    pNext : *void;
    groupCount : u32;
    pGroups : *GraphicsShaderGroupCreateInfoNV;
    pipelineCount : u32;
    pPipelines : *Pipeline;
}

BindShaderGroupIndirectCommandNV :: struct {
    groupIndex : u32;
}

BindIndexBufferIndirectCommandNV :: struct {
    bufferAddress : DeviceAddress;
    size : u32;
    indexType : IndexType;
}

BindVertexBufferIndirectCommandNV :: struct {
    bufferAddress : DeviceAddress;
    size : u32;
    stride : u32;
}

SetStateFlagsIndirectCommandNV :: struct {
    data : u32;
}

IndirectCommandsStreamNV :: struct {
    buffer : Buffer;
    offset : DeviceSize;
}

IndirectCommandsLayoutTokenNV :: struct {
    sType : StructureType;
    pNext : *void;
    tokenType : IndirectCommandsTokenTypeNV;
    stream : u32;
    offset : u32;
    vertexBindingUnit : u32;
    vertexDynamicStride : Bool32;
    pushconstantPipelineLayout : PipelineLayout;
    pushconstantShaderStageFlags : ShaderStageFlags;
    pushconstantOffset : u32;
    pushconstantSize : u32;
    indirectStateFlags : IndirectStateFlagsNV;
    indexTypeCount : u32;
    pIndexTypes : *IndexType;
    pIndexTypeValues : *u32;
}

IndirectCommandsLayoutCreateInfoNV :: struct {
    sType : StructureType;
    pNext : *void;
    flags : IndirectCommandsLayoutUsageFlagsNV;
    pipelineBindPoint : PipelineBindPoint;
    tokenCount : u32;
    pTokens : *IndirectCommandsLayoutTokenNV;
    streamCount : u32;
    pStreamStrides : *u32;
}

GeneratedCommandsInfoNV :: struct {
    sType : StructureType;
    pNext : *void;
    pipelineBindPoint : PipelineBindPoint;
    pipeline : Pipeline;
    indirectCommandsLayout : IndirectCommandsLayoutNV;
    streamCount : u32;
    pStreams : *IndirectCommandsStreamNV;
    sequencesCount : u32;
    preprocessBuffer : Buffer;
    preprocessOffset : DeviceSize;
    preprocessSize : DeviceSize;
    sequencesCountBuffer : Buffer;
    sequencesCountOffset : DeviceSize;
    sequencesIndexBuffer : Buffer;
    sequencesIndexOffset : DeviceSize;
}

GeneratedCommandsMemoryRequirementsInfoNV :: struct {
    sType : StructureType;
    pNext : *void;
    pipelineBindPoint : PipelineBindPoint;
    pipeline : Pipeline;
    indirectCommandsLayout : IndirectCommandsLayoutNV;
    maxSequencesCount : u32;
}

PhysicalDeviceTexelBufferAlignmentFeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    texelBufferAlignment : Bool32;
}

PhysicalDeviceTexelBufferAlignmentPropertiesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    storageTexelBufferOffsetAlignmentBytes : DeviceSize;
    storageTexelBufferOffsetSingleTexelAlignment : Bool32;
    uniformTexelBufferOffsetAlignmentBytes : DeviceSize;
    uniformTexelBufferOffsetSingleTexelAlignment : Bool32;
}

RenderPassTransformBeginInfoQCOM :: struct {
    sType : StructureType;
    pNext : *void;
    transform : SurfaceTransformFlagBitsKHR;
}

CommandBufferInheritanceRenderPassTransformInfoQCOM :: struct {
    sType : StructureType;
    pNext : *void;
    transform : SurfaceTransformFlagBitsKHR;
    renderArea : Rect2D;
}

PhysicalDeviceDeviceMemoryReportFeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    deviceMemoryReport : Bool32;
}

DeviceMemoryReportCallbackDataEXT :: struct {
    sType : StructureType;
    pNext : *void;
    flags : DeviceMemoryReportFlagsEXT;
    type : DeviceMemoryReportEventTypeEXT;
    memoryObjectId : u64;
    size : DeviceSize;
    objectType : ObjectType;
    objectHandle : u64;
    heapIndex : u32;
}

DeviceDeviceMemoryReportCreateInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    flags : DeviceMemoryReportFlagsEXT;
    pfnUserCallback : PFN_DeviceMemoryReportCallbackEXT;
    pUserData : *void;
}

PhysicalDeviceRobustness2FeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    robustBufferAccess2 : Bool32;
    robustImageAccess2 : Bool32;
    nullDescriptor : Bool32;
}

PhysicalDeviceRobustness2PropertiesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    robustStorageBufferAccessSizeAlignment : DeviceSize;
    robustUniformBufferAccessSizeAlignment : DeviceSize;
}

SamplerCustomBorderColorCreateInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    customBorderColor : ClearColorValue;
    format : Format;
}

PhysicalDeviceCustomBorderColorPropertiesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    maxCustomBorderColorSamplers : u32;
}

PhysicalDeviceCustomBorderColorFeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    customBorderColors : Bool32;
    customBorderColorWithoutFormat : Bool32;
}

PrivateDataSlotEXTT :: struct {}

PhysicalDevicePrivateDataFeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    privateData : Bool32;
}

DevicePrivateDataCreateInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    privateDataSlotRequestCount : u32;
}

PrivateDataSlotCreateInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    flags : PrivateDataSlotCreateFlagsEXT;
}

PhysicalDevicePipelineCreationCacheControlFeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    pipelineCreationCacheControl : Bool32;
}

PhysicalDeviceDiagnosticsConfigFeaturesNV :: struct {
    sType : StructureType;
    pNext : *void;
    diagnosticsConfig : Bool32;
}

DeviceDiagnosticsConfigCreateInfoNV :: struct {
    sType : StructureType;
    pNext : *void;
    flags : DeviceDiagnosticsConfigFlagsNV;
}

PhysicalDeviceFragmentShadingRateEnumsFeaturesNV :: struct {
    sType : StructureType;
    pNext : *void;
    fragmentShadingRateEnums : Bool32;
    supersampleFragmentShadingRates : Bool32;
    noInvocationFragmentShadingRates : Bool32;
}

PhysicalDeviceFragmentShadingRateEnumsPropertiesNV :: struct {
    sType : StructureType;
    pNext : *void;
    maxFragmentShadingRateInvocationCount : SampleCountFlagBits;
}

PipelineFragmentShadingRateEnumStateCreateInfoNV :: struct {
    sType : StructureType;
    pNext : *void;
    shadingRateType : FragmentShadingRateTypeNV;
    shadingRate : FragmentShadingRateNV;
    combinerOps : [2]FragmentShadingRateCombinerOpKHR;
}

PhysicalDeviceFragmentDensityMap2FeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    fragmentDensityMapDeferred : Bool32;
}

PhysicalDeviceFragmentDensityMap2PropertiesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    subsampledLoads : Bool32;
    subsampledCoarseReconstructionEarlyAccess : Bool32;
    maxSubsampledArrayLayers : u32;
    maxDescriptorSetSubsampledSamplers : u32;
}

CopyCommandTransformInfoQCOM :: struct {
    sType : StructureType;
    pNext : *void;
    transform : SurfaceTransformFlagBitsKHR;
}

PhysicalDeviceImageRobustnessFeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    robustImageAccess : Bool32;
}

PhysicalDevice4444FormatsFeaturesEXT :: struct {
    sType : StructureType;
    pNext : *void;
    formatA4R4G4B4 : Bool32;
    formatA4B4G4R4 : Bool32;
}

AccelerationStructureKHRT :: struct {}

AccelerationStructureBuildRangeInfoKHR :: struct {
    primitiveCount : u32;
    primitiveOffset : u32;
    firstVertex : u32;
    transformOffset : u32;
}

AccelerationStructureGeometryTrianglesDataKHR :: struct {
    sType : StructureType;
    pNext : *void;
    vertexFormat : Format;
    vertexData : DeviceOrHostAddressConstKHR;
    vertexStride : DeviceSize;
    maxVertex : u32;
    indexType : IndexType;
    indexData : DeviceOrHostAddressConstKHR;
    transformData : DeviceOrHostAddressConstKHR;
}

AccelerationStructureGeometryAabbsDataKHR :: struct {
    sType : StructureType;
    pNext : *void;
    data : DeviceOrHostAddressConstKHR;
    stride : DeviceSize;
}

AccelerationStructureGeometryInstancesDataKHR :: struct {
    sType : StructureType;
    pNext : *void;
    arrayOfPointers : Bool32;
    data : DeviceOrHostAddressConstKHR;
}

AccelerationStructureGeometryKHR :: struct {
    sType : StructureType;
    pNext : *void;
    geometryType : GeometryTypeKHR;
    geometry : AccelerationStructureGeometryDataKHR;
    flags : GeometryFlagsKHR;
}

AccelerationStructureBuildGeometryInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    type : AccelerationStructureTypeKHR;
    flags : BuildAccelerationStructureFlagsKHR;
    mode : BuildAccelerationStructureModeKHR;
    srcAccelerationStructure : AccelerationStructureKHR;
    dstAccelerationStructure : AccelerationStructureKHR;
    geometryCount : u32;
    pGeometries : *AccelerationStructureGeometryKHR;
    ppGeometries : **AccelerationStructureGeometryKHR;
    scratchData : DeviceOrHostAddressKHR;
}

AccelerationStructureCreateInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    createFlags : AccelerationStructureCreateFlagsKHR;
    buffer : Buffer;
    offset : DeviceSize;
    size : DeviceSize;
    type : AccelerationStructureTypeKHR;
    deviceAddress : DeviceAddress;
}

WriteDescriptorSetAccelerationStructureKHR :: struct {
    sType : StructureType;
    pNext : *void;
    accelerationStructureCount : u32;
    pAccelerationStructures : *AccelerationStructureKHR;
}

PhysicalDeviceAccelerationStructureFeaturesKHR :: struct {
    sType : StructureType;
    pNext : *void;
    accelerationStructure : Bool32;
    accelerationStructureCaptureReplay : Bool32;
    accelerationStructureIndirectBuild : Bool32;
    accelerationStructureHostCommands : Bool32;
    descriptorBindingAccelerationStructureUpdateAfterBind : Bool32;
}

PhysicalDeviceAccelerationStructurePropertiesKHR :: struct {
    sType : StructureType;
    pNext : *void;
    maxGeometryCount : u64;
    maxInstanceCount : u64;
    maxPrimitiveCount : u64;
    maxPerStageDescriptorAccelerationStructures : u32;
    maxPerStageDescriptorUpdateAfterBindAccelerationStructures : u32;
    maxDescriptorSetAccelerationStructures : u32;
    maxDescriptorSetUpdateAfterBindAccelerationStructures : u32;
    minAccelerationStructureScratchOffsetAlignment : u32;
}

AccelerationStructureDeviceAddressInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    accelerationStructure : AccelerationStructureKHR;
}

AccelerationStructureVersionInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    pVersionData : *u8;
}

CopyAccelerationStructureToMemoryInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    src : AccelerationStructureKHR;
    dst : DeviceOrHostAddressKHR;
    mode : CopyAccelerationStructureModeKHR;
}

CopyMemoryToAccelerationStructureInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    src : DeviceOrHostAddressConstKHR;
    dst : AccelerationStructureKHR;
    mode : CopyAccelerationStructureModeKHR;
}

CopyAccelerationStructureInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    src : AccelerationStructureKHR;
    dst : AccelerationStructureKHR;
    mode : CopyAccelerationStructureModeKHR;
}

AccelerationStructureBuildSizesInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    accelerationStructureSize : DeviceSize;
    updateScratchSize : DeviceSize;
    buildScratchSize : DeviceSize;
}

RayTracingShaderGroupCreateInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    type : RayTracingShaderGroupTypeKHR;
    generalShader : u32;
    closestHitShader : u32;
    anyHitShader : u32;
    intersectionShader : u32;
    pShaderGroupCaptureReplayHandle : *void;
}

RayTracingPipelineInterfaceCreateInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    maxPipelineRayPayloadSize : u32;
    maxPipelineRayHitAttributeSize : u32;
}

RayTracingPipelineCreateInfoKHR :: struct {
    sType : StructureType;
    pNext : *void;
    flags : PipelineCreateFlags;
    stageCount : u32;
    pStages : *PipelineShaderStageCreateInfo;
    groupCount : u32;
    pGroups : *RayTracingShaderGroupCreateInfoKHR;
    maxPipelineRayRecursionDepth : u32;
    pLibraryInfo : *PipelineLibraryCreateInfoKHR;
    pLibraryInterface : *RayTracingPipelineInterfaceCreateInfoKHR;
    pDynamicState : *PipelineDynamicStateCreateInfo;
    layout : PipelineLayout;
    basePipelineHandle : Pipeline;
    basePipelineIndex : s32;
}

PhysicalDeviceRayTracingPipelineFeaturesKHR :: struct {
    sType : StructureType;
    pNext : *void;
    rayTracingPipeline : Bool32;
    rayTracingPipelineShaderGroupHandleCaptureReplay : Bool32;
    rayTracingPipelineShaderGroupHandleCaptureReplayMixed : Bool32;
    rayTracingPipelineTraceRaysIndirect : Bool32;
    rayTraversalPrimitiveCulling : Bool32;
}

PhysicalDeviceRayTracingPipelinePropertiesKHR :: struct {
    sType : StructureType;
    pNext : *void;
    shaderGroupHandleSize : u32;
    maxRayRecursionDepth : u32;
    maxShaderGroupStride : u32;
    shaderGroupBaseAlignment : u32;
    shaderGroupHandleCaptureReplaySize : u32;
    maxRayDispatchInvocationCount : u32;
    shaderGroupHandleAlignment : u32;
    maxRayHitAttributeSize : u32;
}

StridedDeviceAddressRegionKHR :: struct {
    deviceAddress : DeviceAddress;
    stride : DeviceSize;
    size : DeviceSize;
}

TraceRaysIndirectCommandKHR :: struct {
    width : u32;
    height : u32;
    depth : u32;
}

PhysicalDeviceRayQueryFeaturesKHR :: struct {
    sType : StructureType;
    pNext : *void;
    rayQuery : Bool32;
}

DescriptorBufferBindingInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    address : DeviceAddress;
    usage : BufferUsageFlags;
}

DescriptorAddressInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    address : DeviceAddress;
    range : DeviceSize;
    format : Format;
}

DescriptorDataEXT :: union {
    pSampler : *Sampler;
    pCombinedImageSampler : *DescriptorImageInfo;
    pInputAttachmentImage : *DescriptorImageInfo;
    pSampledImage : *DescriptorImageInfo;
    pStorageImage : *DescriptorImageInfo;
    pUniformTexelBuffer : *DescriptorAddressInfoEXT;
    pStorageTexelBuffer : *DescriptorAddressInfoEXT;
    pUniformBuffer : *DescriptorAddressInfoEXT;
    pStorageBuffer : *DescriptorAddressInfoEXT;
    accelerationStructure : DeviceAddress;
}

DescriptorGetInfoEXT :: struct {
    sType : StructureType;
    pNext : *void;
    type : DescriptorType;
    data : DescriptorDataEXT;
}

ClearColorValue :: union {
    _float32 : [4]float32;
    int32 : [4]s32;
    uint32 : [4]u32;
}

ClearValue :: union {
    color : ClearColorValue;
    depthStencil : ClearDepthStencilValue;
}

PerformanceCounterResultKHR :: union {
    int32 : s32;
    int64 : s64;
    uint32 : u32;
    uint64 : u64;
    _float32 : float32;
    _float64 : float64;
}

PipelineExecutableStatisticValueKHR :: union {
    b32 : Bool32;
    i64 : s64;
    _u64 : u64;
    f64 : float64;
}

PerformanceValueDataINTEL :: union {
    value32 : u32;
    value64 : u64;
    valueFloat : float32;
    valueBool : Bool32;
    valueString : *u8;
}

DeviceOrHostAddressKHR :: union {
    deviceAddress : DeviceAddress;
    hostAddress : *void;
}

DeviceOrHostAddressConstKHR :: union {
    deviceAddress : DeviceAddress;
    hostAddress : *void;
}

AccelerationStructureGeometryDataKHR :: union {
    triangles : AccelerationStructureGeometryTrianglesDataKHR;
    aabbs : AccelerationStructureGeometryAabbsDataKHR;
    instances : AccelerationStructureGeometryInstancesDataKHR;
}

create_instance :: (
    pCreateInfo : *InstanceCreateInfo,
    pAllocator : *AllocationCallbacks,
    pInstance : *Instance
) -> Result #foreign libvulkan "vkCreateInstance";

destroy_instance :: (
    instance : Instance,
    pAllocator : *AllocationCallbacks
) -> void #foreign libvulkan "vkDestroyInstance";

enumerate_physical_devices :: (
    instance : Instance,
    pPhysicalDeviceCount : *u32,
    pPhysicalDevices : *PhysicalDevice
) -> Result #foreign libvulkan "vkEnumeratePhysicalDevices";

get_physical_device_features :: (
    physicalDevice : PhysicalDevice,
    pFeatures : *PhysicalDeviceFeatures
) -> void #foreign libvulkan "vkGetPhysicalDeviceFeatures";

get_physical_device_format_properties :: (
    physicalDevice : PhysicalDevice,
    format : Format,
    pFormatProperties : *FormatProperties
) -> void #foreign libvulkan "vkGetPhysicalDeviceFormatProperties";

get_physical_device_image_format_properties :: (
    physicalDevice : PhysicalDevice,
    format : Format,
    type : ImageType,
    tiling : ImageTiling,
    usage : ImageUsageFlags,
    flags : ImageCreateFlags,
    pImageFormatProperties : *ImageFormatProperties
) -> Result #foreign libvulkan "vkGetPhysicalDeviceImageFormatProperties";

get_physical_device_properties :: (
    physicalDevice : PhysicalDevice,
    pProperties : *PhysicalDeviceProperties
) -> void #foreign libvulkan "vkGetPhysicalDeviceProperties";

get_physical_device_queue_family_properties :: (
    physicalDevice : PhysicalDevice,
    pQueueFamilyPropertyCount : *u32,
    pQueueFamilyProperties : *QueueFamilyProperties
) -> void #foreign libvulkan "vkGetPhysicalDeviceQueueFamilyProperties";

get_physical_device_memory_properties :: (
    physicalDevice : PhysicalDevice,
    pMemoryProperties : *PhysicalDeviceMemoryProperties
) -> void #foreign libvulkan "vkGetPhysicalDeviceMemoryProperties";

get_instance_proc_addr :: (
    instance : Instance,
    pName : *u8
) -> PFN_VoidFunction #foreign libvulkan "vkGetInstanceProcAddr";

get_device_proc_addr :: (
    device : Device,
    pName : *u8
) -> PFN_VoidFunction #foreign libvulkan "vkGetDeviceProcAddr";

create_device :: (
    physicalDevice : PhysicalDevice,
    pCreateInfo : *DeviceCreateInfo,
    pAllocator : *AllocationCallbacks,
    pDevice : *Device
) -> Result #foreign libvulkan "vkCreateDevice";

destroy_device :: (
    device : Device,
    pAllocator : *AllocationCallbacks
) -> void #foreign libvulkan "vkDestroyDevice";

enumerate_instance_extension_properties :: (
    pLayerName : *u8,
    pPropertyCount : *u32,
    pProperties : *ExtensionProperties
) -> Result #foreign libvulkan "vkEnumerateInstanceExtensionProperties";

enumerate_device_extension_properties :: (
    physicalDevice : PhysicalDevice,
    pLayerName : *u8,
    pPropertyCount : *u32,
    pProperties : *ExtensionProperties
) -> Result #foreign libvulkan "vkEnumerateDeviceExtensionProperties";

enumerate_instance_layer_properties :: (
    pPropertyCount : *u32,
    pProperties : *LayerProperties
) -> Result #foreign libvulkan "vkEnumerateInstanceLayerProperties";

enumerate_device_layer_properties :: (
    physicalDevice : PhysicalDevice,
    pPropertyCount : *u32,
    pProperties : *LayerProperties
) -> Result #foreign libvulkan "vkEnumerateDeviceLayerProperties";

get_device_queue :: (
    device : Device,
    queueFamilyIndex : u32,
    queueIndex : u32,
    pQueue : *Queue
) -> void #foreign libvulkan "vkGetDeviceQueue";

queue_submit :: (
    queue : Queue,
    submitCount : u32,
    pSubmits : *SubmitInfo,
    fence : Fence
) -> Result #foreign libvulkan "vkQueueSubmit";

queue_wait_idle :: (queue : Queue) -> Result #foreign libvulkan "vkQueueWaitIdle";

device_wait_idle :: (device : Device) -> Result #foreign libvulkan "vkDeviceWaitIdle";

allocate_memory :: (
    device : Device,
    pAllocateInfo : *MemoryAllocateInfo,
    pAllocator : *AllocationCallbacks,
    pMemory : *DeviceMemory
) -> Result #foreign libvulkan "vkAllocateMemory";

free_memory :: (
    device : Device,
    memory : DeviceMemory,
    pAllocator : *AllocationCallbacks
) -> void #foreign libvulkan "vkFreeMemory";

map_memory :: (
    device : Device,
    memory : DeviceMemory,
    offset : DeviceSize,
    size : DeviceSize,
    flags : MemoryMapFlags,
    ppData : **void
) -> Result #foreign libvulkan "vkMapMemory";

unmap_memory :: (
    device : Device,
    memory : DeviceMemory
) -> void #foreign libvulkan "vkUnmapMemory";

flush_mapped_memory_ranges :: (
    device : Device,
    memoryRangeCount : u32,
    pMemoryRanges : *MappedMemoryRange
) -> Result #foreign libvulkan "vkFlushMappedMemoryRanges";

invalidate_mapped_memory_ranges :: (
    device : Device,
    memoryRangeCount : u32,
    pMemoryRanges : *MappedMemoryRange
) -> Result #foreign libvulkan "vkInvalidateMappedMemoryRanges";

get_device_memory_commitment :: (
    device : Device,
    memory : DeviceMemory,
    pCommittedMemoryInBytes : *DeviceSize
) -> void #foreign libvulkan "vkGetDeviceMemoryCommitment";

bind_buffer_memory :: (
    device : Device,
    buffer : Buffer,
    memory : DeviceMemory,
    memoryOffset : DeviceSize
) -> Result #foreign libvulkan "vkBindBufferMemory";

bind_image_memory :: (
    device : Device,
    image : Image,
    memory : DeviceMemory,
    memoryOffset : DeviceSize
) -> Result #foreign libvulkan "vkBindImageMemory";

get_buffer_memory_requirements :: (
    device : Device,
    buffer : Buffer,
    pMemoryRequirements : *MemoryRequirements
) -> void #foreign libvulkan "vkGetBufferMemoryRequirements";

get_image_memory_requirements :: (
    device : Device,
    image : Image,
    pMemoryRequirements : *MemoryRequirements
) -> void #foreign libvulkan "vkGetImageMemoryRequirements";

get_image_sparse_memory_requirements :: (
    device : Device,
    image : Image,
    pSparseMemoryRequirementCount : *u32,
    pSparseMemoryRequirements : *SparseImageMemoryRequirements
) -> void #foreign libvulkan "vkGetImageSparseMemoryRequirements";

get_physical_device_sparse_image_format_properties :: (
    physicalDevice : PhysicalDevice,
    format : Format,
    type : ImageType,
    samples : SampleCountFlagBits,
    usage : ImageUsageFlags,
    tiling : ImageTiling,
    pPropertyCount : *u32,
    pProperties : *SparseImageFormatProperties
) -> void #foreign libvulkan "vkGetPhysicalDeviceSparseImageFormatProperties";

queue_bind_sparse :: (
    queue : Queue,
    bindInfoCount : u32,
    pBindInfo : *BindSparseInfo,
    fence : Fence
) -> Result #foreign libvulkan "vkQueueBindSparse";

create_fence :: (
    device : Device,
    pCreateInfo : *FenceCreateInfo,
    pAllocator : *AllocationCallbacks,
    pFence : *Fence
) -> Result #foreign libvulkan "vkCreateFence";

destroy_fence :: (
    device : Device,
    fence : Fence,
    pAllocator : *AllocationCallbacks
) -> void #foreign libvulkan "vkDestroyFence";

reset_fences :: (
    device : Device,
    fenceCount : u32,
    pFences : *Fence
) -> Result #foreign libvulkan "vkResetFences";

get_fence_status :: (
    device : Device,
    fence : Fence
) -> Result #foreign libvulkan "vkGetFenceStatus";

wait_for_fences :: (
    device : Device,
    fenceCount : u32,
    pFences : *Fence,
    waitAll : Bool32,
    timeout : u64
) -> Result #foreign libvulkan "vkWaitForFences";

create_semaphore :: (
    device : Device,
    pCreateInfo : *SemaphoreCreateInfo,
    pAllocator : *AllocationCallbacks,
    pSemaphore : *Semaphore
) -> Result #foreign libvulkan "vkCreateSemaphore";

destroy_semaphore :: (
    device : Device,
    semaphore : Semaphore,
    pAllocator : *AllocationCallbacks
) -> void #foreign libvulkan "vkDestroySemaphore";

create_event :: (
    device : Device,
    pCreateInfo : *EventCreateInfo,
    pAllocator : *AllocationCallbacks,
    pEvent : *Event
) -> Result #foreign libvulkan "vkCreateEvent";

destroy_event :: (
    device : Device,
    event : Event,
    pAllocator : *AllocationCallbacks
) -> void #foreign libvulkan "vkDestroyEvent";

get_event_status :: (
    device : Device,
    event : Event
) -> Result #foreign libvulkan "vkGetEventStatus";

set_event :: (
    device : Device,
    event : Event
) -> Result #foreign libvulkan "vkSetEvent";

reset_event :: (
    device : Device,
    event : Event
) -> Result #foreign libvulkan "vkResetEvent";

create_query_pool :: (
    device : Device,
    pCreateInfo : *QueryPoolCreateInfo,
    pAllocator : *AllocationCallbacks,
    pQueryPool : *QueryPool
) -> Result #foreign libvulkan "vkCreateQueryPool";

destroy_query_pool :: (
    device : Device,
    queryPool : QueryPool,
    pAllocator : *AllocationCallbacks
) -> void #foreign libvulkan "vkDestroyQueryPool";

get_query_pool_results :: (
    device : Device,
    queryPool : QueryPool,
    firstQuery : u32,
    queryCount : u32,
    dataSize : u64,
    pData : *void,
    stride : DeviceSize,
    flags : QueryResultFlags
) -> Result #foreign libvulkan "vkGetQueryPoolResults";

create_buffer :: (
    device : Device,
    pCreateInfo : *BufferCreateInfo,
    pAllocator : *AllocationCallbacks,
    pBuffer : *Buffer
) -> Result #foreign libvulkan "vkCreateBuffer";

destroy_buffer :: (
    device : Device,
    buffer : Buffer,
    pAllocator : *AllocationCallbacks
) -> void #foreign libvulkan "vkDestroyBuffer";

create_buffer_view :: (
    device : Device,
    pCreateInfo : *BufferViewCreateInfo,
    pAllocator : *AllocationCallbacks,
    pView : *BufferView
) -> Result #foreign libvulkan "vkCreateBufferView";

destroy_buffer_view :: (
    device : Device,
    bufferView : BufferView,
    pAllocator : *AllocationCallbacks
) -> void #foreign libvulkan "vkDestroyBufferView";

create_image :: (
    device : Device,
    pCreateInfo : *ImageCreateInfo,
    pAllocator : *AllocationCallbacks,
    pImage : *Image
) -> Result #foreign libvulkan "vkCreateImage";

destroy_image :: (
    device : Device,
    image : Image,
    pAllocator : *AllocationCallbacks
) -> void #foreign libvulkan "vkDestroyImage";

get_image_subresource_layout :: (
    device : Device,
    image : Image,
    pSubresource : *ImageSubresource,
    pLayout : *SubresourceLayout
) -> void #foreign libvulkan "vkGetImageSubresourceLayout";

create_image_view :: (
    device : Device,
    pCreateInfo : *ImageViewCreateInfo,
    pAllocator : *AllocationCallbacks,
    pView : *ImageView
) -> Result #foreign libvulkan "vkCreateImageView";

destroy_image_view :: (
    device : Device,
    imageView : ImageView,
    pAllocator : *AllocationCallbacks
) -> void #foreign libvulkan "vkDestroyImageView";

create_shader_module :: (
    device : Device,
    pCreateInfo : *ShaderModuleCreateInfo,
    pAllocator : *AllocationCallbacks,
    pShaderModule : *ShaderModule
) -> Result #foreign libvulkan "vkCreateShaderModule";

destroy_shader_module :: (
    device : Device,
    shaderModule : ShaderModule,
    pAllocator : *AllocationCallbacks
) -> void #foreign libvulkan "vkDestroyShaderModule";

create_pipeline_cache :: (
    device : Device,
    pCreateInfo : *PipelineCacheCreateInfo,
    pAllocator : *AllocationCallbacks,
    pPipelineCache : *PipelineCache
) -> Result #foreign libvulkan "vkCreatePipelineCache";

destroy_pipeline_cache :: (
    device : Device,
    pipelineCache : PipelineCache,
    pAllocator : *AllocationCallbacks
) -> void #foreign libvulkan "vkDestroyPipelineCache";

get_pipeline_cache_data :: (
    device : Device,
    pipelineCache : PipelineCache,
    pDataSize : *u64,
    pData : *void
) -> Result #foreign libvulkan "vkGetPipelineCacheData";

merge_pipeline_caches :: (
    device : Device,
    dstCache : PipelineCache,
    srcCacheCount : u32,
    pSrcCaches : *PipelineCache
) -> Result #foreign libvulkan "vkMergePipelineCaches";

create_graphics_pipelines :: (
    device : Device,
    pipelineCache : PipelineCache,
    createInfoCount : u32,
    pCreateInfos : *GraphicsPipelineCreateInfo,
    pAllocator : *AllocationCallbacks,
    pPipelines : *Pipeline
) -> Result #foreign libvulkan "vkCreateGraphicsPipelines";

create_compute_pipelines :: (
    device : Device,
    pipelineCache : PipelineCache,
    createInfoCount : u32,
    pCreateInfos : *ComputePipelineCreateInfo,
    pAllocator : *AllocationCallbacks,
    pPipelines : *Pipeline
) -> Result #foreign libvulkan "vkCreateComputePipelines";

destroy_pipeline :: (
    device : Device,
    pipeline : Pipeline,
    pAllocator : *AllocationCallbacks
) -> void #foreign libvulkan "vkDestroyPipeline";

create_pipeline_layout :: (
    device : Device,
    pCreateInfo : *PipelineLayoutCreateInfo,
    pAllocator : *AllocationCallbacks,
    pPipelineLayout : *PipelineLayout
) -> Result #foreign libvulkan "vkCreatePipelineLayout";

destroy_pipeline_layout :: (
    device : Device,
    pipelineLayout : PipelineLayout,
    pAllocator : *AllocationCallbacks
) -> void #foreign libvulkan "vkDestroyPipelineLayout";

create_sampler :: (
    device : Device,
    pCreateInfo : *SamplerCreateInfo,
    pAllocator : *AllocationCallbacks,
    pSampler : *Sampler
) -> Result #foreign libvulkan "vkCreateSampler";

destroy_sampler :: (
    device : Device,
    sampler : Sampler,
    pAllocator : *AllocationCallbacks
) -> void #foreign libvulkan "vkDestroySampler";

create_descriptor_set_layout :: (
    device : Device,
    pCreateInfo : *DescriptorSetLayoutCreateInfo,
    pAllocator : *AllocationCallbacks,
    pSetLayout : *DescriptorSetLayout
) -> Result #foreign libvulkan "vkCreateDescriptorSetLayout";

destroy_descriptor_set_layout :: (
    device : Device,
    descriptorSetLayout : DescriptorSetLayout,
    pAllocator : *AllocationCallbacks
) -> void #foreign libvulkan "vkDestroyDescriptorSetLayout";

create_descriptor_pool :: (
    device : Device,
    pCreateInfo : *DescriptorPoolCreateInfo,
    pAllocator : *AllocationCallbacks,
    pDescriptorPool : *DescriptorPool
) -> Result #foreign libvulkan "vkCreateDescriptorPool";

destroy_descriptor_pool :: (
    device : Device,
    descriptorPool : DescriptorPool,
    pAllocator : *AllocationCallbacks
) -> void #foreign libvulkan "vkDestroyDescriptorPool";

reset_descriptor_pool :: (
    device : Device,
    descriptorPool : DescriptorPool,
    flags : DescriptorPoolResetFlags
) -> Result #foreign libvulkan "vkResetDescriptorPool";

allocate_descriptor_sets :: (
    device : Device,
    pAllocateInfo : *DescriptorSetAllocateInfo,
    pDescriptorSets : *DescriptorSet
) -> Result #foreign libvulkan "vkAllocateDescriptorSets";

free_descriptor_sets :: (
    device : Device,
    descriptorPool : DescriptorPool,
    descriptorSetCount : u32,
    pDescriptorSets : *DescriptorSet
) -> Result #foreign libvulkan "vkFreeDescriptorSets";

update_descriptor_sets :: (
    device : Device,
    descriptorWriteCount : u32,
    pDescriptorWrites : *WriteDescriptorSet,
    descriptorCopyCount : u32,
    pDescriptorCopies : *CopyDescriptorSet
) -> void #foreign libvulkan "vkUpdateDescriptorSets";

create_framebuffer :: (
    device : Device,
    pCreateInfo : *FramebufferCreateInfo,
    pAllocator : *AllocationCallbacks,
    pFramebuffer : *Framebuffer
) -> Result #foreign libvulkan "vkCreateFramebuffer";

destroy_framebuffer :: (
    device : Device,
    framebuffer : Framebuffer,
    pAllocator : *AllocationCallbacks
) -> void #foreign libvulkan "vkDestroyFramebuffer";

create_render_pass :: (
    device : Device,
    pCreateInfo : *RenderPassCreateInfo,
    pAllocator : *AllocationCallbacks,
    pRenderPass : *RenderPass
) -> Result #foreign libvulkan "vkCreateRenderPass";

destroy_render_pass :: (
    device : Device,
    renderPass : RenderPass,
    pAllocator : *AllocationCallbacks
) -> void #foreign libvulkan "vkDestroyRenderPass";

get_render_area_granularity :: (
    device : Device,
    renderPass : RenderPass,
    pGranularity : *Extent2D
) -> void #foreign libvulkan "vkGetRenderAreaGranularity";

create_command_pool :: (
    device : Device,
    pCreateInfo : *CommandPoolCreateInfo,
    pAllocator : *AllocationCallbacks,
    pCommandPool : *CommandPool
) -> Result #foreign libvulkan "vkCreateCommandPool";

destroy_command_pool :: (
    device : Device,
    commandPool : CommandPool,
    pAllocator : *AllocationCallbacks
) -> void #foreign libvulkan "vkDestroyCommandPool";

reset_command_pool :: (
    device : Device,
    commandPool : CommandPool,
    flags : CommandPoolResetFlags
) -> Result #foreign libvulkan "vkResetCommandPool";

allocate_command_buffers :: (
    device : Device,
    pAllocateInfo : *CommandBufferAllocateInfo,
    pCommandBuffers : *CommandBuffer
) -> Result #foreign libvulkan "vkAllocateCommandBuffers";

free_command_buffers :: (
    device : Device,
    commandPool : CommandPool,
    commandBufferCount : u32,
    pCommandBuffers : *CommandBuffer
) -> void #foreign libvulkan "vkFreeCommandBuffers";

begin_command_buffer :: (
    commandBuffer : CommandBuffer,
    pBeginInfo : *CommandBufferBeginInfo
) -> Result #foreign libvulkan "vkBeginCommandBuffer";

end_command_buffer :: (commandBuffer : CommandBuffer) -> Result #foreign libvulkan "vkEndCommandBuffer";

reset_command_buffer :: (
    commandBuffer : CommandBuffer,
    flags : CommandBufferResetFlags
) -> Result #foreign libvulkan "vkResetCommandBuffer";

cmd_bind_pipeline :: (
    commandBuffer : CommandBuffer,
    pipelineBindPoint : PipelineBindPoint,
    pipeline : Pipeline
) -> void #foreign libvulkan "vkCmdBindPipeline";

cmd_set_viewport :: (
    commandBuffer : CommandBuffer,
    firstViewport : u32,
    viewportCount : u32,
    pViewports : *Viewport
) -> void #foreign libvulkan "vkCmdSetViewport";

cmd_set_scissor :: (
    commandBuffer : CommandBuffer,
    firstScissor : u32,
    scissorCount : u32,
    pScissors : *Rect2D
) -> void #foreign libvulkan "vkCmdSetScissor";

cmd_set_line_width :: (
    commandBuffer : CommandBuffer,
    lineWidth : float32
) -> void #foreign libvulkan "vkCmdSetLineWidth";

cmd_set_depth_bias :: (
    commandBuffer : CommandBuffer,
    depthBiasConstantFactor : float32,
    depthBiasClamp : float32,
    depthBiasSlopeFactor : float32
) -> void #foreign libvulkan "vkCmdSetDepthBias";

cmd_set_blend_constants :: (
    commandBuffer : CommandBuffer,
    blendConstants : *float32
) -> void #foreign libvulkan "vkCmdSetBlendConstants";

cmd_set_depth_bounds :: (
    commandBuffer : CommandBuffer,
    minDepthBounds : float32,
    maxDepthBounds : float32
) -> void #foreign libvulkan "vkCmdSetDepthBounds";

cmd_set_stencil_compare_mask :: (
    commandBuffer : CommandBuffer,
    faceMask : StencilFaceFlags,
    compareMask : u32
) -> void #foreign libvulkan "vkCmdSetStencilCompareMask";

cmd_set_stencil_write_mask :: (
    commandBuffer : CommandBuffer,
    faceMask : StencilFaceFlags,
    writeMask : u32
) -> void #foreign libvulkan "vkCmdSetStencilWriteMask";

cmd_set_stencil_reference :: (
    commandBuffer : CommandBuffer,
    faceMask : StencilFaceFlags,
    reference : u32
) -> void #foreign libvulkan "vkCmdSetStencilReference";

cmd_bind_descriptor_sets :: (
    commandBuffer : CommandBuffer,
    pipelineBindPoint : PipelineBindPoint,
    layout : PipelineLayout,
    firstSet : u32,
    descriptorSetCount : u32,
    pDescriptorSets : *DescriptorSet,
    dynamicOffsetCount : u32,
    pDynamicOffsets : *u32
) -> void #foreign libvulkan "vkCmdBindDescriptorSets";

cmd_bind_index_buffer :: (
    commandBuffer : CommandBuffer,
    buffer : Buffer,
    offset : DeviceSize,
    indexType : IndexType
) -> void #foreign libvulkan "vkCmdBindIndexBuffer";

cmd_bind_vertex_buffers :: (
    commandBuffer : CommandBuffer,
    firstBinding : u32,
    bindingCount : u32,
    pBuffers : *Buffer,
    pOffsets : *DeviceSize
) -> void #foreign libvulkan "vkCmdBindVertexBuffers";

cmd_draw :: (
    commandBuffer : CommandBuffer,
    vertexCount : u32,
    instanceCount : u32,
    firstVertex : u32,
    firstInstance : u32
) -> void #foreign libvulkan "vkCmdDraw";

cmd_draw_indexed :: (
    commandBuffer : CommandBuffer,
    indexCount : u32,
    instanceCount : u32,
    firstIndex : u32,
    vertexOffset : s32,
    firstInstance : u32
) -> void #foreign libvulkan "vkCmdDrawIndexed";

cmd_draw_indirect :: (
    commandBuffer : CommandBuffer,
    buffer : Buffer,
    offset : DeviceSize,
    drawCount : u32,
    stride : u32
) -> void #foreign libvulkan "vkCmdDrawIndirect";

cmd_draw_indexed_indirect :: (
    commandBuffer : CommandBuffer,
    buffer : Buffer,
    offset : DeviceSize,
    drawCount : u32,
    stride : u32
) -> void #foreign libvulkan "vkCmdDrawIndexedIndirect";

cmd_dispatch :: (
    commandBuffer : CommandBuffer,
    groupCountX : u32,
    groupCountY : u32,
    groupCountZ : u32
) -> void #foreign libvulkan "vkCmdDispatch";

cmd_dispatch_indirect :: (
    commandBuffer : CommandBuffer,
    buffer : Buffer,
    offset : DeviceSize
) -> void #foreign libvulkan "vkCmdDispatchIndirect";

cmd_copy_buffer :: (
    commandBuffer : CommandBuffer,
    srcBuffer : Buffer,
    dstBuffer : Buffer,
    regionCount : u32,
    pRegions : *BufferCopy
) -> void #foreign libvulkan "vkCmdCopyBuffer";

cmd_copy_image :: (
    commandBuffer : CommandBuffer,
    srcImage : Image,
    srcImageLayout : ImageLayout,
    dstImage : Image,
    dstImageLayout : ImageLayout,
    regionCount : u32,
    pRegions : *ImageCopy
) -> void #foreign libvulkan "vkCmdCopyImage";

cmd_blit_image :: (
    commandBuffer : CommandBuffer,
    srcImage : Image,
    srcImageLayout : ImageLayout,
    dstImage : Image,
    dstImageLayout : ImageLayout,
    regionCount : u32,
    pRegions : *ImageBlit,
    filter : Filter
) -> void #foreign libvulkan "vkCmdBlitImage";

cmd_copy_buffer_to_image :: (
    commandBuffer : CommandBuffer,
    srcBuffer : Buffer,
    dstImage : Image,
    dstImageLayout : ImageLayout,
    regionCount : u32,
    pRegions : *BufferImageCopy
) -> void #foreign libvulkan "vkCmdCopyBufferToImage";

cmd_copy_image_to_buffer :: (
    commandBuffer : CommandBuffer,
    srcImage : Image,
    srcImageLayout : ImageLayout,
    dstBuffer : Buffer,
    regionCount : u32,
    pRegions : *BufferImageCopy
) -> void #foreign libvulkan "vkCmdCopyImageToBuffer";

cmd_update_buffer :: (
    commandBuffer : CommandBuffer,
    dstBuffer : Buffer,
    dstOffset : DeviceSize,
    dataSize : DeviceSize,
    pData : *void
) -> void #foreign libvulkan "vkCmdUpdateBuffer";

cmd_fill_buffer :: (
    commandBuffer : CommandBuffer,
    dstBuffer : Buffer,
    dstOffset : DeviceSize,
    size : DeviceSize,
    data : u32
) -> void #foreign libvulkan "vkCmdFillBuffer";

cmd_clear_color_image :: (
    commandBuffer : CommandBuffer,
    image : Image,
    imageLayout : ImageLayout,
    pColor : *ClearColorValue,
    rangeCount : u32,
    pRanges : *ImageSubresourceRange
) -> void #foreign libvulkan "vkCmdClearColorImage";

cmd_clear_depth_stencil_image :: (
    commandBuffer : CommandBuffer,
    image : Image,
    imageLayout : ImageLayout,
    pDepthStencil : *ClearDepthStencilValue,
    rangeCount : u32,
    pRanges : *ImageSubresourceRange
) -> void #foreign libvulkan "vkCmdClearDepthStencilImage";

cmd_clear_attachments :: (
    commandBuffer : CommandBuffer,
    attachmentCount : u32,
    pAttachments : *ClearAttachment,
    rectCount : u32,
    pRects : *ClearRect
) -> void #foreign libvulkan "vkCmdClearAttachments";

cmd_resolve_image :: (
    commandBuffer : CommandBuffer,
    srcImage : Image,
    srcImageLayout : ImageLayout,
    dstImage : Image,
    dstImageLayout : ImageLayout,
    regionCount : u32,
    pRegions : *ImageResolve
) -> void #foreign libvulkan "vkCmdResolveImage";

cmd_set_event :: (
    commandBuffer : CommandBuffer,
    event : Event,
    stageMask : PipelineStageFlags
) -> void #foreign libvulkan "vkCmdSetEvent";

cmd_reset_event :: (
    commandBuffer : CommandBuffer,
    event : Event,
    stageMask : PipelineStageFlags
) -> void #foreign libvulkan "vkCmdResetEvent";

cmd_wait_events :: (
    commandBuffer : CommandBuffer,
    eventCount : u32,
    pEvents : *Event,
    srcStageMask : PipelineStageFlags,
    dstStageMask : PipelineStageFlags,
    memoryBarrierCount : u32,
    pMemoryBarriers : *MemoryBarrier,
    bufferMemoryBarrierCount : u32,
    pBufferMemoryBarriers : *BufferMemoryBarrier,
    imageMemoryBarrierCount : u32,
    pImageMemoryBarriers : *ImageMemoryBarrier
) -> void #foreign libvulkan "vkCmdWaitEvents";

cmd_pipeline_barrier :: (
    commandBuffer : CommandBuffer,
    srcStageMask : PipelineStageFlags,
    dstStageMask : PipelineStageFlags,
    dependencyFlags : DependencyFlags,
    memoryBarrierCount : u32,
    pMemoryBarriers : *MemoryBarrier,
    bufferMemoryBarrierCount : u32,
    pBufferMemoryBarriers : *BufferMemoryBarrier,
    imageMemoryBarrierCount : u32,
    pImageMemoryBarriers : *ImageMemoryBarrier
) -> void #foreign libvulkan "vkCmdPipelineBarrier";

cmd_begin_query :: (
    commandBuffer : CommandBuffer,
    queryPool : QueryPool,
    query : u32,
    flags : QueryControlFlags
) -> void #foreign libvulkan "vkCmdBeginQuery";

cmd_end_query :: (
    commandBuffer : CommandBuffer,
    queryPool : QueryPool,
    query : u32
) -> void #foreign libvulkan "vkCmdEndQuery";

cmd_reset_query_pool :: (
    commandBuffer : CommandBuffer,
    queryPool : QueryPool,
    firstQuery : u32,
    queryCount : u32
) -> void #foreign libvulkan "vkCmdResetQueryPool";

cmd_write_timestamp :: (
    commandBuffer : CommandBuffer,
    pipelineStage : PipelineStageFlagBits,
    queryPool : QueryPool,
    query : u32
) -> void #foreign libvulkan "vkCmdWriteTimestamp";

cmd_copy_query_pool_results :: (
    commandBuffer : CommandBuffer,
    queryPool : QueryPool,
    firstQuery : u32,
    queryCount : u32,
    dstBuffer : Buffer,
    dstOffset : DeviceSize,
    stride : DeviceSize,
    flags : QueryResultFlags
) -> void #foreign libvulkan "vkCmdCopyQueryPoolResults";

cmd_push_constants :: (
    commandBuffer : CommandBuffer,
    layout : PipelineLayout,
    stageFlags : ShaderStageFlags,
    offset : u32,
    size : u32,
    pValues : *void
) -> void #foreign libvulkan "vkCmdPushConstants";

cmd_begin_render_pass :: (
    commandBuffer : CommandBuffer,
    pRenderPassBegin : *RenderPassBeginInfo,
    contents : SubpassContents
) -> void #foreign libvulkan "vkCmdBeginRenderPass";

cmd_next_subpass :: (
    commandBuffer : CommandBuffer,
    contents : SubpassContents
) -> void #foreign libvulkan "vkCmdNextSubpass";

cmd_end_render_pass :: (commandBuffer : CommandBuffer) -> void #foreign libvulkan "vkCmdEndRenderPass";

cmd_execute_commands :: (
    commandBuffer : CommandBuffer,
    commandBufferCount : u32,
    pCommandBuffers : *CommandBuffer
) -> void #foreign libvulkan "vkCmdExecuteCommands";

enumerate_instance_version :: (pApiVersion : *u32) -> Result #foreign libvulkan "vkEnumerateInstanceVersion";

bind_buffer_memory2 :: (
    device : Device,
    bindInfoCount : u32,
    pBindInfos : *BindBufferMemoryInfo
) -> Result #foreign libvulkan "vkBindBufferMemory2";

bind_image_memory2 :: (
    device : Device,
    bindInfoCount : u32,
    pBindInfos : *BindImageMemoryInfo
) -> Result #foreign libvulkan "vkBindImageMemory2";

get_device_group_peer_memory_features :: (
    device : Device,
    heapIndex : u32,
    localDeviceIndex : u32,
    remoteDeviceIndex : u32,
    pPeerMemoryFeatures : *PeerMemoryFeatureFlags
) -> void #foreign libvulkan "vkGetDeviceGroupPeerMemoryFeatures";

cmd_set_device_mask :: (
    commandBuffer : CommandBuffer,
    deviceMask : u32
) -> void #foreign libvulkan "vkCmdSetDeviceMask";

cmd_dispatch_base :: (
    commandBuffer : CommandBuffer,
    baseGroupX : u32,
    baseGroupY : u32,
    baseGroupZ : u32,
    groupCountX : u32,
    groupCountY : u32,
    groupCountZ : u32
) -> void #foreign libvulkan "vkCmdDispatchBase";

enumerate_physical_device_groups :: (
    instance : Instance,
    pPhysicalDeviceGroupCount : *u32,
    pPhysicalDeviceGroupProperties : *PhysicalDeviceGroupProperties
) -> Result #foreign libvulkan "vkEnumeratePhysicalDeviceGroups";

get_image_memory_requirements2 :: (
    device : Device,
    pInfo : *ImageMemoryRequirementsInfo2,
    pMemoryRequirements : *MemoryRequirements2
) -> void #foreign libvulkan "vkGetImageMemoryRequirements2";

get_buffer_memory_requirements2 :: (
    device : Device,
    pInfo : *BufferMemoryRequirementsInfo2,
    pMemoryRequirements : *MemoryRequirements2
) -> void #foreign libvulkan "vkGetBufferMemoryRequirements2";

get_image_sparse_memory_requirements2 :: (
    device : Device,
    pInfo : *ImageSparseMemoryRequirementsInfo2,
    pSparseMemoryRequirementCount : *u32,
    pSparseMemoryRequirements : *SparseImageMemoryRequirements2
) -> void #foreign libvulkan "vkGetImageSparseMemoryRequirements2";

get_physical_device_features2 :: (
    physicalDevice : PhysicalDevice,
    pFeatures : *PhysicalDeviceFeatures2
) -> void #foreign libvulkan "vkGetPhysicalDeviceFeatures2";

get_physical_device_properties2 :: (
    physicalDevice : PhysicalDevice,
    pProperties : *PhysicalDeviceProperties2
) -> void #foreign libvulkan "vkGetPhysicalDeviceProperties2";

get_physical_device_format_properties2 :: (
    physicalDevice : PhysicalDevice,
    format : Format,
    pFormatProperties : *FormatProperties2
) -> void #foreign libvulkan "vkGetPhysicalDeviceFormatProperties2";

get_physical_device_image_format_properties2 :: (
    physicalDevice : PhysicalDevice,
    pImageFormatInfo : *PhysicalDeviceImageFormatInfo2,
    pImageFormatProperties : *ImageFormatProperties2
) -> Result #foreign libvulkan "vkGetPhysicalDeviceImageFormatProperties2";

get_physical_device_queue_family_properties2 :: (
    physicalDevice : PhysicalDevice,
    pQueueFamilyPropertyCount : *u32,
    pQueueFamilyProperties : *QueueFamilyProperties2
) -> void #foreign libvulkan "vkGetPhysicalDeviceQueueFamilyProperties2";

get_physical_device_memory_properties2 :: (
    physicalDevice : PhysicalDevice,
    pMemoryProperties : *PhysicalDeviceMemoryProperties2
) -> void #foreign libvulkan "vkGetPhysicalDeviceMemoryProperties2";

get_physical_device_sparse_image_format_properties2 :: (
    physicalDevice : PhysicalDevice,
    pFormatInfo : *PhysicalDeviceSparseImageFormatInfo2,
    pPropertyCount : *u32,
    pProperties : *SparseImageFormatProperties2
) -> void #foreign libvulkan "vkGetPhysicalDeviceSparseImageFormatProperties2";

trim_command_pool :: (
    device : Device,
    commandPool : CommandPool,
    flags : CommandPoolTrimFlags
) -> void #foreign libvulkan "vkTrimCommandPool";

get_device_queue2 :: (
    device : Device,
    pQueueInfo : *DeviceQueueInfo2,
    pQueue : *Queue
) -> void #foreign libvulkan "vkGetDeviceQueue2";

create_sampler_ycbcr_conversion :: (
    device : Device,
    pCreateInfo : *SamplerYcbcrConversionCreateInfo,
    pAllocator : *AllocationCallbacks,
    pYcbcrConversion : *SamplerYcbcrConversion
) -> Result #foreign libvulkan "vkCreateSamplerYcbcrConversion";

destroy_sampler_ycbcr_conversion :: (
    device : Device,
    ycbcrConversion : SamplerYcbcrConversion,
    pAllocator : *AllocationCallbacks
) -> void #foreign libvulkan "vkDestroySamplerYcbcrConversion";

create_descriptor_update_template :: (
    device : Device,
    pCreateInfo : *DescriptorUpdateTemplateCreateInfo,
    pAllocator : *AllocationCallbacks,
    pDescriptorUpdateTemplate : *DescriptorUpdateTemplate
) -> Result #foreign libvulkan "vkCreateDescriptorUpdateTemplate";

destroy_descriptor_update_template :: (
    device : Device,
    descriptorUpdateTemplate : DescriptorUpdateTemplate,
    pAllocator : *AllocationCallbacks
) -> void #foreign libvulkan "vkDestroyDescriptorUpdateTemplate";

update_descriptor_set_with_template :: (
    device : Device,
    descriptorSet : DescriptorSet,
    descriptorUpdateTemplate : DescriptorUpdateTemplate,
    pData : *void
) -> void #foreign libvulkan "vkUpdateDescriptorSetWithTemplate";

get_physical_device_external_buffer_properties :: (
    physicalDevice : PhysicalDevice,
    pExternalBufferInfo : *PhysicalDeviceExternalBufferInfo,
    pExternalBufferProperties : *ExternalBufferProperties
) -> void #foreign libvulkan "vkGetPhysicalDeviceExternalBufferProperties";

get_physical_device_external_fence_properties :: (
    physicalDevice : PhysicalDevice,
    pExternalFenceInfo : *PhysicalDeviceExternalFenceInfo,
    pExternalFenceProperties : *ExternalFenceProperties
) -> void #foreign libvulkan "vkGetPhysicalDeviceExternalFenceProperties";

get_physical_device_external_semaphore_properties :: (
    physicalDevice : PhysicalDevice,
    pExternalSemaphoreInfo : *PhysicalDeviceExternalSemaphoreInfo,
    pExternalSemaphoreProperties : *ExternalSemaphoreProperties
) -> void #foreign libvulkan "vkGetPhysicalDeviceExternalSemaphoreProperties";

get_descriptor_set_layout_support :: (
    device : Device,
    pCreateInfo : *DescriptorSetLayoutCreateInfo,
    pSupport : *DescriptorSetLayoutSupport
) -> void #foreign libvulkan "vkGetDescriptorSetLayoutSupport";

cmd_draw_indirect_count :: (
    commandBuffer : CommandBuffer,
    buffer : Buffer,
    offset : DeviceSize,
    countBuffer : Buffer,
    countBufferOffset : DeviceSize,
    maxDrawCount : u32,
    stride : u32
) -> void #foreign libvulkan "vkCmdDrawIndirectCount";

cmd_draw_indexed_indirect_count :: (
    commandBuffer : CommandBuffer,
    buffer : Buffer,
    offset : DeviceSize,
    countBuffer : Buffer,
    countBufferOffset : DeviceSize,
    maxDrawCount : u32,
    stride : u32
) -> void #foreign libvulkan "vkCmdDrawIndexedIndirectCount";

create_render_pass2 :: (
    device : Device,
    pCreateInfo : *RenderPassCreateInfo2,
    pAllocator : *AllocationCallbacks,
    pRenderPass : *RenderPass
) -> Result #foreign libvulkan "vkCreateRenderPass2";

cmd_begin_render_pass2 :: (
    commandBuffer : CommandBuffer,
    pRenderPassBegin : *RenderPassBeginInfo,
    pSubpassBeginInfo : *SubpassBeginInfo
) -> void #foreign libvulkan "vkCmdBeginRenderPass2";

cmd_next_subpass2 :: (
    commandBuffer : CommandBuffer,
    pSubpassBeginInfo : *SubpassBeginInfo,
    pSubpassEndInfo : *SubpassEndInfo
) -> void #foreign libvulkan "vkCmdNextSubpass2";

cmd_end_render_pass2 :: (
    commandBuffer : CommandBuffer,
    pSubpassEndInfo : *SubpassEndInfo
) -> void #foreign libvulkan "vkCmdEndRenderPass2";

reset_query_pool :: (
    device : Device,
    queryPool : QueryPool,
    firstQuery : u32,
    queryCount : u32
) -> void #foreign libvulkan "vkResetQueryPool";

get_semaphore_counter_value :: (
    device : Device,
    semaphore : Semaphore,
    pValue : *u64
) -> Result #foreign libvulkan "vkGetSemaphoreCounterValue";

wait_semaphores :: (
    device : Device,
    pWaitInfo : *SemaphoreWaitInfo,
    timeout : u64
) -> Result #foreign libvulkan "vkWaitSemaphores";

signal_semaphore :: (
    device : Device,
    pSignalInfo : *SemaphoreSignalInfo
) -> Result #foreign libvulkan "vkSignalSemaphore";

get_buffer_device_address :: (
    device : Device,
    pInfo : *BufferDeviceAddressInfo
) -> DeviceAddress #foreign libvulkan "vkGetBufferDeviceAddress";

get_buffer_opaque_capture_address :: (
    device : Device,
    pInfo : *BufferDeviceAddressInfo
) -> u64 #foreign libvulkan "vkGetBufferOpaqueCaptureAddress";

get_device_memory_opaque_capture_address :: (
    device : Device,
    pInfo : *DeviceMemoryOpaqueCaptureAddressInfo
) -> u64 #foreign libvulkan "vkGetDeviceMemoryOpaqueCaptureAddress";

destroy_surface_khr :: (
    instance : Instance,
    surface : SurfaceKHR,
    pAllocator : *AllocationCallbacks
) -> void #foreign libvulkan "vkDestroySurfaceKHR";

get_physical_device_surface_support_khr :: (
    physicalDevice : PhysicalDevice,
    queueFamilyIndex : u32,
    surface : SurfaceKHR,
    pSupported : *Bool32
) -> Result #foreign libvulkan "vkGetPhysicalDeviceSurfaceSupportKHR";

get_physical_device_surface_capabilities_khr :: (
    physicalDevice : PhysicalDevice,
    surface : SurfaceKHR,
    pSurfaceCapabilities : *SurfaceCapabilitiesKHR
) -> Result #foreign libvulkan "vkGetPhysicalDeviceSurfaceCapabilitiesKHR";

get_physical_device_surface_formats_khr :: (
    physicalDevice : PhysicalDevice,
    surface : SurfaceKHR,
    pSurfaceFormatCount : *u32,
    pSurfaceFormats : *SurfaceFormatKHR
) -> Result #foreign libvulkan "vkGetPhysicalDeviceSurfaceFormatsKHR";

get_physical_device_surface_present_modes_khr :: (
    physicalDevice : PhysicalDevice,
    surface : SurfaceKHR,
    pPresentModeCount : *u32,
    pPresentModes : *PresentModeKHR
) -> Result #foreign libvulkan "vkGetPhysicalDeviceSurfacePresentModesKHR";

create_swapchain_khr :: (
    device : Device,
    pCreateInfo : *SwapchainCreateInfoKHR,
    pAllocator : *AllocationCallbacks,
    pSwapchain : *SwapchainKHR
) -> Result #foreign libvulkan "vkCreateSwapchainKHR";

destroy_swapchain_khr :: (
    device : Device,
    swapchain : SwapchainKHR,
    pAllocator : *AllocationCallbacks
) -> void #foreign libvulkan "vkDestroySwapchainKHR";

get_swapchain_images_khr :: (
    device : Device,
    swapchain : SwapchainKHR,
    pSwapchainImageCount : *u32,
    pSwapchainImages : *Image
) -> Result #foreign libvulkan "vkGetSwapchainImagesKHR";

acquire_next_image_khr :: (
    device : Device,
    swapchain : SwapchainKHR,
    timeout : u64,
    semaphore : Semaphore,
    fence : Fence,
    pImageIndex : *u32
) -> Result #foreign libvulkan "vkAcquireNextImageKHR";

queue_present_khr :: (
    queue : Queue,
    pPresentInfo : *PresentInfoKHR
) -> Result #foreign libvulkan "vkQueuePresentKHR";

get_device_group_present_capabilities_khr :: (
    device : Device,
    pDeviceGroupPresentCapabilities : *DeviceGroupPresentCapabilitiesKHR
) -> Result #foreign libvulkan "vkGetDeviceGroupPresentCapabilitiesKHR";

get_device_group_surface_present_modes_khr :: (
    device : Device,
    surface : SurfaceKHR,
    pModes : *DeviceGroupPresentModeFlagsKHR
) -> Result #foreign libvulkan "vkGetDeviceGroupSurfacePresentModesKHR";

get_physical_device_present_rectangles_khr :: (
    physicalDevice : PhysicalDevice,
    surface : SurfaceKHR,
    pRectCount : *u32,
    pRects : *Rect2D
) -> Result #foreign libvulkan "vkGetPhysicalDevicePresentRectanglesKHR";

acquire_next_image2_khr :: (
    device : Device,
    pAcquireInfo : *AcquireNextImageInfoKHR,
    pImageIndex : *u32
) -> Result #foreign libvulkan "vkAcquireNextImage2KHR";

get_physical_device_display_properties_khr :: (
    physicalDevice : PhysicalDevice,
    pPropertyCount : *u32,
    pProperties : *DisplayPropertiesKHR
) -> Result #foreign libvulkan "vkGetPhysicalDeviceDisplayPropertiesKHR";

get_physical_device_display_plane_properties_khr :: (
    physicalDevice : PhysicalDevice,
    pPropertyCount : *u32,
    pProperties : *DisplayPlanePropertiesKHR
) -> Result #foreign libvulkan "vkGetPhysicalDeviceDisplayPlanePropertiesKHR";

get_display_plane_supported_displays_khr :: (
    physicalDevice : PhysicalDevice,
    planeIndex : u32,
    pDisplayCount : *u32,
    pDisplays : *DisplayKHR
) -> Result #foreign libvulkan "vkGetDisplayPlaneSupportedDisplaysKHR";

get_display_mode_properties_khr :: (
    physicalDevice : PhysicalDevice,
    display : DisplayKHR,
    pPropertyCount : *u32,
    pProperties : *DisplayModePropertiesKHR
) -> Result #foreign libvulkan "vkGetDisplayModePropertiesKHR";

create_display_mode_khr :: (
    physicalDevice : PhysicalDevice,
    display : DisplayKHR,
    pCreateInfo : *DisplayModeCreateInfoKHR,
    pAllocator : *AllocationCallbacks,
    pMode : *DisplayModeKHR
) -> Result #foreign libvulkan "vkCreateDisplayModeKHR";

get_display_plane_capabilities_khr :: (
    physicalDevice : PhysicalDevice,
    mode : DisplayModeKHR,
    planeIndex : u32,
    pCapabilities : *DisplayPlaneCapabilitiesKHR
) -> Result #foreign libvulkan "vkGetDisplayPlaneCapabilitiesKHR";

create_display_plane_surface_khr :: (
    instance : Instance,
    pCreateInfo : *DisplaySurfaceCreateInfoKHR,
    pAllocator : *AllocationCallbacks,
    pSurface : *SurfaceKHR
) -> Result #foreign libvulkan "vkCreateDisplayPlaneSurfaceKHR";

create_shared_swapchains_khr :: (
    device : Device,
    swapchainCount : u32,
    pCreateInfos : *SwapchainCreateInfoKHR,
    pAllocator : *AllocationCallbacks,
    pSwapchains : *SwapchainKHR
) -> Result #foreign libvulkan "vkCreateSharedSwapchainsKHR";

get_physical_device_surface_formats2_khr :: (
    physicalDevice : PhysicalDevice,
    pSurfaceInfo : *PhysicalDeviceSurfaceInfo2KHR,
    pSurfaceFormatCount : *u32,
    pSurfaceFormats : *SurfaceFormat2KHR
) -> Result #foreign libvulkan "vkGetPhysicalDeviceSurfaceFormats2KHR";

get_physical_device_display_properties2_khr :: (
    physicalDevice : PhysicalDevice,
    pPropertyCount : *u32,
    pProperties : *DisplayProperties2KHR
) -> Result #foreign libvulkan "vkGetPhysicalDeviceDisplayProperties2KHR";

get_physical_device_display_plane_properties2_khr :: (
    physicalDevice : PhysicalDevice,
    pPropertyCount : *u32,
    pProperties : *DisplayPlaneProperties2KHR
) -> Result #foreign libvulkan "vkGetPhysicalDeviceDisplayPlaneProperties2KHR";

get_display_mode_properties2_khr :: (
    physicalDevice : PhysicalDevice,
    display : DisplayKHR,
    pPropertyCount : *u32,
    pProperties : *DisplayModeProperties2KHR
) -> Result #foreign libvulkan "vkGetDisplayModeProperties2KHR";

get_display_plane_capabilities2_khr :: (
    physicalDevice : PhysicalDevice,
    pDisplayPlaneInfo : *DisplayPlaneInfo2KHR,
    pCapabilities : *DisplayPlaneCapabilities2KHR
) -> Result #foreign libvulkan "vkGetDisplayPlaneCapabilities2KHR";

create_debug_report_callback_ext : (
    instance : Instance,
    pCreateInfo : *DebugReportCallbackCreateInfoEXT,
    pAllocator : *AllocationCallbacks,
    pCallback : *DebugReportCallbackEXT
) -> Result #c_call; //  libvulkan "vkCreateDebugReportCallbackEXT";

destroy_debug_report_callback_ext : (
    instance : Instance,
    callback : DebugReportCallbackEXT,
    pAllocator : *AllocationCallbacks
) -> void #c_call; // libvulkan "vkDestroyDebugReportCallbackEXT";

set_debug_utils_object_name_ext : (
    device : Device,
    pNameInfo : *DebugUtilsObjectNameInfoEXT
) -> Result #c_call; // libvulkan "vkSetDebugUtilsObjectNameEXT";

get_ray_tracing_shader_group_handles_khr : (
    device : Device,
    pipeline : Pipeline,
    firstGroup : u32,
    groupCount : u32,
    dataSize : u64,
    pData : *void
) -> Result #c_call; // libvulkan "vkGetRayTracingShaderGroupHandlesKHR";

create_acceleration_structure_khr : (
    device : Device,
    pCreateInfo : *AccelerationStructureCreateInfoKHR,
    pAllocator : *AllocationCallbacks,
    pAccelerationStructure : *AccelerationStructureKHR
) -> Result #c_call; // libvulkan "vkCreateAccelerationStructureKHR";

destroy_acceleration_structure_khr : (
    device : Device,
    accelerationStructure : AccelerationStructureKHR,
    pAllocator : *AllocationCallbacks
) -> void #c_call; // libvulkan "vkDestroyAccelerationStructureKHR";

cmd_build_acceleration_structures_khr : (
    commandBuffer : CommandBuffer,
    infoCount : u32,
    pInfos : *AccelerationStructureBuildGeometryInfoKHR,
    ppBuildRangeInfos : **AccelerationStructureBuildRangeInfoKHR
) -> void #c_call; // libvulkan "vkCmdBuildAccelerationStructuresKHR";

get_acceleration_structure_device_address_khr : (
    device : Device,
    pInfo : *AccelerationStructureDeviceAddressInfoKHR
) -> DeviceAddress #c_call; // libvulkan "vkGetAccelerationStructureDeviceAddressKHR";

get_acceleration_structure_build_sizes_khr : (
    device : Device,
    buildType : AccelerationStructureBuildTypeKHR,
    pBuildInfo : *AccelerationStructureBuildGeometryInfoKHR,
    pMaxPrimitiveCounts : *u32,
    pSizeInfo : *AccelerationStructureBuildSizesInfoKHR
) -> void #c_call; // libvulkan "vkGetAccelerationStructureBuildSizesKHR";

cmd_trace_rays_khr : (
    commandBuffer : CommandBuffer,
    pRaygenShaderBindingTable : *StridedDeviceAddressRegionKHR,
    pMissShaderBindingTable : *StridedDeviceAddressRegionKHR,
    pHitShaderBindingTable : *StridedDeviceAddressRegionKHR,
    pCallableShaderBindingTable : *StridedDeviceAddressRegionKHR,
    width : u32,
    height : u32,
    depth : u32
) -> void #c_call; // libvulkan "vkCmdTraceRaysKHR";

create_ray_tracing_pipelines_khr : (
    device : Device,
    deferredOperation : DeferredOperationKHR,
    pipelineCache : PipelineCache,
    createInfoCount : u32,
    pCreateInfos : *RayTracingPipelineCreateInfoKHR,
    pAllocator : *AllocationCallbacks,
    pPipelines : *Pipeline
) -> Result #c_call; // libvulkan "vkCreateRayTracingPipelinesKHR";

get_descriptor_set_layout_size_ext : (
    device : Device,
    layout : DescriptorSetLayout,
    pLayoutSizeInBytes : *DeviceSize
) -> void #c_call; // libvulkan "vkGetDescriptorSetLayoutSizeEXT";

cmd_bind_descriptor_buffers_ext : (
    commandBuffer : CommandBuffer,
    bufferCount : u32,
    pBindingInfos : *DescriptorBufferBindingInfoEXT
) -> void #c_call; // libvulkan "vkCmdBindDescriptorBuffersEXT";

cmd_set_descriptor_buffer_offsets_ext : (
    commandBuffer : CommandBuffer,
    pipelineBindPoint : PipelineBindPoint,
    layout : PipelineLayout,
    firstSet : u32,
    setCount : u32,
    pBufferIndices : *u32,
    pOffsets : *DeviceSize
) -> void #c_call; // libvulkan "vkCmdSetDescriptorBufferOffsetsEXT";

get_descriptor_ext : (
    device : Device,
    pDescriptorInfo : *DescriptorGetInfoEXT,
    dataSize : u64,
    pDescriptor : *void
) -> void #c_call; // libvulkan "vkGetDescriptorEXT";

get_descriptor_set_layout_binding_offset_ext : (
    device : Device,
    layout : DescriptorSetLayout,
    binding : u32,
    pOffset : *DeviceSize
) -> void #c_call; // libvulkan "vkGetDescriptorSetLayoutBindingOffsetEXT";
